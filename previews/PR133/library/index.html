<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · MatrixAlgebraKit.jl</title><meta name="title" content="Library · MatrixAlgebraKit.jl"/><meta property="og:title" content="Library · MatrixAlgebraKit.jl"/><meta property="twitter:title" content="Library · MatrixAlgebraKit.jl"/><meta name="description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="og:description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="twitter:description" content="Documentation for MatrixAlgebraKit.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MatrixAlgebraKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../user_interface/compositions/">Compositions</a></li><li><a class="tocitem" href="../user_interface/decompositions/">Decompositions</a></li><li><a class="tocitem" href="../user_interface/truncations/">Truncations</a></li><li><a class="tocitem" href="../user_interface/properties/">Matrix Properties</a></li><li><a class="tocitem" href="../user_interface/matrix_functions/">Matrix functions</a></li></ul></li><li><a class="tocitem" href="../dev_interface/">Developer Interface</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Constants-and-types"><span>Constants and types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Other"><span>Other</span></a></li></ul></li><li><a class="tocitem" href="../changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-documentation"><a class="docs-heading-anchor" href="#Library-documentation">Library documentation</a><a id="Library-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-documentation" title="Permalink"></a></h1><h2 id="Constants-and-types"><a class="docs-heading-anchor" href="#Constants-and-types">Constants and types</a><a id="Constants-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Constants-and-types" title="Permalink"></a></h2><article><details class="docstring"><summary id="MatrixAlgebraKit.AbstractAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.AbstractAlgorithm"><code>MatrixAlgebraKit.AbstractAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractAlgorithm end</code></pre><p>Supertype to dispatch on specific implementations of different the different functions. Concrete subtypes should represent both a way to dispatch to a given implementation, as well as the configuration of that implementation.</p><p>See also <a href="#MatrixAlgebraKit.select_algorithm"><code>select_algorithm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L1-L9">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.Algorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.Algorithm"><code>MatrixAlgebraKit.Algorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Algorithm{name,KW} &lt;: AbstractAlgorithm</code></pre><p>Bare-bones implementation of an algorithm, where <code>name</code> should be a <code>Symbol</code> to dispatch on, and <code>KW</code> is typically a <code>NamedTuple</code> indicating the keyword arguments.</p><p>See also <a href="#MatrixAlgebraKit.@algdef-Tuple{Any}"><code>@algdef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L12-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_DivideAndConquer"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_DivideAndConquer"><code>MatrixAlgebraKit.CUSOLVER_DivideAndConquer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_DivideAndConquer(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the CUSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L284-L292">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_HouseholderQR"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_HouseholderQR"><code>MatrixAlgebraKit.CUSOLVER_HouseholderQR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_HouseholderQR(; positive = false)</code></pre><p>Algorithm type to denote the standard CUSOLVER algorithm for computing the QR decomposition of a matrix using Householder reflectors. The keyword <code>positive = true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L214-L220">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_Jacobi"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_Jacobi"><code>MatrixAlgebraKit.CUSOLVER_Jacobi</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_Jacobi(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L245-L252">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_QRIteration"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_QRIteration"><code>MatrixAlgebraKit.CUSOLVER_QRIteration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_QRIteration(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the CUSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L223-L231">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_Randomized"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_Randomized"><code>MatrixAlgebraKit.CUSOLVER_Randomized</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_Randomized(; k, p, niters)</code></pre><p>Algorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix using the randomized SVD algorithm. Here, <code>k</code> denotes the number of singular values that should be computed, therefore requiring <code>k &lt;= min(size(A))</code>. This method is accurate for small values of <code>k</code> compared to the size of the input matrix, where the accuracy can be improved by increasing <code>p</code>, the number of additional values used for oversampling, and <code>niters</code>, the number of iterations the solver uses, at the cost of increasing the runtime.</p><p>See also the <a href="https://docs.nvidia.com/cuda/cusolver/index.html#cusolverdnxgesvdr">CUSOLVER documentation</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L255-L267">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_SVDPolar"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_SVDPolar"><code>MatrixAlgebraKit.CUSOLVER_SVDPolar</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_SVDPolar(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix by using Halley&#39;s iterative algorithm to compute the polar decompositon, followed by the hermitian eigenvalue decomposition of the positive definite factor. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L234-L242">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.CUSOLVER_Simple"><a class="docstring-binding" href="#MatrixAlgebraKit.CUSOLVER_Simple"><code>MatrixAlgebraKit.CUSOLVER_Simple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CUSOLVER_Simple(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the simple CUSOLVER driver for computing the non-Hermitian eigenvalue decomposition of a matrix. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L272-L279">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.DiagonalAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.DiagonalAlgorithm"><code>MatrixAlgebraKit.DiagonalAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiagonalAlgorithm(; kwargs...)</code></pre><p>Algorithm type to denote a native Julia implementation of the decompositions making use of the diagonal structure of the input and outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L188-L193">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.GLA_HouseholderQR"><a class="docstring-binding" href="#MatrixAlgebraKit.GLA_HouseholderQR"><code>MatrixAlgebraKit.GLA_HouseholderQR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GLA_HouseholderQR(; positive = false)</code></pre><p>Algorithm type to denote the GenericLinearAlgebra.jl implementation for computing the QR decomposition of a matrix using Householder reflectors. Currently, only <code>blocksize = 1</code> and <code>pivoted == false</code> are supported. The keyword <code>positive = true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L35-L42">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.GLA_QRIteration"><a class="docstring-binding" href="#MatrixAlgebraKit.GLA_QRIteration"><code>MatrixAlgebraKit.GLA_QRIteration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GLA_QRIteration(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the GenericLinearAlgebra.jl implementation for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L133-L141">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.GS_QRIteration"><a class="docstring-binding" href="#MatrixAlgebraKit.GS_QRIteration"><code>MatrixAlgebraKit.GS_QRIteration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GS_QRIteration()</code></pre><p>Algorithm type to denote the GenericSchur.jl implementation for computing the eigenvalue decomposition of a non-Hermitian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L73-L78">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_Bisection"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_Bisection"><code>MatrixAlgebraKit.LAPACK_Bisection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_Bisection(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L94-L102">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_DivideAndConquer"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_DivideAndConquer"><code>MatrixAlgebraKit.LAPACK_DivideAndConquer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_DivideAndConquer(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L105-L113">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_Expert"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_Expert"><code>MatrixAlgebraKit.LAPACK_Expert</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_Expert(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L61-L68">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_HouseholderLQ"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_HouseholderLQ"><code>MatrixAlgebraKit.LAPACK_HouseholderLQ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_HouseholderLQ(; blocksize, positive = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. <code>?gelqt</code> will be chosen if <code>blocksize &gt; 1</code> or <code>?gelqf</code> will be chosen if <code>blocksize == 1</code>. The keyword <code>positive = true</code> can be used to ensure that the diagonal elements of <code>L</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L24-L32">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_HouseholderQR"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_HouseholderQR"><code>MatrixAlgebraKit.LAPACK_HouseholderQR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_HouseholderQR(; blocksize, positive = false, pivoted = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  <code>?geqrt</code> will be chosen if <code>blocksize &gt; 1</code>. With <code>blocksize == 1</code>, <code>?geqrf</code> will be chosen if <code>pivoted == false</code> and <code>?geqp3</code> will be chosen if <code>pivoted == true</code>. The keyword <code>positive = true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L12-L21">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_Jacobi"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_Jacobi"><code>MatrixAlgebraKit.LAPACK_Jacobi</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_Jacobi(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L146-L153">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations"><code>MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_MultipleRelativelyRobustRepresentations(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L116-L123">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_QRIteration"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_QRIteration"><code>MatrixAlgebraKit.LAPACK_QRIteration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_QRIteration(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L83-L91">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LAPACK_Simple"><a class="docstring-binding" href="#MatrixAlgebraKit.LAPACK_Simple"><code>MatrixAlgebraKit.LAPACK_Simple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAPACK_Simple(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L51-L58">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LQViaTransposedQR"><a class="docstring-binding" href="#MatrixAlgebraKit.LQViaTransposedQR"><code>MatrixAlgebraKit.LQViaTransposedQR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LQViaTransposedQR(qr_alg)</code></pre><p>Algorithm type to denote finding the LQ decomposition of <code>A</code> by computing the QR decomposition of <code>Aᵀ</code>. The <code>qr_alg</code> specifies which QR-decomposition implementation to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L196-L201">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LeftNullAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.LeftNullAlgorithm"><code>MatrixAlgebraKit.LeftNullAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeftNullAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="#MatrixAlgebraKit.left_null"><code>left_null</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:qr</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L440-L445">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.LeftOrthAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.LeftOrthAlgorithm"><code>MatrixAlgebraKit.LeftOrthAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeftOrthAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="#MatrixAlgebraKit.left_orth"><code>left_orth</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:qr</code>, <code>:polar</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L382-L387">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.NativeBlocked"><a class="docstring-binding" href="#MatrixAlgebraKit.NativeBlocked"><code>MatrixAlgebraKit.NativeBlocked</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>NativeBlocked(; blocksize = 32)</p><p>Algorithm type to denote a native blocked algorithm with given <code>blocksize</code> for computing the hermitian or anti-hermitian part of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L49-L54">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.NoTruncation"><a class="docstring-binding" href="#MatrixAlgebraKit.NoTruncation"><code>MatrixAlgebraKit.NoTruncation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoTruncation()</code></pre><p>Trivial truncation strategy that keeps all values, mostly for testing purposes. See also <a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L79-L84">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.PolarNewton"><a class="docstring-binding" href="#MatrixAlgebraKit.PolarNewton"><code>MatrixAlgebraKit.PolarNewton</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolarNewton(; maxiter = 10, tol = defaulttol(A))</code></pre><p>Algorithm for computing the polar decomposition of a matrix <code>A</code> via scaled Newton iteration, with a maximum of <code>maxiter</code> iterations and until convergence up to tolerance <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L176-L182">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.PolarViaSVD"><a class="docstring-binding" href="#MatrixAlgebraKit.PolarViaSVD"><code>MatrixAlgebraKit.PolarViaSVD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolarViaSVD(svd_alg)</code></pre><p>Algorithm for computing the polar decomposition of a matrix <code>A</code> via the singular value decomposition (SVD) of <code>A</code>. The <code>svd_alg</code> argument specifies the SVD algorithm to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L166-L171">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.ROCSOLVER_Bisection"><a class="docstring-binding" href="#MatrixAlgebraKit.ROCSOLVER_Bisection"><code>MatrixAlgebraKit.ROCSOLVER_Bisection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROCSOLVER_Bisection(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L332-L340">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.ROCSOLVER_DivideAndConquer"><a class="docstring-binding" href="#MatrixAlgebraKit.ROCSOLVER_DivideAndConquer"><code>MatrixAlgebraKit.ROCSOLVER_DivideAndConquer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROCSOLVER_DivideAndConquer(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L343-L351">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.ROCSOLVER_HouseholderQR"><a class="docstring-binding" href="#MatrixAlgebraKit.ROCSOLVER_HouseholderQR"><code>MatrixAlgebraKit.ROCSOLVER_HouseholderQR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROCSOLVER_HouseholderQR(; positive = false)</code></pre><p>Algorithm type to denote the standard ROCSOLVER algorithm for computing the QR decomposition of a matrix using Householder reflectors. The keyword <code>positive=true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L302-L308">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.ROCSOLVER_Jacobi"><a class="docstring-binding" href="#MatrixAlgebraKit.ROCSOLVER_Jacobi"><code>MatrixAlgebraKit.ROCSOLVER_Jacobi</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROCSOLVER_Jacobi(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the ROCSOLVER driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L322-L329">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.ROCSOLVER_QRIteration"><a class="docstring-binding" href="#MatrixAlgebraKit.ROCSOLVER_QRIteration"><code>MatrixAlgebraKit.ROCSOLVER_QRIteration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROCSOLVER_QRIteration(; fixgauge::Bool = true)</code></pre><p>Algorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The <code>fixgauge</code> keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also <a href="#MatrixAlgebraKit.gaugefix!"><code>gaugefix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L311-L319">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.RightNullAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.RightNullAlgorithm"><code>MatrixAlgebraKit.RightNullAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RightNullAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="#MatrixAlgebraKit.right_null"><code>right_null</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:lq</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L468-L473">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.RightOrthAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.RightOrthAlgorithm"><code>MatrixAlgebraKit.RightOrthAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RightOrthAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="#MatrixAlgebraKit.right_orth"><code>right_orth</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:lq</code>, <code>:polar</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/decompositions.jl#L411-L416">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncatedAlgorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>MatrixAlgebraKit.TruncatedAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TruncatedAlgorithm(alg::AbstractAlgorithm, trunc::TruncationAlgorithm)</code></pre><p>Generic wrapper type for algorithms that consist of first using <code>alg</code>, followed by a truncation through <code>trunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L222-L227">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationByError"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationByError"><code>MatrixAlgebraKit.TruncationByError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TruncationByError(; atol::Real, rtol::Real, p::Real)</code></pre><p>Truncation strategy to discard values until the error caused by the discarded values exceeds some tolerances. See also <a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L163-L168">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationByFilter"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationByFilter"><code>MatrixAlgebraKit.TruncationByFilter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TruncationByFilter(filter::Function)</code></pre><p>Truncation strategy to keep the values for which <code>filter</code> returns true.</p><p>See also <a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L117-L123">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationByOrder"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationByOrder"><code>MatrixAlgebraKit.TruncationByOrder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TruncationByOrder(howmany::Int, by::Function, rev::Bool)</code></pre><p>Truncation strategy to keep the first <code>howmany</code> values when sorted according to <code>by</code> in increasing (decreasing) order if <code>rev</code> is false (true).</p><p>See also <a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L95-L101">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationByValue"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationByValue"><code>MatrixAlgebraKit.TruncationByValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TruncationByValue(atol::Real, rtol::Real, p::Real, by, keep_below::Bool=false)</code></pre><p>Truncation strategy to keep the values that satisfy <code>by(val) &gt; max(atol, rtol * norm(values, p)</code>. If <code>keep_below = true</code>, discard these values instead. See also <a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L135-L141">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationIntersection"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationIntersection"><code>MatrixAlgebraKit.TruncationIntersection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TruncationIntersection(trunc::TruncationStrategy, truncs::TruncationStrategy...)</code></pre><p>Truncation strategy that composes multiple truncation strategies, keeping values that are common between them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L188-L193">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationStrategy"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationStrategy"><code>MatrixAlgebraKit.TruncationStrategy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type TruncationStrategy end</code></pre><p>Supertype to denote different strategies for truncated decompositions that are implemented via post-truncation.</p><p>See also <a href="#MatrixAlgebraKit.truncate"><code>truncate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L148-L154">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.TruncationStrategy-Tuple{}"><a class="docstring-binding" href="#MatrixAlgebraKit.TruncationStrategy-Tuple{}"><code>MatrixAlgebraKit.TruncationStrategy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TruncationStrategy(; kwargs...)</code></pre><p>Select a truncation strategy based on the provided keyword arguments.</p><p><strong>Keyword arguments</strong></p><p>The following keyword arguments are all optional, and their default value (<code>nothing</code>) will be ignored. It is also allowed to combine multiple of these, in which case the kept values will consist of the intersection of the different truncated strategies.</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L23-L34">source</a></section></details></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article><details class="docstring"><summary id="MatrixAlgebraKit.copy_input"><a class="docstring-binding" href="#MatrixAlgebraKit.copy_input"><code>MatrixAlgebraKit.copy_input</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">copy_input(f, A)</code></pre><p>Preprocess the input <code>A</code> for a given function, such that it may be handled correctly later. This may include a copy whenever the implementation would destroy the original matrix, or a change of element type to something that is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L130-L136">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.default_algorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MatrixAlgebraKit.default_algorithm(f, A; kwargs...)
MatrixAlgebraKit.default_algorithm(f, ::Type{TA}; kwargs...) where {TA}</code></pre><p>Select the default algorithm for a given factorization function <code>f</code> and input <code>A</code>. In general, this is called by <a href="#MatrixAlgebraKit.select_algorithm"><code>select_algorithm</code></a> if no algorithm is specified explicitly. New types should prefer to register their default algorithms in the type domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L111-L119">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.default_fixgauge"><a class="docstring-binding" href="#MatrixAlgebraKit.default_fixgauge"><code>MatrixAlgebraKit.default_fixgauge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_fixgauge() -&gt; current_value
default_fixgauge(new_value::Bool) -&gt; previous_value</code></pre><p>Global toggle for enabling or disabling the default behavior of gauge fixing the output of the eigen- and singular value decompositions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/defaults.jl#L48-L53">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.default_hermitian_tol-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.default_hermitian_tol-Tuple{Any}"><code>MatrixAlgebraKit.default_hermitian_tol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_hermitian_tol(A)</code></pre><p>Default tolerance for deciding to warn if the provided <code>A</code> is not hermitian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/defaults.jl#L38-L42">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.default_pullback_degeneracy_atol-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.default_pullback_degeneracy_atol-Tuple{Any}"><code>MatrixAlgebraKit.default_pullback_degeneracy_atol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_pullback_degeneracy_atol(A)</code></pre><p>Default tolerance for deciding when values should be considered as degenerate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/defaults.jl#L24-L28">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.default_pullback_gauge_atol-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.default_pullback_gauge_atol-Tuple{Any}"><code>MatrixAlgebraKit.default_pullback_gauge_atol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_pullback_gauge_atol(ΔA...)</code></pre><p>Default tolerance for deciding to warn if incoming adjoints of a pullback rule has components that are not gauge-invariant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/defaults.jl#L12-L17">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.default_pullback_rank_atol-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.default_pullback_rank_atol-Tuple{Any}"><code>MatrixAlgebraKit.default_pullback_rank_atol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">default_pullback_rank_atol(A)</code></pre><p>Default tolerance for deciding what values should be considered equal to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/defaults.jl#L31-L35">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.defaulttol-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.defaulttol-Tuple{Any}"><code>MatrixAlgebraKit.defaulttol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">defaulttol(x)</code></pre><p>Default tolerance or precision for a given object, e.g. to decide when it can be considerd to be zero or ignored in some other way, or how accurate some quantity needs to be computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/defaults.jl#L3-L9">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.diagonal"><a class="docstring-binding" href="#MatrixAlgebraKit.diagonal"><code>MatrixAlgebraKit.diagonal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">diagonal(v)</code></pre><p>Construct a diagonal matrix view for the given diagonal vector.</p><p>See also <a href="#MatrixAlgebraKit.diagview"><code>diagview</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/view.jl#L13-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.diagview"><a class="docstring-binding" href="#MatrixAlgebraKit.diagview"><code>MatrixAlgebraKit.diagview</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">diagview(D)</code></pre><p>Return a view of the diagonal elements of a matrix <code>D</code>.</p><p>See also <a href="#MatrixAlgebraKit.diagonal"><code>diagonal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/view.jl#L2-L8">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.does_truncate-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><a class="docstring-binding" href="#MatrixAlgebraKit.does_truncate-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>MatrixAlgebraKit.does_truncate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">does_truncate(alg::AbstractAlgorithm) -&gt; Bool</code></pre><p>Indicate whether or not an algorithm will compute a truncated decomposition (such that composing the factors only approximates the input up to some tolerance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L58-L63">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_full"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_full"><code>MatrixAlgebraKit.eig_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_full(A; kwargs...) -&gt; D, V
eig_full(A, alg::AbstractAlgorithm) -&gt; D, V
eig_full!(A, [DV]; kwargs...) -&gt; D, V
eig_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the square matrix <code>A</code>, such that <code>A * V = V * D</code>, where the invertible matrix <code>V</code> contains the eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info" id="Note-98fbb562b195f5e3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-98fbb562b195f5e3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc_no_error"><code>eig_trunc_no_error</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L12-L32">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_full!"><code>MatrixAlgebraKit.eig_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_full(A; kwargs...) -&gt; D, V
eig_full(A, alg::AbstractAlgorithm) -&gt; D, V
eig_full!(A, [DV]; kwargs...) -&gt; D, V
eig_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the square matrix <code>A</code>, such that <code>A * V = V * D</code>, where the invertible matrix <code>V</code> contains the eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info" id="Note-98fbb562b195f5e3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-98fbb562b195f5e3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc_no_error"><code>eig_trunc_no_error</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L12-L32">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_pullback!"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_pullback!"><code>MatrixAlgebraKit.eig_pullback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_pullback!(
    ΔA::AbstractMatrix, A, DV, ΔDV, [ind];
    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])
)</code></pre><p>Adds the pullback from the full eigenvalue decomposition of <code>A</code> to <code>ΔA</code>, given the output <code>DV</code> of <code>eig_full</code> and the cotangent <code>ΔDV</code> of <code>eig_full</code> or <code>eig_trunc</code>.</p><p>In particular, it is assumed that <code>A ≈ V * D * inv(V)</code> with thus <code>size(A) == size(V) == size(D)</code> and <code>D</code> diagonal. For the cotangents, an arbitrary number of eigenvectors or eigenvalues can be missing, i.e. for a matrix <code>A</code> of size <code>(n, n)</code>, <code>ΔV</code> can have size <code>(n, pV)</code> and <code>diagview(ΔD)</code> can have length <code>pD</code>. In those cases, additionally <code>ind</code> is required to specify which eigenvectors or eigenvalues are present in <code>ΔV</code> or <code>ΔD</code>. By default, it is assumed that all eigenvectors and eigenvalues are present.</p><p>A warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of <code>V&#39; * ΔV</code> to rows <code>i</code> and columns <code>j</code> for which <code>abs(D[i] - D[j]) &lt; degeneracy_atol</code>, is not small compared to <code>gauge_atol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/eig.jl#L1-L21">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_trunc"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_trunc"><code>MatrixAlgebraKit.eig_trunc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_trunc(A; [trunc], kwargs...) -&gt; D, V, ϵ
eig_trunc(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eig_trunc!(A, [DV]; [trunc], kwargs...) -&gt; D, V, ϵ
eig_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded eigenvalues.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword Arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-203ded4cf50b6985"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-203ded4cf50b6985" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a>, <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc_no_error"><code>eig_trunc_no_error!</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L35-L86">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_trunc!"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_trunc!"><code>MatrixAlgebraKit.eig_trunc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_trunc(A; [trunc], kwargs...) -&gt; D, V, ϵ
eig_trunc(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eig_trunc!(A, [DV]; [trunc], kwargs...) -&gt; D, V, ϵ
eig_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded eigenvalues.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword Arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-203ded4cf50b6985"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-203ded4cf50b6985" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a>, <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc_no_error"><code>eig_trunc_no_error!</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L35-L86">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_trunc_no_error"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_trunc_no_error"><code>MatrixAlgebraKit.eig_trunc_no_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_trunc_no_error(A; [trunc], kwargs...) -&gt; D, V
eig_trunc_no_error(A, alg::AbstractAlgorithm) -&gt; D, V
eig_trunc_no_error!(A, [DV]; [trunc], kwargs...) -&gt; D, V
eig_trunc_no_error!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy. The truncation error is <em>not</em> returned.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword Arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-203ded4cf50b6985"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-203ded4cf50b6985" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a>, <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L89-L137">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_trunc_no_error!"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_trunc_no_error!"><code>MatrixAlgebraKit.eig_trunc_no_error!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_trunc_no_error(A; [trunc], kwargs...) -&gt; D, V
eig_trunc_no_error(A, alg::AbstractAlgorithm) -&gt; D, V
eig_trunc_no_error!(A, [DV]; [trunc], kwargs...) -&gt; D, V
eig_trunc_no_error!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy. The truncation error is <em>not</em> returned.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword Arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-203ded4cf50b6985"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-203ded4cf50b6985" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a>, <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L89-L137">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.eig_trunc_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eig_trunc_pullback!(
    ΔA::AbstractMatrix, ΔDV, A, DV;
    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])
)</code></pre><p>Adds the pullback from the truncated eigenvalue decomposition of <code>A</code> to <code>ΔA</code>, given the output <code>DV</code> and the cotangent <code>ΔDV</code> of <code>eig_trunc</code>.</p><p>In particular, it is assumed that <code>A * V ≈ V * D</code> with <code>V</code> a rectangular matrix of eigenvectors and <code>D</code> diagonal. For the cotangents, it is assumed that if <code>ΔV</code> is not zero, then it has the same number of columns as <code>V</code>, and if <code>ΔD</code> is not zero, then it is a diagonal matrix of the same size as <code>D</code>.</p><p>For this method to work correctly, it is also assumed that the remaining eigenvalues (not included in <code>D</code>) are (sufficiently) separated from those in <code>D</code>.</p><p>A warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of <code>V&#39; * ΔV</code> to rows <code>i</code> and columns <code>j</code> for which <code>abs(D[i] - D[j]) &lt; degeneracy_atol</code>, is not small compared to <code>gauge_atol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/eig.jl#L82-L103">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_vals"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_vals"><code>MatrixAlgebraKit.eig_vals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_vals(A; kwargs...) -&gt; D
eig_vals(A, alg::AbstractAlgorithm) -&gt; D
eig_vals!(A, [D]; kwargs...) -&gt; D
eig_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of eigenvalues of <code>A</code>.</p><div class="admonition is-info" id="Note-bc7b22d7797faa2e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bc7b22d7797faa2e" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>D</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L140-L157">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_vals!"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_vals!"><code>MatrixAlgebraKit.eig_vals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_vals(A; kwargs...) -&gt; D
eig_vals(A, alg::AbstractAlgorithm) -&gt; D
eig_vals!(A, [D]; kwargs...) -&gt; D
eig_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of eigenvalues of <code>A</code>.</p><div class="admonition is-info" id="Note-bc7b22d7797faa2e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bc7b22d7797faa2e" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>D</code> as output.</p></div></div><div class="admonition is-info" id="Note-b384f28d5a25d648"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b384f28d5a25d648" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eig.jl#L140-L157">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eig_vals_pullback!"><a class="docstring-binding" href="#MatrixAlgebraKit.eig_vals_pullback!"><code>MatrixAlgebraKit.eig_vals_pullback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eig_vals_pullback!(
    ΔA, A, DV, ΔD, [ind];
    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),
)</code></pre><p>Adds the pullback from the eigenvalues of <code>A</code> to <code>ΔA</code>, given the output <code>DV</code> of <code>eig_full</code> and the cotangent <code>ΔD</code> of <code>eig_vals</code>.</p><p>In particular, it is assumed that <code>A ≈ V * D * inv(V)</code> with thus <code>size(A) == size(V) == size(D)</code> and <code>D</code> diagonal. For the cotangents, an arbitrary number of eigenvalues can be missing, i.e. for a matrix <code>A</code> of size <code>(n, n)</code>, <code>diagview(ΔD)</code> can have length <code>pD</code>. In those cases, additionally <code>ind</code> is required to specify which eigenvalues are present in <code>ΔV</code> or <code>ΔD</code>. By default, it is assumed that all eigenvectors and eigenvalues are present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/eig.jl#L155-L169">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_full"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_full"><code>MatrixAlgebraKit.eigh_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_full(A; kwargs...) -&gt; D, V, ϵ
eigh_full(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eigh_full!(A, [DV]; kwargs...) -&gt; D, V, ϵ
eigh_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute the full eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V = V * D</code>, where the unitary matrix <code>V</code> contains the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded eigenvalues.</p><div class="admonition is-info" id="Note-ee22081f26e42d7d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ee22081f26e42d7d" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L14-L36">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_full!"><code>MatrixAlgebraKit.eigh_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_full(A; kwargs...) -&gt; D, V, ϵ
eigh_full(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eigh_full!(A, [DV]; kwargs...) -&gt; D, V, ϵ
eigh_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute the full eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V = V * D</code>, where the unitary matrix <code>V</code> contains the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded eigenvalues.</p><div class="admonition is-info" id="Note-ee22081f26e42d7d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ee22081f26e42d7d" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L14-L36">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_pullback!"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_pullback!"><code>MatrixAlgebraKit.eigh_pullback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_pullback!(
    ΔA::AbstractMatrix, A, DV, ΔDV, [ind];
    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])
)</code></pre><p>Adds the pullback from the Hermitian eigenvalue decomposition of <code>A</code> to <code>ΔA</code>, given the output <code>DV</code> of <code>eigh_full</code> and the cotangent <code>ΔDV</code> of <code>eigh_full</code> or <code>eigh_trunc</code>.</p><p>In particular, it is assumed that <code>A ≈ V * D * V&#39;</code> with thus <code>size(A) == size(V) == size(D)</code> and <code>D</code> diagonal. For the cotangents, an arbitrary number of eigenvectors or eigenvalues can be missing, i.e. for a matrix <code>A</code> of size <code>(n, n)</code>, <code>ΔV</code> can have size <code>(n, pV)</code> and <code>diagview(ΔD)</code> can have length <code>pD</code>. In those cases, additionally <code>ind</code> is required to specify which eigenvectors or eigenvalues are present in <code>ΔV</code> or <code>ΔD</code>. By default, it is assumed that all eigenvectors and eigenvalues are present.</p><p>A warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of <code>V&#39; * ΔV</code>, restricted to rows <code>i</code> and columns <code>j</code> for which `abs(D[i]</p><ul><li>D[j]) &lt; degeneracy<em>atol<code>, is not small compared to</code>gauge</em>atol`.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/eigh.jl#L1-L21">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_trunc"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_trunc"><code>MatrixAlgebraKit.eigh_trunc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_trunc(A; [trunc], kwargs...) -&gt; D, V, ϵ
eigh_trunc(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eigh_trunc!(A, [DV]; [trunc], kwargs...) -&gt; D, V, ϵ
eigh_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the discarded eigenvalues.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-b1b47de4791a2adb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b1b47de4791a2adb" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a>, <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eigh_trunc_no_error"><code>eigh_trunc_no_error(!)</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L39-L90">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_trunc!"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_trunc!"><code>MatrixAlgebraKit.eigh_trunc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_trunc(A; [trunc], kwargs...) -&gt; D, V, ϵ
eigh_trunc(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eigh_trunc!(A, [DV]; [trunc], kwargs...) -&gt; D, V, ϵ
eigh_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the discarded eigenvalues.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-b1b47de4791a2adb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b1b47de4791a2adb" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a>, <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eigh_trunc_no_error"><code>eigh_trunc_no_error(!)</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L39-L90">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_trunc_no_error"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_trunc_no_error"><code>MatrixAlgebraKit.eigh_trunc_no_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_trunc_no_error(A; [trunc], kwargs...) -&gt; D, V
eigh_trunc_no_error(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_trunc_no_error!(A, [DV]; [trunc], kwargs...) -&gt; D, V
eigh_trunc_no_error!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.  The function does <em>not</em> returns the truncation error. </p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-b1b47de4791a2adb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b1b47de4791a2adb" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a>, <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc"><code>eigh_trunc(!)</code></a>, and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L93-L141">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_trunc_no_error!"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_trunc_no_error!"><code>MatrixAlgebraKit.eigh_trunc_no_error!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_trunc_no_error(A; [trunc], kwargs...) -&gt; D, V
eigh_trunc_no_error(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_trunc_no_error!(A, [DV]; [trunc], kwargs...) -&gt; D, V
eigh_trunc_no_error!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.  The function does <em>not</em> returns the truncation error. </p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-b1b47de4791a2adb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b1b47de4791a2adb" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a>, <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>, <a href="#MatrixAlgebraKit.eig_trunc"><code>eigh_trunc(!)</code></a>, and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L93-L141">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.eigh_trunc_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eigh_trunc_pullback!(
    ΔA::AbstractMatrix, A, DV, ΔDV;
    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])
)</code></pre><p>Adds the pullback from the truncated Hermitian eigenvalue decomposition of <code>A</code> to <code>ΔA</code>, given the output <code>DV</code> and the cotangent <code>ΔDV</code> of <code>eig_trunc</code>.</p><p>In particular, it is assumed that <code>A * V ≈ V * D</code> with <code>V</code> a rectangular matrix of eigenvectors and <code>D</code> diagonal. For the cotangents, it is assumed that if <code>ΔV</code> is not zero, then it has the same number of columns as <code>V</code>, and if <code>ΔD</code> is not zero, then it is a diagonal matrix of the same size as <code>D</code>.</p><p>For this method to work correctly, it is also assumed that the remaining eigenvalues (not included in <code>D</code>) are (sufficiently) separated from those in <code>D</code>.</p><p>A warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of <code>V&#39; * ΔV</code> to rows <code>i</code> and columns <code>j</code> for which <code>abs(D[i] - D[j]) &lt; degeneracy_atol</code>, is not small compared to <code>gauge_atol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/eigh.jl#L72-L93">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_vals"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_vals"><code>MatrixAlgebraKit.eigh_vals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_vals(A; kwargs...) -&gt; D
eigh_vals(A, alg::AbstractAlgorithm) -&gt; D
eigh_vals!(A, [D]; kwargs...) -&gt; D
eigh_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of (real) eigenvalues of the symmetric or hermitian matrix <code>A</code>.</p><div class="admonition is-info" id="Note-b0854da06d1beb78"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b0854da06d1beb78" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L144-L161">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_vals!"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_vals!"><code>MatrixAlgebraKit.eigh_vals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_vals(A; kwargs...) -&gt; D
eigh_vals(A, alg::AbstractAlgorithm) -&gt; D
eigh_vals!(A, [D]; kwargs...) -&gt; D
eigh_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of (real) eigenvalues of the symmetric or hermitian matrix <code>A</code>.</p><div class="admonition is-info" id="Note-b0854da06d1beb78"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b0854da06d1beb78" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-a0d232fe7fd1a011"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a0d232fe7fd1a011" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/eigh.jl#L144-L161">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.eigh_vals_pullback!"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_vals_pullback!"><code>MatrixAlgebraKit.eigh_vals_pullback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eigh_vals_pullback!(
    ΔA, A, DV, ΔD, [ind];
    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),
)</code></pre><p>Adds the pullback from the eigenvalues of <code>A</code> to <code>ΔA</code>, given the output <code>DV</code> of <code>eigh_full</code> and the cotangent <code>ΔD</code> of <code>eig_vals</code>.</p><p>In particular, it is assumed that <code>A ≈ V * D * inv(V)</code> with thus <code>size(A) == size(V) == size(D)</code> and <code>D</code> diagonal. For the cotangents, an arbitrary number of eigenvalues can be missing, i.e. for a matrix <code>A</code> of size <code>(n, n)</code>, <code>diagview(ΔD)</code> can have length <code>pD</code>. In those cases, additionally <code>ind</code> is required to specify which eigenvalues are present in <code>ΔV</code> or <code>ΔD</code>. By default, it is assumed that all eigenvectors and eigenvalues are present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/eigh.jl#L145-L159">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.findtruncated"><a class="docstring-binding" href="#MatrixAlgebraKit.findtruncated"><code>MatrixAlgebraKit.findtruncated</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MatrixAlgebraKit.findtruncated(values::AbstractVector, strategy::TruncationStrategy)</code></pre><p>Generic interface for finding truncated values of the spectrum of a decomposition based on the <code>strategy</code>. The output should be a collection of indices specifying which values to keep. <code>MatrixAlgebraKit.findtruncated</code> is used inside of the default implementation of <a href="#MatrixAlgebraKit.truncate"><code>truncate</code></a> to perform the truncation. It does not assume that the values are sorted. For a version that assumes the values are reverse sorted (which is the standard case for SVD) see <a href="#MatrixAlgebraKit.findtruncated_svd"><code>MatrixAlgebraKit.findtruncated_svd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L193-L202">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.findtruncated_svd"><a class="docstring-binding" href="#MatrixAlgebraKit.findtruncated_svd"><code>MatrixAlgebraKit.findtruncated_svd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MatrixAlgebraKit.findtruncated_svd(values::AbstractVector, strategy::TruncationStrategy)</code></pre><p>Like <a href="#MatrixAlgebraKit.findtruncated"><code>MatrixAlgebraKit.findtruncated</code></a> but assumes that the values are real and sorted in descending order, as typically obtained by the SVD. This assumption is not checked, and this is used in the default implementation of <a href="#MatrixAlgebraKit.svd_trunc!"><code>svd_trunc!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L204-L210">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.gaugefix!"><a class="docstring-binding" href="#MatrixAlgebraKit.gaugefix!"><code>MatrixAlgebraKit.gaugefix!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gaugefix!(f_eig, V)
gaugefix!(f_svd, U, Vᴴ)</code></pre><p>Fix the residual gauge degrees of freedom in the eigen or singular vectors, that are obtained from the decomposition performed by <code>f_eig</code> or <code>f_svd</code>. This is achieved by ensuring that the entry with the largest magnitude in <code>V</code> or <code>U</code> is real and positive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/gauge.jl#L1-L9">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.gen_eig_full"><a class="docstring-binding" href="#MatrixAlgebraKit.gen_eig_full"><code>MatrixAlgebraKit.gen_eig_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gen_eig_full(A, B; kwargs...) -&gt; W, V
gen_eig_full(A, B, alg::AbstractAlgorithm) -&gt; W, V
gen_eig_full!(A, B, [WV]; kwargs...) -&gt; W, V
gen_eig_full!(A, B, [WV], alg::AbstractAlgorithm) -&gt; W, V</code></pre><p>Compute the full generalized eigenvalue decomposition of the square matrices <code>A</code> and <code>B</code>, such that <code>A * V = B * V * W</code>, where the invertible matrix <code>V</code> contains the generalized eigenvectors and the diagonal matrix <code>W</code> contains the associated generalized eigenvalues.</p><div class="admonition is-info" id="Note-d04955524291fa3d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d04955524291fa3d" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>gen_eig_full!</code> optionally accepts the output structure and possibly destroys the input matrices <code>A</code> and <code>B</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WV</code> as output.</p></div></div><div class="admonition is-info" id="Note-653d3638bf181272"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-653d3638bf181272" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.gen_eig_full"><code>gen_eig_full</code></a> and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_vals"><code>gen_eig_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/gen_eig.jl#L14-L34">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.gen_eig_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.gen_eig_full!"><code>MatrixAlgebraKit.gen_eig_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gen_eig_full(A, B; kwargs...) -&gt; W, V
gen_eig_full(A, B, alg::AbstractAlgorithm) -&gt; W, V
gen_eig_full!(A, B, [WV]; kwargs...) -&gt; W, V
gen_eig_full!(A, B, [WV], alg::AbstractAlgorithm) -&gt; W, V</code></pre><p>Compute the full generalized eigenvalue decomposition of the square matrices <code>A</code> and <code>B</code>, such that <code>A * V = B * V * W</code>, where the invertible matrix <code>V</code> contains the generalized eigenvectors and the diagonal matrix <code>W</code> contains the associated generalized eigenvalues.</p><div class="admonition is-info" id="Note-d04955524291fa3d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d04955524291fa3d" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>gen_eig_full!</code> optionally accepts the output structure and possibly destroys the input matrices <code>A</code> and <code>B</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WV</code> as output.</p></div></div><div class="admonition is-info" id="Note-653d3638bf181272"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-653d3638bf181272" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.gen_eig_full"><code>gen_eig_full</code></a> and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_vals"><code>gen_eig_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/gen_eig.jl#L14-L34">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.gen_eig_vals"><a class="docstring-binding" href="#MatrixAlgebraKit.gen_eig_vals"><code>MatrixAlgebraKit.gen_eig_vals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gen_eig_vals(A, B; kwargs...) -&gt; W
gen_eig_vals(A, B, alg::AbstractAlgorithm) -&gt; W
gen_eig_vals!(A, B, [W]; kwargs...) -&gt; W 
gen_eig_vals!(A, B, [W], alg::AbstractAlgorithm) -&gt; W</code></pre><p>Compute the list of generalized eigenvalues of <code>A</code> and <code>B</code>.</p><div class="admonition is-info" id="Note-71666262c3c5a374"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-71666262c3c5a374" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>gen_eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrices <code>A</code> and <code>B</code>. Always use the return value of the function as it may not always be possible to use the provided <code>W</code> as output.</p></div></div><div class="admonition is-info" id="Note-653d3638bf181272"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-653d3638bf181272" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.gen_eig_full"><code>gen_eig_full</code></a> and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.</p></div></div><p>See also <a href="#MatrixAlgebraKit.gen_eig_full"><code>gen_eig_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/gen_eig.jl#L37-L55">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.gen_eig_vals!"><a class="docstring-binding" href="#MatrixAlgebraKit.gen_eig_vals!"><code>MatrixAlgebraKit.gen_eig_vals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gen_eig_vals(A, B; kwargs...) -&gt; W
gen_eig_vals(A, B, alg::AbstractAlgorithm) -&gt; W
gen_eig_vals!(A, B, [W]; kwargs...) -&gt; W 
gen_eig_vals!(A, B, [W], alg::AbstractAlgorithm) -&gt; W</code></pre><p>Compute the list of generalized eigenvalues of <code>A</code> and <code>B</code>.</p><div class="admonition is-info" id="Note-71666262c3c5a374"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-71666262c3c5a374" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>gen_eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrices <code>A</code> and <code>B</code>. Always use the return value of the function as it may not always be possible to use the provided <code>W</code> as output.</p></div></div><div class="admonition is-info" id="Note-653d3638bf181272"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-653d3638bf181272" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.gen_eig_full"><code>gen_eig_full</code></a> and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.</p></div></div><p>See also <a href="#MatrixAlgebraKit.gen_eig_full"><code>gen_eig_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/gen_eig.jl#L37-L55">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.initialize_output"><a class="docstring-binding" href="#MatrixAlgebraKit.initialize_output"><code>MatrixAlgebraKit.initialize_output</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_output(f, A, alg)</code></pre><p>Whenever possible, allocate the destination for applying a given algorithm in-place. If this is not possible, for example when the output size is not known a priori or immutable, this function may return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L138-L144">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.inv_regularized"><a class="docstring-binding" href="#MatrixAlgebraKit.inv_regularized"><code>MatrixAlgebraKit.inv_regularized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inv_regularized(a::Number, tol = defaulttol(a))
inv_regularized(A::Matrix, tol = defaulttol(A); isposdef = false, kwargs...)</code></pre><p>Compute a smooth regularised inverse (L2 Tikhonov regularisation) of a number or square  matrix a.</p><ul><li><p>For numbers, this is given by <code>inv(hypot(a, tol))</code>.</p></li><li><p>For matrices, this is computed using the singular value decomposition and aplying   <code>inv_regularized</code> to the singular values. If <code>isposdef = true</code>, the singular value   decomposition is equivalent to the (Hermitian) eigenvalue decomposition of <code>A</code> and   the latter is used instead.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/regularinv.jl#L5-L18">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.inv_safe"><a class="docstring-binding" href="#MatrixAlgebraKit.inv_safe"><code>MatrixAlgebraKit.inv_safe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function inv_safe(a::Number, tol = defaulttol(a))</code></pre><p>Compute the inverse of a number <code>a</code>, but return zero if <code>a</code> is smaller than <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/safemethods.jl#L15-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.is_left_isometric"><a class="docstring-binding" href="#MatrixAlgebraKit.is_left_isometric"><code>MatrixAlgebraKit.is_left_isometric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_left_isometric(A; isapprox_kwargs...) -&gt; Bool</code></pre><p>Test whether a linear map is a (left) isometry, i.e. <code>A&#39; * A ≈ I</code>. The <code>isapprox_kwargs</code> can be used to control the tolerances of the equality.</p><p>See also <a href="#MatrixAlgebraKit.isisometric-Tuple{Any}"><code>isisometric</code></a> and <a href="#MatrixAlgebraKit.is_right_isometric"><code>MatrixAlgebraKit.is_right_isometric</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/matrixproperties.jl#L40-L47">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.is_right_isometric"><a class="docstring-binding" href="#MatrixAlgebraKit.is_right_isometric"><code>MatrixAlgebraKit.is_right_isometric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_right_isometric(A; isapprox_kwargs...) -&gt; Bool</code></pre><p>Test whether a linear map is a (right) isometry, i.e. <code>A * A&#39; ≈ I</code>. The <code>isapprox_kwargs</code> can be used to control the tolerances of the equality.</p><p>See also <a href="#MatrixAlgebraKit.isisometric-Tuple{Any}"><code>isisometric</code></a> and <a href="#MatrixAlgebraKit.is_left_isometric"><code>MatrixAlgebraKit.is_left_isometric</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/matrixproperties.jl#L56-L63">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.isantihermitian-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.isantihermitian-Tuple{Any}"><code>MatrixAlgebraKit.isantihermitian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isantihermitian(A; isapprox_kwargs...)</code></pre><p>Test whether a linear map is anti-Hermitian, i.e. <code>A = -A&#39;</code>. The <code>isapprox_kwargs</code> can be used to control the tolerances of the equality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/matrixproperties.jl#L90-L95">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.ishermitian-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.ishermitian-Tuple{Any}"><code>MatrixAlgebraKit.ishermitian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ishermitian(A; isapprox_kwargs...)</code></pre><p>Test whether a linear map is Hermitian, i.e. <code>A = A&#39;</code>. The <code>isapprox_kwargs</code> can be used to control the tolerances of the equality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/matrixproperties.jl#L66-L71">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.isisometric-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.isisometric-Tuple{Any}"><code>MatrixAlgebraKit.isisometric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isisometric(A; side=:left, isapprox_kwargs...) -&gt; Bool</code></pre><p>Test whether a linear map is an isometry, where the type of isometry is controlled by <code>kind</code>:</p><ul><li><code>side = :left</code> : <code>A&#39; * A ≈ I</code>. </li><li><code>side = :right</code> : <code>A * A&#39; ≈ I</code>.</li></ul><p>The <code>isapprox_kwargs</code> are passed on to <code>isapprox</code> to control the tolerances.</p><p>New specializations should overload <a href="#MatrixAlgebraKit.is_left_isometric"><code>MatrixAlgebraKit.is_left_isometric</code></a> and <a href="#MatrixAlgebraKit.is_right_isometric"><code>MatrixAlgebraKit.is_right_isometric</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.isunitary-Tuple{Any}"><code>isunitary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/matrixproperties.jl#L1-L15">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.isunitary-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.isunitary-Tuple{Any}"><code>MatrixAlgebraKit.isunitary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isunitary(A; isapprox_kwargs...)</code></pre><p>Test whether a linear map is unitary, i.e. <code>A * A&#39; ≈ I ≈ A&#39; * A</code>. The <code>isapprox_kwargs</code> are passed on to <code>isapprox</code> to control the tolerances.</p><p>See also <a href="#MatrixAlgebraKit.isisometric-Tuple{Any}"><code>isisometric</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/matrixproperties.jl#L23-L30">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.iszerotangent"><a class="docstring-binding" href="#MatrixAlgebraKit.iszerotangent"><code>MatrixAlgebraKit.iszerotangent</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">iszerotangent(x)</code></pre><p>Return true if <code>x</code> is of a type that the different AD engines use to communicate a (co)tangent that is identically zero. By overloading this method, and writing pullback definitions in term of it, we will be able to hook into different AD ecosystems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/pullbacks.jl#L1-L8">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_null"><a class="docstring-binding" href="#MatrixAlgebraKit.left_null"><code>MatrixAlgebraKit.left_null</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_null(A; [alg], [trunc], kwargs...) -&gt; N
left_null!(A, [N], [alg]; [trunc], kwargs...) -&gt; N</code></pre><p>Compute an orthonormal basis <code>N</code> for the cokernel of the matrix <code>A</code>, i.e. the nullspace of <code>adjoint(A)</code>, such that <code>adjoint(A) * N ≈ 0</code> and <code>N&#39; * N ≈ I</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of <code>A&#39;</code>, whereas <code>trunc</code> can optionally  be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><div class="admonition is-info" id="Note-e54f897e5faa8d5f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e54f897e5faa8d5f" title="Permalink"></a></header><div class="admonition-body"><p>Here <a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional columns of <code>A</code>.</p></div></div><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:qr</code> : Factorize via QR nullspace, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        N = qr_null(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument. It is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        U, S, _ = svd_full(A; kwargs...)
        N = truncate(left_null, (U, S), trunc)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.left_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>left_null_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-f26718d819157ca2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f26718d819157ca2" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a> and <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L167-L243">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_null!"><a class="docstring-binding" href="#MatrixAlgebraKit.left_null!"><code>MatrixAlgebraKit.left_null!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_null(A; [alg], [trunc], kwargs...) -&gt; N
left_null!(A, [N], [alg]; [trunc], kwargs...) -&gt; N</code></pre><p>Compute an orthonormal basis <code>N</code> for the cokernel of the matrix <code>A</code>, i.e. the nullspace of <code>adjoint(A)</code>, such that <code>adjoint(A) * N ≈ 0</code> and <code>N&#39; * N ≈ I</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of <code>A&#39;</code>, whereas <code>trunc</code> can optionally  be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><div class="admonition is-info" id="Note-e54f897e5faa8d5f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e54f897e5faa8d5f" title="Permalink"></a></header><div class="admonition-body"><p>Here <a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional columns of <code>A</code>.</p></div></div><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:qr</code> : Factorize via QR nullspace, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        N = qr_null(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument. It is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        U, S, _ = svd_full(A; kwargs...)
        N = truncate(left_null, (U, S), trunc)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.left_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>left_null_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-f26718d819157ca2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f26718d819157ca2" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a> and <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L167-L243">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><a class="docstring-binding" href="#MatrixAlgebraKit.left_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>MatrixAlgebraKit.left_null_alg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_null_alg(alg::AbstractAlgorithm) -&gt; LeftNullAlgorithm</code></pre><p>Convert an algorithm to a <a href="#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm</code></a> wrapper for use with <a href="#MatrixAlgebraKit.left_null"><code>left_null</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:qr</code> or <code>:svd</code>) from the algorithm type and wraps it in a <code>LeftNullAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.left_null_alg(alg::CustomAlgorithm) = LeftNullAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm</code></a>, <a href="#MatrixAlgebraKit.left_null"><code>left_null</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L483-L499">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_orth"><a class="docstring-binding" href="#MatrixAlgebraKit.left_orth"><code>MatrixAlgebraKit.left_orth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_orth(A; [alg], [trunc], kwargs...) -&gt; V, C
left_orth!(A, [VC], [alg]; [trunc], kwargs...) -&gt; V, C</code></pre><p>Compute an orthonormal basis <code>V</code> for the image of the matrix <code>A</code>, as well as a  matrix <code>C</code> (the corestriction) such that <code>A</code> factors as <code>A = V * C</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>trunc</code> can optionally be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will typically be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:qr</code> : Factorize via QR decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        V, C = qr_compact(A; kwargs...)</code></pre><ul><li><code>:polar</code> : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        V, C = left_polar(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument, and is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        V, S, C = svd_trunc(A; trunc, kwargs...)
        C = lmul!(S, C)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.left_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>left_orth_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-ebb61218dcab1bf9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ebb61218dcab1bf9" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CV</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>, <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a> and <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L3-L81">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_orth!"><a class="docstring-binding" href="#MatrixAlgebraKit.left_orth!"><code>MatrixAlgebraKit.left_orth!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_orth(A; [alg], [trunc], kwargs...) -&gt; V, C
left_orth!(A, [VC], [alg]; [trunc], kwargs...) -&gt; V, C</code></pre><p>Compute an orthonormal basis <code>V</code> for the image of the matrix <code>A</code>, as well as a  matrix <code>C</code> (the corestriction) such that <code>A</code> factors as <code>A = V * C</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>trunc</code> can optionally be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will typically be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:qr</code> : Factorize via QR decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        V, C = qr_compact(A; kwargs...)</code></pre><ul><li><code>:polar</code> : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        V, C = left_polar(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument, and is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        V, S, C = svd_trunc(A; trunc, kwargs...)
        C = lmul!(S, C)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.left_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>left_orth_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-ebb61218dcab1bf9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ebb61218dcab1bf9" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CV</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>, <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a> and <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L3-L81">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><a class="docstring-binding" href="#MatrixAlgebraKit.left_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>MatrixAlgebraKit.left_orth_alg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_orth_alg(alg::AbstractAlgorithm) -&gt; LeftOrthAlgorithm</code></pre><p>Convert an algorithm to a <a href="#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm</code></a> wrapper for use with <a href="#MatrixAlgebraKit.left_orth"><code>left_orth</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:qr</code>, <code>:polar</code>, or <code>:svd</code>) from the algorithm type and wraps it in a <code>LeftOrthAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.left_orth_alg(alg::CustomAlgorithm) = LeftOrthAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L413-L429">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_polar"><a class="docstring-binding" href="#MatrixAlgebraKit.left_polar"><code>MatrixAlgebraKit.left_polar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_polar(A; kwargs...) -&gt; W, P
left_polar(A, alg::AbstractAlgorithm) -&gt; W, P
left_polar!(A, [WP]; kwargs...) -&gt; W, P
left_polar!(A, [WP], alg::AbstractAlgorithm) -&gt; W, P</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>m &gt;= n</code>, such that <code>A = W * P</code>. Here, <code>W</code> is an isometric matrix (orthonormal columns) of size <code>(m, n)</code>, whereas <code>P</code> is a positive (semi)definite matrix of size <code>(n, n)</code>.</p><div class="admonition is-info" id="Note-e83c365b675f681"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e83c365b675f681" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_polar"><code>right_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/polar.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_polar!"><a class="docstring-binding" href="#MatrixAlgebraKit.left_polar!"><code>MatrixAlgebraKit.left_polar!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_polar(A; kwargs...) -&gt; W, P
left_polar(A, alg::AbstractAlgorithm) -&gt; W, P
left_polar!(A, [WP]; kwargs...) -&gt; W, P
left_polar!(A, [WP], alg::AbstractAlgorithm) -&gt; W, P</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>m &gt;= n</code>, such that <code>A = W * P</code>. Here, <code>W</code> is an isometric matrix (orthonormal columns) of size <code>(m, n)</code>, whereas <code>P</code> is a positive (semi)definite matrix of size <code>(n, n)</code>.</p><div class="admonition is-info" id="Note-e83c365b675f681"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e83c365b675f681" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_polar"><code>right_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/polar.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.left_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.left_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.left_polar_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_polar_pullback!(ΔA, A, WP, ΔWP)</code></pre><p>Adds the pullback from the left polar decomposition of <code>A</code> to <code>ΔA</code> given the output <code>WP</code> and cotangent <code>ΔWP</code> of <code>left_polar(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/polar.jl#L1-L6">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_compact"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_compact"><code>MatrixAlgebraKit.lq_compact</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lq_compact(A; kwargs...) -&gt; L, Q
lq_compact(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_compact!(A, [LQ]; kwargs...) -&gt; L, Q
lq_compact!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the compact LQ decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = L * Q</code> where the matrix <code>Q</code> of size <code>(min(m,n), n)</code> has orthogonal rows spanning the image of <code>A&#39;</code>, and the matrix <code>L</code> of size <code>(m, min(m,n))</code> is lower triangular.</p><div class="admonition is-info" id="Note-5aab9aded7713539"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5aab9aded7713539" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><div class="admonition is-info" id="Note-70c8e4e1d274fcf8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-70c8e4e1d274fcf8" title="Permalink"></a></header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full LQ decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/lq.jl#L22-L42">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_compact!"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_compact!"><code>MatrixAlgebraKit.lq_compact!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lq_compact(A; kwargs...) -&gt; L, Q
lq_compact(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_compact!(A, [LQ]; kwargs...) -&gt; L, Q
lq_compact!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the compact LQ decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = L * Q</code> where the matrix <code>Q</code> of size <code>(min(m,n), n)</code> has orthogonal rows spanning the image of <code>A&#39;</code>, and the matrix <code>L</code> of size <code>(m, min(m,n))</code> is lower triangular.</p><div class="admonition is-info" id="Note-5aab9aded7713539"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5aab9aded7713539" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><div class="admonition is-info" id="Note-70c8e4e1d274fcf8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-70c8e4e1d274fcf8" title="Permalink"></a></header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full LQ decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/lq.jl#L22-L42">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_full"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_full"><code>MatrixAlgebraKit.lq_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lq_full(A; kwargs...) -&gt; L, Q
lq_full(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_full!(A, [LQ]; kwargs...) -&gt; L, Q
lq_full!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the full LQ decomposition of the rectangular matrix <code>A</code>, such that <code>A = L * Q</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>L</code> is a lower triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info" id="Note-ac2c6b0bacc155a9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ac2c6b0bacc155a9" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/lq.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_full!"><code>MatrixAlgebraKit.lq_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lq_full(A; kwargs...) -&gt; L, Q
lq_full(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_full!(A, [LQ]; kwargs...) -&gt; L, Q
lq_full!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the full LQ decomposition of the rectangular matrix <code>A</code>, such that <code>A = L * Q</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>L</code> is a lower triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info" id="Note-ac2c6b0bacc155a9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ac2c6b0bacc155a9" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/lq.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_null"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_null"><code>MatrixAlgebraKit.lq_null</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lq_null(A; kwargs...) -&gt; Nᴴ
lq_null(A, alg::AbstractAlgorithm) -&gt; Nᴴ
lq_null!(A, [Nᴴ]; kwargs...) -&gt; Nᴴ
lq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -&gt; Nᴴ</code></pre><p>For a (m, n) matrix A, compute the matrix <code>Nᴴ</code> corresponding the final <code>n - min(m, n)</code> rows  oft the unitary <code>Q</code> factor in the full LQ decomposition of <code>A</code>, i.e. the rows that are not present in the <code>Q</code> factor of the compact LQ decomposition. The matrix <code>Nᴴ</code> is such that the isometric matrix <code>N = adjoint(Nᴴ)</code> contains an orthonormal basis for the kernel (null space) of <code>A</code> as its columns, i.e. <code>A * N = 0</code> or thus <code>A * adjoint(Nᴴ) = 0</code>.</p><div class="admonition is-info" id="Note-9c95f039b89ff317"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9c95f039b89ff317" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> argument as output.</p></div></div><div class="admonition is-info" id="Note-d4cb3129134a0522"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d4cb3129134a0522" title="Permalink"></a></header><div class="admonition-body"><p>The matrix <code>Nᴴ</code> is empty when <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>qr_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/lq.jl#L45-L66">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_null!"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_null!"><code>MatrixAlgebraKit.lq_null!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lq_null(A; kwargs...) -&gt; Nᴴ
lq_null(A, alg::AbstractAlgorithm) -&gt; Nᴴ
lq_null!(A, [Nᴴ]; kwargs...) -&gt; Nᴴ
lq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -&gt; Nᴴ</code></pre><p>For a (m, n) matrix A, compute the matrix <code>Nᴴ</code> corresponding the final <code>n - min(m, n)</code> rows  oft the unitary <code>Q</code> factor in the full LQ decomposition of <code>A</code>, i.e. the rows that are not present in the <code>Q</code> factor of the compact LQ decomposition. The matrix <code>Nᴴ</code> is such that the isometric matrix <code>N = adjoint(Nᴴ)</code> contains an orthonormal basis for the kernel (null space) of <code>A</code> as its columns, i.e. <code>A * N = 0</code> or thus <code>A * adjoint(Nᴴ) = 0</code>.</p><div class="admonition is-info" id="Note-9c95f039b89ff317"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9c95f039b89ff317" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> argument as output.</p></div></div><div class="admonition is-info" id="Note-d4cb3129134a0522"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d4cb3129134a0522" title="Permalink"></a></header><div class="admonition-body"><p>The matrix <code>Nᴴ</code> is empty when <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>qr_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/lq.jl#L45-L66">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.lq_null_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lq_null_pullback!(
    ΔA::AbstractMatrix, A, Nᴴ, ΔNᴴ;
    gauge_atol::Real = default_pullback_gauge_atol(ΔNᴴ)
)</code></pre><p>Adds the pullback from the left nullspace of <code>A</code> to <code>ΔA</code>, given the nullspace basis  <code>Nᴴ</code> and its cotangent <code>ΔNᴴ</code> of <code>lq_null(A)</code>.</p><p>See also <a href="#MatrixAlgebraKit.lq_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>lq_pullback!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/lq.jl#L105-L115">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.lq_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.lq_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.lq_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lq_pullback!(
    ΔA, A, LQ, ΔLQ;
    rank_atol::Real = default_pullback_rank_atol(LQ[1]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔLQ[2])
)</code></pre><p>Adds the pullback from the LQ decomposition of <code>A</code> to <code>ΔA</code> given the output <code>LQ</code> and cotangent <code>ΔLQ</code> of <code>lq_compact(A; positive = true)</code> or <code>lq_full(A; positive = true)</code>.</p><p>In the case where the rank <code>r</code> of the original matrix <code>A ≈ L * Q</code> (as determined by <code>rank_atol</code>) is less then the minimum of the number of rows and columns of the cotangents <code>ΔL</code> and <code>ΔQ</code>, only the first <code>r</code> columns of <code>L</code> and the first <code>r</code> rows of <code>Q</code> are well-defined, and also the adjoint variables <code>ΔL</code> and <code>ΔQ</code> should have nonzero values only in the first <code>r</code> columns and rows respectively. If nonzero values in the remaining columns or rows exceed <code>gauge_atol</code>, a warning will be printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/lq.jl#L1-L17">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.notrunc-Tuple{}"><a class="docstring-binding" href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>MatrixAlgebraKit.notrunc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">notrunc()</code></pre><p>Truncation strategy that does nothing, and keeps all the values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L87-L91">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.null_truncation_strategy-Tuple{}"><a class="docstring-binding" href="#MatrixAlgebraKit.null_truncation_strategy-Tuple{}"><code>MatrixAlgebraKit.null_truncation_strategy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">null_truncation_strategy(; kwargs...)</code></pre><p>Select a nullspace truncation strategy based on the provided keyword arguments.</p><p><strong>Keyword arguments</strong></p><p>The following keyword arguments are all optional, and their default value (<code>nothing</code>) will be ignored. It is also allowed to combine multiple of these, in which case the discarded values will consist of the intersection of the different truncated strategies.</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L57-L68">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.project_antihermitian"><a class="docstring-binding" href="#MatrixAlgebraKit.project_antihermitian"><code>MatrixAlgebraKit.project_antihermitian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_antihermitian(A; kwargs...)
project_antihermitian(A, alg)
project_antihermitian!(A, [Aₐ]; kwargs...)
project_antihermitian!(A, [Aₐ], alg)</code></pre><p>Compute the anti-hermitian part of a (square) matrix <code>A</code>, defined as <code>(A - A&#39;) / 2</code>. For real matrices this corresponds to the antisymmetric part of <code>A</code>. In the bang method, the output storage can be provided via the optional argument <code>Aₐ</code><code>; by default it is equal to</code>A<code>and so the input matrix</code>A` is replaced by its antihermitian projection.</p><p>See also <a href="#MatrixAlgebraKit.project_hermitian"><code>project_hermitian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L16-L28">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.project_antihermitian!"><a class="docstring-binding" href="#MatrixAlgebraKit.project_antihermitian!"><code>MatrixAlgebraKit.project_antihermitian!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_antihermitian(A; kwargs...)
project_antihermitian(A, alg)
project_antihermitian!(A, [Aₐ]; kwargs...)
project_antihermitian!(A, [Aₐ], alg)</code></pre><p>Compute the anti-hermitian part of a (square) matrix <code>A</code>, defined as <code>(A - A&#39;) / 2</code>. For real matrices this corresponds to the antisymmetric part of <code>A</code>. In the bang method, the output storage can be provided via the optional argument <code>Aₐ</code><code>; by default it is equal to</code>A<code>and so the input matrix</code>A` is replaced by its antihermitian projection.</p><p>See also <a href="#MatrixAlgebraKit.project_hermitian"><code>project_hermitian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L16-L28">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.project_hermitian"><a class="docstring-binding" href="#MatrixAlgebraKit.project_hermitian"><code>MatrixAlgebraKit.project_hermitian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_hermitian(A; kwargs...)
project_hermitian(A, alg)
project_hermitian!(A, [Aₕ]; kwargs...)
project_hermitian!(A, [Aₕ], alg)</code></pre><p>Compute the hermitian part of a (square) matrix <code>A</code>, defined as <code>(A + A&#39;) / 2</code>. For real matrices this corresponds to the symmetric part of <code>A</code>. In the bang method, the output storage can be provided via the optional argument <code>Aₕ</code>; by default it is equal to <code>A</code> and so the input matrix <code>A</code> is replaced by its hermitian projection.</p><p>See also <a href="#MatrixAlgebraKit.project_antihermitian"><code>project_antihermitian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L1-L13">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.project_hermitian!"><a class="docstring-binding" href="#MatrixAlgebraKit.project_hermitian!"><code>MatrixAlgebraKit.project_hermitian!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_hermitian(A; kwargs...)
project_hermitian(A, alg)
project_hermitian!(A, [Aₕ]; kwargs...)
project_hermitian!(A, [Aₕ], alg)</code></pre><p>Compute the hermitian part of a (square) matrix <code>A</code>, defined as <code>(A + A&#39;) / 2</code>. For real matrices this corresponds to the symmetric part of <code>A</code>. In the bang method, the output storage can be provided via the optional argument <code>Aₕ</code>; by default it is equal to <code>A</code> and so the input matrix <code>A</code> is replaced by its hermitian projection.</p><p>See also <a href="#MatrixAlgebraKit.project_antihermitian"><code>project_antihermitian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L1-L13">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.project_isometric"><a class="docstring-binding" href="#MatrixAlgebraKit.project_isometric"><code>MatrixAlgebraKit.project_isometric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_isometric(A; kwargs...)
project_isometric(A, alg)
project_isometric!(A, [W]; kwargs...)
project_isometric!(A, [W], alg)</code></pre><p>Compute the projection of <code>A</code> onto the manifold of isometric matrices, i.e. matrices satisfying <code>A&#39; * A ≈ I</code>. This projection is computed via the polar decomposition, i.e. <code>W</code> corresponds to the first return value of <code>left_polar!</code>, but avoids computing the positive definite factor explicitly.</p><div class="admonition is-info" id="Note-91bc085ed638c279"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-91bc085ed638c279" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>project_isometric!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>W</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L31-L46">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.project_isometric!"><a class="docstring-binding" href="#MatrixAlgebraKit.project_isometric!"><code>MatrixAlgebraKit.project_isometric!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_isometric(A; kwargs...)
project_isometric(A, alg)
project_isometric!(A, [W]; kwargs...)
project_isometric!(A, [W], alg)</code></pre><p>Compute the projection of <code>A</code> onto the manifold of isometric matrices, i.e. matrices satisfying <code>A&#39; * A ≈ I</code>. This projection is computed via the polar decomposition, i.e. <code>W</code> corresponds to the first return value of <code>left_polar!</code>, but avoids computing the positive definite factor explicitly.</p><div class="admonition is-info" id="Note-91bc085ed638c279"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-91bc085ed638c279" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>project_isometric!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>W</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/projections.jl#L31-L46">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_compact"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_compact"><code>MatrixAlgebraKit.qr_compact</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qr_compact(A; kwargs...) -&gt; Q, R
qr_compact(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_compact!(A, [QR]; kwargs...) -&gt; Q, R
qr_compact!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the compact QR decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = Q * R</code> where the isometric matrix <code>Q</code> of size <code>(m, min(m,n))</code> has orthogonal columns spanning the image of <code>A</code>, and the matrix <code>R</code> of size <code>(min(m,n), n)</code> is upper triangular.</p><div class="admonition is-info" id="Note-6edc99dc21d0e270"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6edc99dc21d0e270" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><div class="admonition is-info" id="Note-1c66f683d17c30b5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1c66f683d17c30b5" title="Permalink"></a></header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full QR decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_full"><code>qr_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/qr.jl#L22-L43">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_compact!"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_compact!"><code>MatrixAlgebraKit.qr_compact!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qr_compact(A; kwargs...) -&gt; Q, R
qr_compact(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_compact!(A, [QR]; kwargs...) -&gt; Q, R
qr_compact!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the compact QR decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = Q * R</code> where the isometric matrix <code>Q</code> of size <code>(m, min(m,n))</code> has orthogonal columns spanning the image of <code>A</code>, and the matrix <code>R</code> of size <code>(min(m,n), n)</code> is upper triangular.</p><div class="admonition is-info" id="Note-6edc99dc21d0e270"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6edc99dc21d0e270" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><div class="admonition is-info" id="Note-1c66f683d17c30b5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1c66f683d17c30b5" title="Permalink"></a></header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full QR decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_full"><code>qr_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/qr.jl#L22-L43">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_full"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_full"><code>MatrixAlgebraKit.qr_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qr_full(A; kwargs...) -&gt; Q, R
qr_full(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_full!(A, [QR]; kwargs...) -&gt; Q, R
qr_full!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the full QR decomposition of the rectangular matrix <code>A</code>, such that <code>A = Q * R</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>R</code> is an upper triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info" id="Note-492707f8263aef92"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-492707f8263aef92" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/qr.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_full!"><code>MatrixAlgebraKit.qr_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qr_full(A; kwargs...) -&gt; Q, R
qr_full(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_full!(A, [QR]; kwargs...) -&gt; Q, R
qr_full!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the full QR decomposition of the rectangular matrix <code>A</code>, such that <code>A = Q * R</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>R</code> is an upper triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info" id="Note-492707f8263aef92"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-492707f8263aef92" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/qr.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_null"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_null"><code>MatrixAlgebraKit.qr_null</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qr_null(A; kwargs...) -&gt; N
qr_null(A, alg::AbstractAlgorithm) -&gt; N
qr_null!(A, [N]; kwargs...) -&gt; N
qr_null!(A, [N], alg::AbstractAlgorithm) -&gt; N</code></pre><p>For a (m, n) matrix A, compute the matrix <code>N</code> corresponding the final <code>m - min(m, n)</code> columns  of the unitary <code>Q</code> factor in the full QR decomposition of <code>A</code>, i.e. the columns that are not present in the <code>Q</code> factor of the compact QR decomposition. The isometric matrix <code>N</code> contains an orthonormal basis for the cokernel of <code>A</code> as its columns, i.e. <code>adjoint(A) * N = 0</code>.</p><div class="admonition is-info" id="Note-d2f915688bb99c19"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d2f915688bb99c19" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> argument as output.</p></div></div><div class="admonition is-info" id="Note-fbacf6e42e701cf5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fbacf6e42e701cf5" title="Permalink"></a></header><div class="admonition-body"><p>The matrix <code>N</code> is empty when <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/qr.jl#L46-L66">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_null!"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_null!"><code>MatrixAlgebraKit.qr_null!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qr_null(A; kwargs...) -&gt; N
qr_null(A, alg::AbstractAlgorithm) -&gt; N
qr_null!(A, [N]; kwargs...) -&gt; N
qr_null!(A, [N], alg::AbstractAlgorithm) -&gt; N</code></pre><p>For a (m, n) matrix A, compute the matrix <code>N</code> corresponding the final <code>m - min(m, n)</code> columns  of the unitary <code>Q</code> factor in the full QR decomposition of <code>A</code>, i.e. the columns that are not present in the <code>Q</code> factor of the compact QR decomposition. The isometric matrix <code>N</code> contains an orthonormal basis for the cokernel of <code>A</code> as its columns, i.e. <code>adjoint(A) * N = 0</code>.</p><div class="admonition is-info" id="Note-d2f915688bb99c19"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d2f915688bb99c19" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> argument as output.</p></div></div><div class="admonition is-info" id="Note-fbacf6e42e701cf5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fbacf6e42e701cf5" title="Permalink"></a></header><div class="admonition-body"><p>The matrix <code>N</code> is empty when <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/qr.jl#L46-L66">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.qr_null_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qr_null_pullback!(
    ΔA::AbstractMatrix, A, N, ΔN;
    gauge_atol::Real = default_pullback_gauge_atol(ΔN)
)</code></pre><p>Adds the pullback from the right nullspace of <code>A</code> to <code>ΔA</code>, given the nullspace basis <code>N</code> and its cotangent <code>ΔN</code> of <code>qr_null(A)</code>.</p><p>See also <a href="#MatrixAlgebraKit.qr_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>qr_pullback!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/qr.jl#L105-L115">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.qr_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.qr_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.qr_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qr_pullback!(
    ΔA, A, QR, ΔQR;
    tol::Real = default_pullback_gaugetol(QR[2]),
    rank_atol::Real = default_pullback_rank_atol(QR[2]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔQR[1])
)</code></pre><p>Adds the pullback from the QR decomposition of <code>A</code> to <code>ΔA</code> given the output <code>QR</code> and cotangent <code>ΔQR</code> of <code>qr_compact(A; positive = true)</code> or <code>qr_full(A; positive = true)</code>.</p><p>In the case where the rank <code>r</code> of the original matrix <code>A ≈ Q * R</code> (as determined by <code>rank_atol</code>) is less then the minimum of the number of rows and columns, the cotangents <code>ΔQ</code> and <code>ΔR</code>, only the first <code>r</code> columns of <code>Q</code> and the first <code>r</code> rows of <code>R</code> are well-defined, and also the adjoint variables <code>ΔQ</code> and <code>ΔR</code> should have nonzero values only in the first <code>r</code> columns and rows respectively. If nonzero values in the remaining columns or rows exceed <code>gauge_atol</code>, a warning will be printed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/qr.jl#L1-L18">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_null"><a class="docstring-binding" href="#MatrixAlgebraKit.right_null"><code>MatrixAlgebraKit.right_null</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_null(A; [alg], [trunc], kwargs...) -&gt; Nᴴ
right_null!(A, [Nᴴ], [alg]; [trunc], kwargs...) -&gt; Nᴴ</code></pre><p>Compute an orthonormal basis <code>N = adjoint(Nᴴ)</code> for the kernel of the matrix <code>A</code>, i.e. the nullspace of <code>A</code>, such that <code>A * Nᴴ&#39; ≈ 0</code> and <code>Nᴴ * Nᴴ&#39; ≈ I</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of <code>A</code>, whereas <code>trunc</code> can optionally  be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><div class="admonition is-info" id="Note-35f2c042fdc34631"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-35f2c042fdc34631" title="Permalink"></a></header><div class="admonition-body"><p>Here <a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional rows of <code>A</code>.</p></div></div><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:lq</code> : Factorize via LQ nullspace, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        Nᴴ = lq_null(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument. It is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        _, S, Vᴴ = svd_full(A; kwargs...)
        Nᴴ = truncate(right_null, (S, Vᴴ), trunc)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.right_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>right_null_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-d19f7345213c07f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d19f7345213c07f" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a> and <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L246-L322">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_null!"><a class="docstring-binding" href="#MatrixAlgebraKit.right_null!"><code>MatrixAlgebraKit.right_null!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_null(A; [alg], [trunc], kwargs...) -&gt; Nᴴ
right_null!(A, [Nᴴ], [alg]; [trunc], kwargs...) -&gt; Nᴴ</code></pre><p>Compute an orthonormal basis <code>N = adjoint(Nᴴ)</code> for the kernel of the matrix <code>A</code>, i.e. the nullspace of <code>A</code>, such that <code>A * Nᴴ&#39; ≈ 0</code> and <code>Nᴴ * Nᴴ&#39; ≈ I</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of <code>A</code>, whereas <code>trunc</code> can optionally  be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><div class="admonition is-info" id="Note-35f2c042fdc34631"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-35f2c042fdc34631" title="Permalink"></a></header><div class="admonition-body"><p>Here <a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional rows of <code>A</code>.</p></div></div><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:lq</code> : Factorize via LQ nullspace, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        Nᴴ = lq_null(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument. It is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        _, S, Vᴴ = svd_full(A; kwargs...)
        Nᴴ = truncate(right_null, (S, Vᴴ), trunc)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.right_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>right_null_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-d19f7345213c07f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d19f7345213c07f" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a> and <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L246-L322">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><a class="docstring-binding" href="#MatrixAlgebraKit.right_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>MatrixAlgebraKit.right_null_alg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right_null_alg(alg::AbstractAlgorithm) -&gt; RightNullAlgorithm</code></pre><p>Convert an algorithm to a <a href="#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm</code></a> wrapper for use with <a href="#MatrixAlgebraKit.right_null"><code>right_null</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:lq</code> or <code>:svd</code>) from the algorithm type and wraps it in a <code>RightNullAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.right_null_alg(alg::CustomAlgorithm) = RightNullAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm</code></a>, <a href="#MatrixAlgebraKit.right_null"><code>right_null</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L517-L533">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_orth"><a class="docstring-binding" href="#MatrixAlgebraKit.right_orth"><code>MatrixAlgebraKit.right_orth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_orth(A; [alg], [trunc], kwargs...) -&gt; C, Vᴴ
right_orth!(A, [CVᴴ], [alg]; [trunc], kwargs...) -&gt; C, Vᴴ</code></pre><p>Compute an orthonormal basis <code>V = adjoint(Vᴴ)</code> for the coimage of the matrix <code>A</code>, i.e. for the image of <code>adjoint(A)</code>, as well as a matrix <code>C</code> such that <code>A</code> factors as <code>A = C * Vᴴ</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>trunc</code> can optionally be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will typicall be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:lq</code> : Factorize via LQ decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        C, Vᴴ = lq_compact(A; kwargs...)</code></pre><ul><li><code>:polar</code> : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        C, Vᴴ = right_polar(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument, and is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        C, S, Vᴴ = svd_trunc(A; trunc, kwargs...)
        C = rmul!(C, S)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.right_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>right_orth_alg</code></a>.</p><hr/><div class="admonition is-info" id="Note-321073803e5231b5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-321073803e5231b5" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a> and <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L84-L162">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_orth!"><a class="docstring-binding" href="#MatrixAlgebraKit.right_orth!"><code>MatrixAlgebraKit.right_orth!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_orth(A; [alg], [trunc], kwargs...) -&gt; C, Vᴴ
right_orth!(A, [CVᴴ], [alg]; [trunc], kwargs...) -&gt; C, Vᴴ</code></pre><p>Compute an orthonormal basis <code>V = adjoint(Vᴴ)</code> for the coimage of the matrix <code>A</code>, i.e. for the image of <code>adjoint(A)</code>, as well as a matrix <code>C</code> such that <code>A</code> factors as <code>A = C * Vᴴ</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>trunc</code> can optionally be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will typicall be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:lq</code> : Factorize via LQ decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        C, Vᴴ = lq_compact(A; kwargs...)</code></pre><ul><li><code>:polar</code> : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        C, Vᴴ = right_polar(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument, and is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        C, S, Vᴴ = svd_trunc(A; trunc, kwargs...)
        C = rmul!(C, S)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="#MatrixAlgebraKit.right_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>right_orth_alg</code></a>.</p><hr/><div class="admonition is-info" id="Note-321073803e5231b5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-321073803e5231b5" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a> and <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L84-L162">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><a class="docstring-binding" href="#MatrixAlgebraKit.right_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>MatrixAlgebraKit.right_orth_alg</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right_orth_alg(alg::AbstractAlgorithm) -&gt; RightOrthAlgorithm</code></pre><p>Convert an algorithm to a <a href="#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm</code></a> wrapper for use with <a href="#MatrixAlgebraKit.right_orth"><code>right_orth</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:lq</code>, <code>:polar</code>, or <code>:svd</code>) from the algorithm type and wraps it in a <code>RightOrthAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.right_orth_alg(alg::CustomAlgorithm) = RightOrthAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm</code></a>, <a href="#MatrixAlgebraKit.right_orth"><code>right_orth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/orthnull.jl#L448-L464">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_polar"><a class="docstring-binding" href="#MatrixAlgebraKit.right_polar"><code>MatrixAlgebraKit.right_polar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_polar(A; kwargs...) -&gt; P, Wᴴ
right_polar(A, alg::AbstractAlgorithm) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ]; kwargs...) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -&gt; P, Wᴴ</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>n &gt;= m</code>, such that <code>A = P * Wᴴ</code>. Here, <code>P</code> is a positive (semi)definite matrix of size <code>(m, m)</code>, whereas <code>Wᴴ</code> is a matrix with orthonormal rows (its adjoint is isometric) of size <code>(n, m)</code>.</p><div class="admonition is-info" id="Note-8447edbce69380d5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8447edbce69380d5" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_polar"><code>left_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/polar.jl#L22-L39">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_polar!"><a class="docstring-binding" href="#MatrixAlgebraKit.right_polar!"><code>MatrixAlgebraKit.right_polar!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_polar(A; kwargs...) -&gt; P, Wᴴ
right_polar(A, alg::AbstractAlgorithm) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ]; kwargs...) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -&gt; P, Wᴴ</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>n &gt;= m</code>, such that <code>A = P * Wᴴ</code>. Here, <code>P</code> is a positive (semi)definite matrix of size <code>(m, m)</code>, whereas <code>Wᴴ</code> is a matrix with orthonormal rows (its adjoint is isometric) of size <code>(n, m)</code>.</p><div class="admonition is-info" id="Note-8447edbce69380d5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8447edbce69380d5" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_polar"><code>left_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/polar.jl#L22-L39">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.right_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.right_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.right_polar_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right_polar_pullback!(ΔA, A, PWᴴ, ΔPWᴴ)</code></pre><p>Adds the pullback from the left polar decomposition of <code>A</code> to <code>ΔA</code> given the output <code>PWᴴ</code> and cotangent <code>ΔPWᴴ</code> of <code>right_polar(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/polar.jl#L31-L36">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.schur_full"><a class="docstring-binding" href="#MatrixAlgebraKit.schur_full"><code>MatrixAlgebraKit.schur_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schur_full(A; kwargs...) -&gt; T, Z, vals
schur_full(A, alg::AbstractAlgorithm) -&gt; T, Z, vals
schur_full!(A, [TZv]; kwargs...) -&gt; T, Z, vals
schur_full!(A, [TZv], alg::AbstractAlgorithm) -&gt; T, Z, vals</code></pre><p>Compute the full Schur decomposition of the square matrix <code>A</code>, such that <code>A * Z = Z * T</code>, where the orthogonal or unitary matrix <code>Z</code> contains the Schur vectors and the square matrix <code>T</code> is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list <code>vals</code> contains the (complex-valued) eigenvalues of <code>A</code>, as extracted from the (quasi-)diagonal of <code>T</code>.</p><div class="admonition is-info" id="Note-96222ddbfa2df014"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-96222ddbfa2df014" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>schur_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>TZv</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/schur.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.schur_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.schur_full!"><code>MatrixAlgebraKit.schur_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schur_full(A; kwargs...) -&gt; T, Z, vals
schur_full(A, alg::AbstractAlgorithm) -&gt; T, Z, vals
schur_full!(A, [TZv]; kwargs...) -&gt; T, Z, vals
schur_full!(A, [TZv], alg::AbstractAlgorithm) -&gt; T, Z, vals</code></pre><p>Compute the full Schur decomposition of the square matrix <code>A</code>, such that <code>A * Z = Z * T</code>, where the orthogonal or unitary matrix <code>Z</code> contains the Schur vectors and the square matrix <code>T</code> is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list <code>vals</code> contains the (complex-valued) eigenvalues of <code>A</code>, as extracted from the (quasi-)diagonal of <code>T</code>.</p><div class="admonition is-info" id="Note-96222ddbfa2df014"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-96222ddbfa2df014" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>schur_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>TZv</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/schur.jl#L3-L19">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.schur_vals"><a class="docstring-binding" href="#MatrixAlgebraKit.schur_vals"><code>MatrixAlgebraKit.schur_vals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schur_vals(A; kwargs...) -&gt; vals
schur_vals(A, alg::AbstractAlgorithm) -&gt; vals
schur_vals!(A, [vals]; kwargs...) -&gt; vals
schur_vals!(A, [vals], alg::AbstractAlgorithm) -&gt; vals</code></pre><p>Compute the list of eigenvalues of <code>A</code> by computing the Schur decomposition of <code>A</code>.</p><div class="admonition is-info" id="Note-fe78fabb2cf3b8df"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fe78fabb2cf3b8df" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>schur_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>vals</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/schur.jl#L23-L37">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.schur_vals!"><a class="docstring-binding" href="#MatrixAlgebraKit.schur_vals!"><code>MatrixAlgebraKit.schur_vals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schur_vals(A; kwargs...) -&gt; vals
schur_vals(A, alg::AbstractAlgorithm) -&gt; vals
schur_vals!(A, [vals]; kwargs...) -&gt; vals
schur_vals!(A, [vals], alg::AbstractAlgorithm) -&gt; vals</code></pre><p>Compute the list of eigenvalues of <code>A</code> by computing the Schur decomposition of <code>A</code>.</p><div class="admonition is-info" id="Note-fe78fabb2cf3b8df"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fe78fabb2cf3b8df" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>schur_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>vals</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/schur.jl#L23-L37">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.select_algorithm"><a class="docstring-binding" href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MatrixAlgebraKit.select_algorithm(f, A, alg::AbstractAlgorithm)
MatrixAlgebraKit.select_algorithm(f, A, alg::Symbol; kwargs...)
MatrixAlgebraKit.select_algorithm(f, A, alg::Type; kwargs...)
MatrixAlgebraKit.select_algorithm(f, A; kwargs...)
MatrixAlgebraKit.select_algorithm(f, A, (; kwargs...))</code></pre><p>Decide on an algorithm to use for implementing the function <code>f</code> on inputs of type <code>A</code>. This can be obtained both for values <code>A</code> or types <code>A</code>.</p><p>If <code>alg</code> is an <code>AbstractAlgorithm</code> instance, it will be returned as-is.</p><p>If <code>alg</code> is a <code>Symbol</code> or a <code>Type</code> of algorithm, the return value is obtained by calling the corresponding algorithm constructor; keyword arguments in <code>kwargs</code> are passed along  to this constructor.</p><p>If <code>alg</code> is not specified (or <code>nothing</code>), an algorithm will be selected  automatically with <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> and  the keyword arguments in <code>kwargs</code> will be passed to the algorithm constructor. Finally, the same behavior is obtained when the keyword arguments are passed as the third positional argument in the form of a <code>NamedTuple</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L68-L89">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.select_null_truncation"><a class="docstring-binding" href="#MatrixAlgebraKit.select_null_truncation"><code>MatrixAlgebraKit.select_null_truncation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MatrixAlgebraKit.select_null_truncation(trunc)</code></pre><p>Construct a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a> from the given <code>NamedTuple</code> of keywords or input strategy, to implement a nullspace selection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L175-L179">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.select_truncation"><a class="docstring-binding" href="#MatrixAlgebraKit.select_truncation"><code>MatrixAlgebraKit.select_truncation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">MatrixAlgebraKit.select_truncation(trunc)</code></pre><p>Construct a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a> from the given <code>NamedTuple</code> of keywords or input strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L157-L161">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.sign_safe-Tuple{Real}"><a class="docstring-binding" href="#MatrixAlgebraKit.sign_safe-Tuple{Real}"><code>MatrixAlgebraKit.sign_safe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sign_safe(s::Number)</code></pre><p>Compute the sign of a number <code>s</code>, but return <code>+1</code> if <code>s</code> is zero so that the result is always a number with modulus 1, i.e. an element of the unitary group U(1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/common/safemethods.jl#L4-L9">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_compact"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_compact"><code>MatrixAlgebraKit.svd_compact</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_compact(A; kwargs...) -&gt; U, S, Vᴴ
svd_compact(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the compact singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k = min(m, n)</code>.</p><div class="admonition is-info" id="Note-5a024796cb806dd3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5a024796cb806dd3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L23-L41">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_compact!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_compact!"><code>MatrixAlgebraKit.svd_compact!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_compact(A; kwargs...) -&gt; U, S, Vᴴ
svd_compact(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the compact singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k = min(m, n)</code>.</p><div class="admonition is-info" id="Note-5a024796cb806dd3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5a024796cb806dd3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L23-L41">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_full"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_full"><code>MatrixAlgebraKit.svd_full</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_full(A; kwargs...) -&gt; U, S, Vᴴ
svd_full(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the full singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> and <code>Vᴴ</code> are unitary matrices of size <code>(m, m)</code> and <code>(n, n)</code> respectively, and <code>S</code> is a diagonal matrix of size <code>(m, n)</code>.</p><div class="admonition is-info" id="Note-77f6058cdd84c9c3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-77f6058cdd84c9c3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L3-L20">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_full!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_full!"><code>MatrixAlgebraKit.svd_full!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_full(A; kwargs...) -&gt; U, S, Vᴴ
svd_full(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the full singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> and <code>Vᴴ</code> are unitary matrices of size <code>(m, m)</code> and <code>(n, n)</code> respectively, and <code>S</code> is a diagonal matrix of size <code>(m, n)</code>.</p><div class="admonition is-info" id="Note-77f6058cdd84c9c3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-77f6058cdd84c9c3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L3-L20">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_pullback!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_pullback!"><code>MatrixAlgebraKit.svd_pullback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_pullback!(
    ΔA, A, USVᴴ, ΔUSVᴴ, [ind];
    rank_atol::Real = default_pullback_rank_atol(USVᴴ[2]),
    degeneracy_atol::Real = default_pullback_rank_atol(USVᴴ[2]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔUSVᴴ[1], ΔUSVᴴ[3])
)</code></pre><p>Adds the pullback from the SVD of <code>A</code> to <code>ΔA</code> given the output <code>USVᴴ</code> of <code>svd_compact</code> or <code>svd_full</code> and the cotangent <code>ΔUSVᴴ</code> of <code>svd_compact</code>, <code>svd_full</code> or <code>svd_trunc</code>.</p><p>In particular, it is assumed that <code>A ≈ U * S * Vᴴ</code>, or thus, that no singular values with magnitude less than <code>rank_atol</code> are missing from <code>S</code>.  For the cotangents, an arbitrary number of singular vectors or singular values can be missing, i.e. for a matrix <code>A</code> with size <code>(m, n)</code>, <code>ΔU</code> and <code>ΔVᴴ</code> can have sizes <code>(m, pU)</code> and <code>(pV, n)</code> respectively, whereas <code>diagview(ΔS)</code> can have length <code>pS</code>. In those cases, additionally <code>ind</code> is required to specify which singular vectors and values are present in <code>ΔU</code>, <code>ΔS</code> and <code>ΔVᴴ</code>.</p><p>A warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of <code>U&#39; * ΔU + Vᴴ * ΔVᴴ&#39;</code>, restricted to rows <code>i</code> and columns <code>j</code> for which <code>abs(S[i] - S[j]) &lt; degeneracy_atol</code>, is not small compared to <code>gauge_atol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/svd.jl#L1-L22">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_trunc"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_trunc"><code>MatrixAlgebraKit.svd_trunc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_trunc(A; [trunc], kwargs...) -&gt; U, S, Vᴴ, ϵ
svd_trunc(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ, ϵ
svd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -&gt; U, S, Vᴴ, ϵ
svd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ, ϵ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; ≈ U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded singular values.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-2702ed4c9a5df22f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2702ed4c9a5df22f" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_trunc_no_error"><code>svd_trunc_no_error(!)</code></a>, <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>, and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L44-L92">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_trunc!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_trunc!"><code>MatrixAlgebraKit.svd_trunc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_trunc(A; [trunc], kwargs...) -&gt; U, S, Vᴴ, ϵ
svd_trunc(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ, ϵ
svd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -&gt; U, S, Vᴴ, ϵ
svd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ, ϵ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; ≈ U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded singular values.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-2702ed4c9a5df22f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2702ed4c9a5df22f" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_trunc_no_error"><code>svd_trunc_no_error(!)</code></a>, <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>, and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L44-L92">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_trunc_no_error"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_trunc_no_error"><code>MatrixAlgebraKit.svd_trunc_no_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_trunc_no_error(A; [trunc], kwargs...) -&gt; U, S, Vᴴ
svd_trunc_no_error(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_trunc_no_error!(A, [USVᴴ]; [trunc], kwargs...) -&gt; U, S, Vᴴ
svd_trunc_no_error!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; ≈ U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy. The truncation error is <em>not</em> returned.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-9537aa8d834db1f4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9537aa8d834db1f4" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_trunc_no_error!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>, <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L95-L141">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_trunc_no_error!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_trunc_no_error!"><code>MatrixAlgebraKit.svd_trunc_no_error!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_trunc_no_error(A; [trunc], kwargs...) -&gt; U, S, Vᴴ
svd_trunc_no_error(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_trunc_no_error!(A, [USVᴴ]; [trunc], kwargs...) -&gt; U, S, Vᴴ
svd_trunc_no_error!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; ≈ U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy. The truncation error is <em>not</em> returned.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-9537aa8d834db1f4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9537aa8d834db1f4" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_trunc_no_error!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>, <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a> and <a href="../user_interface/truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L95-L141">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}"><code>MatrixAlgebraKit.svd_trunc_pullback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">svd_trunc_pullback!(
    ΔA, A, USVᴴ, ΔUSVᴴ;
    rank_atol::Real = default_pullback_rank_atol(USVᴴ[2]),
    degeneracy_atol::Real = default_pullback_rank_atol(USVᴴ[2]),
    gauge_atol::Real = default_pullback_gauge_atol(ΔUSVᴴ[1], ΔUSVᴴ[3])
)</code></pre><p>Adds the pullback from the truncated SVD of <code>A</code> to <code>ΔA</code>, given the output <code>USVᴴ</code> and the cotangent <code>ΔUSVᴴ</code> of <code>svd_trunc</code>.</p><p>In particular, it is assumed that <code>A * Vᴴ&#39; ≈ U * S</code> and <code>U&#39; * A = S * Vᴴ</code>, with <code>U</code> and <code>Vᴴ</code> rectangular matrices of left and right singular vectors, and <code>S</code> diagonal. For the cotangents, it is assumed that if <code>ΔU</code> and <code>ΔVᴴ</code> are not zero, then they have the same size as <code>U</code> and <code>Vᴴ</code> (respectively), and if <code>ΔS</code> is not zero, then it is a diagonal matrix of the same size as <code>S</code>. For this method to work correctly, it is also assumed that the remaining singular values (not included in <code>S</code>) are (sufficiently) separated from those in <code>S</code>.</p><p>A warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of <code>U&#39; * ΔU + Vᴴ * ΔVᴴ&#39;</code>, restricted to rows <code>i</code> and columns <code>j</code> for which <code>abs(S[i] - S[j]) &lt; degeneracy_atol</code>, is not small compared to <code>gauge_atol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/svd.jl#L103-L124">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_vals"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_vals"><code>MatrixAlgebraKit.svd_vals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_vals(A; kwargs...) -&gt; S
svd_vals(A, alg::AbstractAlgorithm) -&gt; S
svd_vals!(A, [S]; kwargs...) -&gt; S
svd_vals!(A, [S], alg::AbstractAlgorithm) -&gt; S</code></pre><p>Compute the vector of singular values of <code>A</code>, such that for an M×N matrix <code>A</code>, <code>S</code> is a vector of size <code>K = min(M, N)</code>, the number of kept singular values.</p><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L144-L155">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_vals!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_vals!"><code>MatrixAlgebraKit.svd_vals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_vals(A; kwargs...) -&gt; S
svd_vals(A, alg::AbstractAlgorithm) -&gt; S
svd_vals!(A, [S]; kwargs...) -&gt; S
svd_vals!(A, [S], alg::AbstractAlgorithm) -&gt; S</code></pre><p>Compute the vector of singular values of <code>A</code>, such that for an M×N matrix <code>A</code>, <code>S</code> is a vector of size <code>K = min(M, N)</code>, the number of kept singular values.</p><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/svd.jl#L144-L155">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.svd_vals_pullback!"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_vals_pullback!"><code>MatrixAlgebraKit.svd_vals_pullback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_vals_pullback!(
    ΔA, A, USVᴴ, ΔS, [ind];
    rank_atol::Real = default_pullback_rank_atol(USVᴴ[2]),
    degeneracy_atol::Real = default_pullback_rank_atol(USVᴴ[2])
)</code></pre><p>Adds the pullback from the singular values of <code>A</code> to <code>ΔA</code>, given the output <code>USVᴴ</code> of <code>svd_compact</code>, and the cotangent <code>ΔS</code> of <code>svd_vals</code>.</p><p>In particular, it is assumed that <code>A ≈ U * S * Vᴴ</code>, or thus, that no singular values with magnitude less than <code>rank_atol</code> are missing from <code>S</code>. For the cotangents, an arbitrary number of singular vectors or singular values can be missing, i.e. for a matrix <code>A</code> with size <code>(m, n)</code>, <code>diagview(ΔS)</code> can have length <code>pS</code>. In those cases, additionally <code>ind</code> is required to specify which singular vectors and values are present in <code>ΔS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/pullbacks/svd.jl#L205-L221">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.truncate"><a class="docstring-binding" href="#MatrixAlgebraKit.truncate"><code>MatrixAlgebraKit.truncate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">truncate(::typeof(f), F, strategy::TruncationStrategy) -&gt; F′, ind</code></pre><p>Given a factorization function <code>f</code> and truncation <code>strategy</code>, truncate the factors <code>F</code> such that the rows or columns at the indices <code>ind</code> are kept.</p><p>See also <a href="#MatrixAlgebraKit.findtruncated"><code>findtruncated</code></a> and <a href="#MatrixAlgebraKit.findtruncated_svd"><code>findtruncated_svd</code></a> for determining the indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L212-L219">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.truncation_error"><a class="docstring-binding" href="#MatrixAlgebraKit.truncation_error"><code>MatrixAlgebraKit.truncation_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">truncation_error(values, ind)</code></pre><p>Compute the truncation error as the 2-norm of the values that are not kept by <code>ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L225-L228">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.truncation_error!"><a class="docstring-binding" href="#MatrixAlgebraKit.truncation_error!"><code>MatrixAlgebraKit.truncation_error!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">truncation_error(values, ind)</code></pre><p>Compute the truncation error as the 2-norm of the values that are not kept by <code>ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L225-L228">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.truncerror-Tuple{}"><a class="docstring-binding" href="#MatrixAlgebraKit.truncerror-Tuple{}"><code>MatrixAlgebraKit.truncerror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">truncerror(; atol::Real=0, rtol::Real=0, p::Real=2)</code></pre><p>Truncation strategy for truncating values such that the error in the factorization is smaller than <code>max(atol, rtol * norm)</code>, where the error is determined using the <code>p</code>-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L178-L183">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.truncfilter-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>MatrixAlgebraKit.truncfilter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">truncfilter(filter)</code></pre><p>Truncation strategy to keep the values for which <code>filter</code> returns true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L128-L132">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.truncrank-Tuple{Integer}"><a class="docstring-binding" href="#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>MatrixAlgebraKit.truncrank</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">truncrank(howmany::Integer; by=abs, rev::Bool=true)</code></pre><p>Truncation strategy to keep the first <code>howmany</code> values when sorted according to <code>by</code> or the last <code>howmany</code> if <code>rev</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L108-L112">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.trunctol-Tuple{}"><a class="docstring-binding" href="#MatrixAlgebraKit.trunctol-Tuple{}"><code>MatrixAlgebraKit.trunctol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trunctol(; atol::Real=0, rtol::Real=0, p::Real=2, by=abs, keep_below::Bool=false)</code></pre><p>Truncation strategy to keep the values that satisfy <code>by(val) &gt; max(atol, rtol * norm(values, p)</code>. If <code>keep_below = true</code>, discard these values instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/interface/truncation.jl#L153-L158">source</a></section></details></article><h2 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h2><article><details class="docstring"><summary id="MatrixAlgebraKit.@algdef-Tuple{Any}"><a class="docstring-binding" href="#MatrixAlgebraKit.@algdef-Tuple{Any}"><code>MatrixAlgebraKit.@algdef</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@algdef AlgorithmName</code></pre><p>Convenience macro to define an algorithm <code>AlgorithmName</code> that accepts generic keywords. This defines an exported alias for <a href="#MatrixAlgebraKit.Algorithm"><code>Algorithm{:AlgorithmName}</code></a> along with some utility methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L238-L244">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.@check_scalar"><a class="docstring-binding" href="#MatrixAlgebraKit.@check_scalar"><code>MatrixAlgebraKit.@check_scalar</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@check_scalar(x, y, [op], [eltype])</code></pre><p>Check if <code>eltype(x) == op(eltype(y))</code> and throw an error if not. By default <code>op = identity</code> and `eltype = eltype&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L411-L416">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.@check_size"><a class="docstring-binding" href="#MatrixAlgebraKit.@check_size"><code>MatrixAlgebraKit.@check_size</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@check_size(x, sz, [size])</code></pre><p>Check if <code>size(x) == sz</code> and throw an error if not. By default, <code>size = size</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L432-L437">source</a></section></details></article><article><details class="docstring"><summary id="MatrixAlgebraKit.@functiondef-Tuple"><a class="docstring-binding" href="#MatrixAlgebraKit.@functiondef-Tuple"><code>MatrixAlgebraKit.@functiondef</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@functiondef [n_args=1] f</code></pre><p>Convenience macro to define the boilerplate code that dispatches between several versions of <code>f</code> and <code>f!</code>. By default, <code>f</code> accepts a single argument <code>A</code>.  This enables the following signatures to be defined in terms of the final <code>f!(A, out, alg::Algorithm)</code>.</p><pre><code class="language-julia hljs">    f(A; kwargs...)
    f(A, alg::Algorithm)
    f!(A, [out]; kwargs...)
    f!(A, alg::Algorithm)</code></pre><p>The number of inputs can be set with the <code>n_args</code> keyword argument, so that </p><pre><code class="language-julia hljs">@functiondef n_args=2 f</code></pre><p>would create </p><pre><code class="language-julia hljs">    f(A, B; kwargs...)
    f(A, B, alg::Algorithm)
    f!(A, B, [out]; kwargs...)
    f!(A, B, alg::Algorithm)</code></pre><p>See also <a href="#MatrixAlgebraKit.copy_input"><code>copy_input</code></a>, <a href="#MatrixAlgebraKit.select_algorithm"><code>select_algorithm</code></a> and <a href="#MatrixAlgebraKit.initialize_output"><code>initialize_output</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/544f16ac68111692f57441deed13e982ea3bfd71/src/algorithms.jl#L352-L383">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dev_interface/">« Developer Interface</a><a class="docs-footer-nextpage" href="../changelog/">Changelog »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 28 December 2025 02:31">Sunday 28 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
