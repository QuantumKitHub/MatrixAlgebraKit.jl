var documenterSearchIndex = {"docs":
[{"location":"user_interface/matrix_functions/#Matrix-functions","page":"Matrix functions","title":"Matrix functions","text":"","category":"section"},{"location":"user_interface/matrix_functions/","page":"Matrix functions","title":"Matrix functions","text":"Coming soon...","category":"page"},{"location":"library/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"library/#Constants-and-types","page":"Library","title":"Constants and types","text":"","category":"section"},{"location":"library/#MatrixAlgebraKit.AbstractAlgorithm","page":"Library","title":"MatrixAlgebraKit.AbstractAlgorithm","text":"abstract type AbstractAlgorithm end\n\nSupertype to dispatch on specific implementations of different the different functions. Concrete subtypes should represent both a way to dispatch to a given implementation, as well as the configuration of that implementation.\n\nSee also select_algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.Algorithm","page":"Library","title":"MatrixAlgebraKit.Algorithm","text":"Algorithm{name,KW} <: AbstractAlgorithm\n\nBare-bones implementation of an algorithm, where name should be a Symbol to dispatch on, and KW is typically a NamedTuple indicating the keyword arguments.\n\nSee also @algdef.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_DivideAndConquer","text":"CUSOLVER_DivideAndConquer()\n\nAlgorithm type to denote the CUSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_HouseholderQR","text":"CUSOLVER_HouseholderQR(; positive = false)\n\nAlgorithm type to denote the standard CUSOLVER algorithm for computing the QR decomposition of a matrix using Householder reflectors. The keyword positive=true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_Jacobi","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_Jacobi","text":"CUSOLVER_Jacobi()\n\nAlgorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_QRIteration","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_QRIteration","text":"CUSOLVER_QRIteration()\n\nAlgorithm type to denote the CUSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_Randomized","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_Randomized","text":"CUSOLVER_Randomized(; k, p, niters)\n\nAlgorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix using the randomized SVD algorithm. Here, k denotes the number of singular values that should be computed, therefore requiring k <= min(size(A)). This method is accurate for small values of k compared to the size of the input matrix, where the accuracy can be improved by increasing p, the number of additional values used for oversampling, and niters, the number of iterations the solver uses, at the cost of increasing the runtime.\n\nSee also the CUSOLVER documentation for more information.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_SVDPolar","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_SVDPolar","text":"CUSOLVER_SVDPolar()\n\nAlgorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix by using Halley's iterative algorithm to compute the polar decompositon, followed by the hermitian eigenvalue decomposition of the positive definite factor.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_Simple","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_Simple","text":"CUSOLVER_Simple()\n\nAlgorithm type to denote the simple CUSOLVER driver for computing the non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.DiagonalAlgorithm","page":"Library","title":"MatrixAlgebraKit.DiagonalAlgorithm","text":"DiagonalAlgorithm(; kwargs...)\n\nAlgorithm type to denote a native Julia implementation of the decompositions making use of the diagonal structure of the input and outputs.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Bisection","page":"Library","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Expert","page":"Library","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert()\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_HouseholderLQ","page":"Library","title":"MatrixAlgebraKit.LAPACK_HouseholderLQ","text":"LAPACK_HouseholderLQ(; blocksize, positive = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. ?gelqt will be chosen if blocksize > 1 or ?gelqf will be chosen if blocksize == 1. The keyword positive=true can be used to ensure that the diagonal elements of L are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.LAPACK_HouseholderQR","text":"LAPACK_HouseholderQR(; blocksize, positive = false, pivoted = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  ?geqrt will be chosen if blocksize > 1. With blocksize == 1, ?geqrf will be chosen if pivoted == false and ?geqp3 will be chosen if pivoted == true. The keyword positive=true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Jacobi","page":"Library","title":"MatrixAlgebraKit.LAPACK_Jacobi","text":"LAPACK_Jacobi()\n\nAlgorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","page":"Library","title":"MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","text":"LAPACK_MultipleRelativelyRobustRepresentations()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_QRIteration","page":"Library","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Simple","page":"Library","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple()\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.NativeBlocked","page":"Library","title":"MatrixAlgebraKit.NativeBlocked","text":"NativeBlocked(; blocksize = 32)\n\nAlgorithm type to denote a native blocked algorithm with given blocksize for computing the hermitian or anti-hermitian part of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.NoTruncation","page":"Library","title":"MatrixAlgebraKit.NoTruncation","text":"NoTruncation()\n\nTrivial truncation strategy that keeps all values, mostly for testing purposes. See also notrunc().\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.PolarNewton","page":"Library","title":"MatrixAlgebraKit.PolarNewton","text":"PolarNewton(; maxiter = 10, tol = defaulttol(A))\n\nAlgorithm for computing the polar decomposition of a matrix A via scaled Newton iteration, with a maximum of maxiter iterations and until convergence up to tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.PolarViaSVD","page":"Library","title":"MatrixAlgebraKit.PolarViaSVD","text":"PolarViaSVD(svd_alg)\n\nAlgorithm for computing the polar decomposition of a matrix A via the singular value decomposition (SVD) of A. The svd_alg argument specifies the SVD algorithm to use.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_Bisection","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_Bisection","text":"ROCSOLVER_Bisection()\n\nAlgorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_DivideAndConquer","text":"ROCSOLVER_DivideAndConquer()\n\nAlgorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_HouseholderQR","text":"ROCSOLVER_HouseholderQR(; positive = false)\n\nAlgorithm type to denote the standard ROCSOLVER algorithm for computing the QR decomposition of a matrix using Householder reflectors. The keyword positive=true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_Jacobi","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_Jacobi","text":"ROCSOLVER_Jacobi()\n\nAlgorithm type to denote the ROCSOLVER driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_QRIteration","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_QRIteration","text":"ROCSOLVER_QRIteration()\n\nAlgorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncatedAlgorithm","page":"Library","title":"MatrixAlgebraKit.TruncatedAlgorithm","text":"TruncatedAlgorithm(alg::AbstractAlgorithm, trunc::TruncationAlgorithm)\n\nGeneric wrapper type for algorithms that consist of first using alg, followed by a truncation through trunc.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByError","page":"Library","title":"MatrixAlgebraKit.TruncationByError","text":"TruncationByError(; atol::Real, rtol::Real, p::Real)\n\nTruncation strategy to discard values until the error caused by the discarded values exceeds some tolerances. See also truncerror.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByFilter","page":"Library","title":"MatrixAlgebraKit.TruncationByFilter","text":"TruncationByFilter(filter::Function)\n\nTruncation strategy to keep the values for which filter returns true.\n\nSee also truncfilter.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByOrder","page":"Library","title":"MatrixAlgebraKit.TruncationByOrder","text":"TruncationByOrder(howmany::Int, by::Function, rev::Bool)\n\nTruncation strategy to keep the first howmany values when sorted according to by in increasing (decreasing) order if rev is false (true).\n\nSee also truncrank.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByValue","page":"Library","title":"MatrixAlgebraKit.TruncationByValue","text":"TruncationByValue(atol::Real, rtol::Real, p::Real, by, keep_below::Bool=false)\n\nTruncation strategy to keep the values that satisfy by(val) > max(atol, rtol * norm(values, p). If keep_below = true, discard these values instead. See also trunctol\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationIntersection","page":"Library","title":"MatrixAlgebraKit.TruncationIntersection","text":"TruncationIntersection(trunc::TruncationStrategy, truncs::TruncationStrategy...)\n\nTruncation strategy that composes multiple truncation strategies, keeping values that are common between them.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationStrategy","page":"Library","title":"MatrixAlgebraKit.TruncationStrategy","text":"abstract type TruncationStrategy end\n\nSupertype to denote different strategies for truncated decompositions that are implemented via post-truncation.\n\nSee also truncate\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationStrategy-Tuple{}","page":"Library","title":"MatrixAlgebraKit.TruncationStrategy","text":"TruncationStrategy(; kwargs...)\n\nSelect a truncation strategy based on the provided keyword arguments.\n\nKeyword arguments\n\nThe following keyword arguments are all optional, and their default value (nothing) will be ignored. It is also allowed to combine multiple of these, in which case the kept values will consist of the intersection of the different truncated strategies.\n\natol::Real : Absolute tolerance for the truncation\nrtol::Real : Relative tolerance for the truncation\nmaxrank::Real : Maximal rank for the truncation\nmaxerror::Real : Maximal truncation error.\nfilter : Custom filter to select truncated values.\n\n\n\n\n\n","category":"method"},{"location":"library/#Functions","page":"Library","title":"Functions","text":"","category":"section"},{"location":"library/#MatrixAlgebraKit.copy_input","page":"Library","title":"MatrixAlgebraKit.copy_input","text":"copy_input(f, A)\n\nPreprocess the input A for a given function, such that it may be handled correctly later. This may include a copy whenever the implementation would destroy the original matrix, or a change of element type to something that is supported.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.default_algorithm","page":"Library","title":"MatrixAlgebraKit.default_algorithm","text":"MatrixAlgebraKit.default_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.default_algorithm(f, ::Type{TA}; kwargs...) where {TA}\n\nSelect the default algorithm for a given factorization function f and input A. In general, this is called by select_algorithm if no algorithm is specified explicitly. New types should prefer to register their default algorithms in the type domain.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.default_hermitian_tol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_hermitian_tol","text":"default_hermitian_tol(A)\n\nDefault tolerance for deciding to warn if the provided A is not hermitian.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.default_pullback_gaugetol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_pullback_gaugetol","text":"default_pullback_gaugetol(a)\n\nDefault tolerance for deciding to warn if incoming adjoints of a pullback rule has components that are not gauge-invariant.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.defaulttol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.defaulttol","text":"defaulttol(x)\n\nDefault tolerance or precision for a given object, e.g. to decide when it can be considerd to be zero or ignored in some other way, or how accurate some quantity needs to be computed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eig_full","page":"Library","title":"MatrixAlgebraKit.eig_full","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_full!","page":"Library","title":"MatrixAlgebraKit.eig_full!","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_pullback!","page":"Library","title":"MatrixAlgebraKit.eig_pullback!","text":"eig_pullback!(\n    ΔA::AbstractMatrix, A, DV, ΔDV, [ind];\n    tol = default_pullback_gaugetol(DV[1]),\n    degeneracy_atol = tol,\n    gauge_atol = tol\n)\n\nAdds the pullback from the full eigenvalue decomposition of A to ΔA, given the output DV of eig_full and the cotangent ΔDV of eig_full or eig_trunc.\n\nIn particular, it is assumed that A ≈ V * D * inv(V) with thus size(A) == size(V) == size(D) and D diagonal. For the cotangents, an arbitrary number of eigenvectors or eigenvalues can be missing, i.e. for a matrix A of size (n, n), ΔV can have size (n, pV) and diagview(ΔD) can have length pD. In those cases, additionally ind is required to specify which eigenvectors or eigenvalues are present in ΔV or ΔD. By default, it is assumed that all eigenvectors and eigenvalues are present.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of V' * ΔV to rows i and columns j for which abs(D[i] - D[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc","page":"Library","title":"MatrixAlgebraKit.eig_trunc","text":"eig_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neig_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neig_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all eigenvalues.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!), eig_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc!","page":"Library","title":"MatrixAlgebraKit.eig_trunc!","text":"eig_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neig_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neig_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all eigenvalues.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!), eig_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.eig_trunc_pullback!","text":"eig_trunc_pullback!(\n    ΔA::AbstractMatrix, ΔDV, A, DV;\n    tol = default_pullback_gaugetol(DV[1]),\n    degeneracy_atol = tol,\n    gauge_atol = tol\n)\n\nAdds the pullback from the truncated eigenvalue decomposition of A to ΔA, given the output DV and the cotangent ΔDV of eig_trunc.\n\nIn particular, it is assumed that A * V ≈ V * D with V a rectangular matrix of eigenvectors and D diagonal. For the cotangents, it is assumed that if ΔV is not zero, then it has the same number of columns as V, and if ΔD is not zero, then it is a diagonal matrix of the same size as D.\n\nFor this method to work correctly, it is also assumed that the remaining eigenvalues (not included in D) are (sufficiently) separated from those in D.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of V' * ΔV to rows i and columns j for which abs(D[i] - D[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eig_vals","page":"Library","title":"MatrixAlgebraKit.eig_vals","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_vals!","page":"Library","title":"MatrixAlgebraKit.eig_vals!","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_full","page":"Library","title":"MatrixAlgebraKit.eigh_full","text":"eigh_full(A; kwargs...) -> D, V, ϵ\neigh_full(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_full!(A, [DV]; kwargs...) -> D, V, ϵ\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_full!","page":"Library","title":"MatrixAlgebraKit.eigh_full!","text":"eigh_full(A; kwargs...) -> D, V, ϵ\neigh_full(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_full!(A, [DV]; kwargs...) -> D, V, ϵ\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_pullback!","page":"Library","title":"MatrixAlgebraKit.eigh_pullback!","text":"eigh_pullback!(\n    ΔA::AbstractMatrix, A, DV, ΔDV, [ind];\n    tol = default_pullback_gaugetol(DV[1]),\n    degeneracy_atol = tol,\n    gauge_atol = tol\n)\n\nAdds the pullback from the Hermitian eigenvalue decomposition of A to ΔA, given the output DV of eigh_full and the cotangent ΔDV of eigh_full or eigh_trunc.\n\nIn particular, it is assumed that A ≈ V * D * V' with thus size(A) == size(V) == size(D) and D diagonal. For the cotangents, an arbitrary number of eigenvectors or eigenvalues can be missing, i.e. for a matrix A of size (n, n), ΔV can have size (n, pV) and diagview(ΔD) can have length pD. In those cases, additionally ind is required to specify which eigenvectors or eigenvalues are present in ΔV or ΔD. By default, it is assumed that all eigenvectors and eigenvalues are present.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of V' * ΔV, restricted to rows i and columns j for which `abs(D[i]\n\nD[j]) < degeneracyatol, is not small compared togaugeatol`.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc","page":"Library","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the discarded eigenvalues.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all eigenvalues.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!), eigh_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc!","page":"Library","title":"MatrixAlgebraKit.eigh_trunc!","text":"eigh_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the discarded eigenvalues.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all eigenvalues.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!), eigh_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.eigh_trunc_pullback!","text":"eigh_trunc_pullback!(\n    ΔA::AbstractMatrix, A, DV, ΔDV;\n    tol=default_pullback_gaugetol(DV[1]),\n    degeneracy_atol=tol,\n    gauge_atol=tol\n)\n\nAdds the pullback from the truncated Hermitian eigenvalue decomposition of A to ΔA, given the output DV and the cotangent ΔDV of eig_trunc.\n\nIn particular, it is assumed that A * V ≈ V * D with V a rectangular matrix of eigenvectors and D diagonal. For the cotangents, it is assumed that if ΔV is not zero, then it has the same number of columns as V, and if ΔD is not zero, then it is a diagonal matrix of the same size as D.\n\nFor this method to work correctly, it is also assumed that the remaining eigenvalues (not included in D) are (sufficiently) separated from those in D.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of V' * ΔV to rows i and columns j for which abs(D[i] - D[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eigh_vals","page":"Library","title":"MatrixAlgebraKit.eigh_vals","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_vals!","page":"Library","title":"MatrixAlgebraKit.eigh_vals!","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.findtruncated","page":"Library","title":"MatrixAlgebraKit.findtruncated","text":"MatrixAlgebraKit.findtruncated(values::AbstractVector, strategy::TruncationStrategy)\n\nGeneric interface for finding truncated values of the spectrum of a decomposition based on the strategy. The output should be a collection of indices specifying which values to keep. MatrixAlgebraKit.findtruncated is used inside of the default implementation of truncate to perform the truncation. It does not assume that the values are sorted. For a version that assumes the values are reverse sorted (which is the standard case for SVD) see MatrixAlgebraKit.findtruncated_svd.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.findtruncated_svd","page":"Library","title":"MatrixAlgebraKit.findtruncated_svd","text":"MatrixAlgebraKit.findtruncated_svd(values::AbstractVector, strategy::TruncationStrategy)\n\nLike MatrixAlgebraKit.findtruncated but assumes that the values are real and sorted in descending order, as typically obtained by the SVD. This assumption is not checked, and this is used in the default implementation of svd_trunc!.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_full","page":"Library","title":"MatrixAlgebraKit.gen_eig_full","text":"gen_eig_full(A, B; kwargs...) -> W, V\ngen_eig_full(A, B, alg::AbstractAlgorithm) -> W, V\ngen_eig_full!(A, B, [WV]; kwargs...) -> W, V\ngen_eig_full!(A, B, [WV], alg::AbstractAlgorithm) -> W, V\n\nCompute the full generalized eigenvalue decomposition of the square matrices A and B, such that A * V = B * V * W, where the invertible matrix V contains the generalized eigenvectors and the diagonal matrix W contains the associated generalized eigenvalues.\n\nnote: Note\nThe bang method gen_eig_full! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided WV as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_full!","page":"Library","title":"MatrixAlgebraKit.gen_eig_full!","text":"gen_eig_full(A, B; kwargs...) -> W, V\ngen_eig_full(A, B, alg::AbstractAlgorithm) -> W, V\ngen_eig_full!(A, B, [WV]; kwargs...) -> W, V\ngen_eig_full!(A, B, [WV], alg::AbstractAlgorithm) -> W, V\n\nCompute the full generalized eigenvalue decomposition of the square matrices A and B, such that A * V = B * V * W, where the invertible matrix V contains the generalized eigenvectors and the diagonal matrix W contains the associated generalized eigenvalues.\n\nnote: Note\nThe bang method gen_eig_full! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided WV as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_vals","page":"Library","title":"MatrixAlgebraKit.gen_eig_vals","text":"gen_eig_vals(A, B; kwargs...) -> W\ngen_eig_vals(A, B, alg::AbstractAlgorithm) -> W\ngen_eig_vals!(A, B, [W]; kwargs...) -> W \ngen_eig_vals!(A, B, [W], alg::AbstractAlgorithm) -> W\n\nCompute the list of generalized eigenvalues of A and B.\n\nnote: Note\nThe bang method gen_eig_vals! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_vals!","page":"Library","title":"MatrixAlgebraKit.gen_eig_vals!","text":"gen_eig_vals(A, B; kwargs...) -> W\ngen_eig_vals(A, B, alg::AbstractAlgorithm) -> W\ngen_eig_vals!(A, B, [W]; kwargs...) -> W \ngen_eig_vals!(A, B, [W], alg::AbstractAlgorithm) -> W\n\nCompute the list of generalized eigenvalues of A and B.\n\nnote: Note\nThe bang method gen_eig_vals! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.initialize_output","page":"Library","title":"MatrixAlgebraKit.initialize_output","text":"initialize_output(f, A, alg)\n\nWhenever possible, allocate the destination for applying a given algorithm in-place. If this is not possible, for example when the output size is not known a priori or immutable, this function may return nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.inv_regularized","page":"Library","title":"MatrixAlgebraKit.inv_regularized","text":"inv_regularized(a::Number, tol = defaulttol(a))\ninv_regularized(A::Matrix, tol = defaulttol(A); isposdef = false, kwargs...)\n\nCompute a smooth regularised inverse (L2 Tikhonov regularisation) of a number or square  matrix a.\n\nFor numbers, this is given by inv(hypot(a, tol)).\nFor matrices, this is computed using the singular value decomposition and aplying   inv_regularized to the singular values. If isposdef = true, the singular value   decomposition is equivalent to the (Hermitian) eigenvalue decomposition of A and   the latter is used instead.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.inv_safe","page":"Library","title":"MatrixAlgebraKit.inv_safe","text":"function inv_safe(a::Number, tol = defaulttol(a))\n\nCompute the inverse of a number a, but return zero if a is smaller than tol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.is_left_isometric","page":"Library","title":"MatrixAlgebraKit.is_left_isometric","text":"is_left_isometric(A; isapprox_kwargs...) -> Bool\n\nTest whether a linear map is a (left) isometry, i.e. A' * A ≈ I. The isapprox_kwargs can be used to control the tolerances of the equality.\n\nSee also isisometric and MatrixAlgebraKit.is_right_isometric.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.is_right_isometric","page":"Library","title":"MatrixAlgebraKit.is_right_isometric","text":"is_right_isometric(A; isapprox_kwargs...) -> Bool\n\nTest whether a linear map is a (right) isometry, i.e. A * A' ≈ I. The isapprox_kwargs can be used to control the tolerances of the equality.\n\nSee also isisometric and MatrixAlgebraKit.is_left_isometric.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.isantihermitian-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.isantihermitian","text":"isantihermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is anti-Hermitian, i.e. A = -A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.ishermitian-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.ishermitian","text":"ishermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is Hermitian, i.e. A = A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.isisometric-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.isisometric","text":"isisometric(A; side=:left, isapprox_kwargs...) -> Bool\n\nTest whether a linear map is an isometry, where the type of isometry is controlled by kind:\n\nside = :left : A' * A ≈ I. \nside = :right : A * A' ≈ I.\n\nThe isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nNew specializations should overload MatrixAlgebraKit.is_left_isometric and MatrixAlgebraKit.is_right_isometric.\n\nSee also isunitary.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.isunitary-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.isunitary","text":"isunitary(A; isapprox_kwargs...)\n\nTest whether a linear map is unitary, i.e. A * A' ≈ I ≈ A' * A. The isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nSee also isisometric.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.iszerotangent","page":"Library","title":"MatrixAlgebraKit.iszerotangent","text":"iszerotangent(x)\n\nReturn true if x is of a type that the different AD engines use to communicate a (co)tangent that is identically zero. By overloading this method, and writing pullback definitions in term of it, we will be able to hook into different AD ecosystems\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_null","page":"Library","title":"MatrixAlgebraKit.left_null","text":"left_null(A; [kind::Symbol, trunc, alg_qr, alg_svd]) -> N\nleft_null!(A, [N]; [kind::Symbol, alg_qr, alg_svd]) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A of size (m, n), i.e. the nullspace of adjoint(A), such that adjoint(A)*N ≈ 0 and N'*N ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxnullity.\n\nThis is a high-level wrapper and will use one of the decompositions qr! or svd! to compute the orthogonal basis N, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qr: N is computed using the QR decomposition.   This requires isnothing(trunc) and left_null!(A, [N], kind=:qr) is equivalent to   qr_null!(A, [N], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to either the zero singular values if trunc   isn't specified or the singular values specified by trunc.\n\nWhen kind is not provided, the default value is :qr when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg_qr and alg_svd keyword arguments, which will only be used by the corresponding factorization backend. If alg_qr or alg_svd are NamedTuples, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_qr defaults to (; positive=true) so that by default a positive QR decomposition will be used.\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_orth","page":"Library","title":"MatrixAlgebraKit.left_orth","text":"left_orth(A; [kind::Symbol, trunc, alg_qr, alg_polar, alg_svd]) -> V, C\nleft_orth!(A, [VC]; [kind::Symbol, trunc, alg_qr, alg_polar, alg_svd]) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A of size (m, n), as well as a  matrix C (the corestriction) such that A factors as A = V * C. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the precision in determining the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxrank.\n\nThis is a high-level wrapper and will use one of the decompositions qr_compact!, svd_compact!/svd_trunc!, andleft_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qr: V and C are computed using the QR decomposition.   This requires isnothing(trunc) and left_orth!(A, [VC]) is equivalent to   qr_compact!(A, [VC], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :polar: V and C are computed using the polar decomposition,   This requires isnothing(trunc) and left_orth!(A, [VC]) is equivalent to   left_polar!(A, [VC], alg) with a default value alg = select_algorithm(left_polar!, A)\nkind == :svd: V and C are computed using the singular value decomposition svd_trunc! when a   truncation strategy is specified using the trunc keyword argument, and using svd_compact! otherwise.   V will contain the left singular vectors and C is computed as the product of the singular   values and the right singular vectors, i.e. with U, S, Vᴴ = svd(A), we have   V = U and C = S * Vᴴ.\n\nWhen kind is not provided, the default value is :qr when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm for backend factorizations through the alg_qr, alg_polar, and alg_svd keyword arguments, which will only be used if the corresponding factorization is called based on the other inputs. If NamedTuples are passed as alg_qr, alg_polar, or alg_svd, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_qr defaults to (; positive=true) so that by default a positive QR decomposition will be used.\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_null(!), right_null(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar","page":"Library","title":"MatrixAlgebraKit.left_polar","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar!","page":"Library","title":"MatrixAlgebraKit.left_polar!","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.left_polar_pullback!","text":"left_polar_pullback!(ΔA, A, WP, ΔWP)\n\nAdds the pullback from the left polar decomposition of A to ΔA given the output WP and cotangent ΔWP of left_polar(A).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.lq_compact","page":"Library","title":"MatrixAlgebraKit.lq_compact","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_compact!","page":"Library","title":"MatrixAlgebraKit.lq_compact!","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_full","page":"Library","title":"MatrixAlgebraKit.lq_full","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_full!","page":"Library","title":"MatrixAlgebraKit.lq_full!","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null","page":"Library","title":"MatrixAlgebraKit.lq_null","text":"lq_null(A; kwargs...) -> Nᴴ\nlq_null(A, alg::AbstractAlgorithm) -> Nᴴ\nlq_null!(A, [Nᴴ]; kwargs...) -> Nᴴ\nlq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -> Nᴴ\n\nFor a (m, n) matrix A, compute the matrix Nᴴ corresponding the final n - min(m, n) rows  oft the unitary Q factor in the full LQ decomposition of A, i.e. the rows that are not present in the Q factor of the compact LQ decomposition. The matrix Nᴴ is such that the isometric matrix N = adjoint(Nᴴ) contains an orthonormal basis for the kernel (null space) of A as its columns, i.e. A * N = 0 or thus A * adjoint(Nᴴ) = 0.\n\nnote: Note\nThe bang method lq_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ argument as output.\n\nnote: Note\nThe matrix Nᴴ is empty when m >= n.\n\nSee also qr_full(!) and qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null!","page":"Library","title":"MatrixAlgebraKit.lq_null!","text":"lq_null(A; kwargs...) -> Nᴴ\nlq_null(A, alg::AbstractAlgorithm) -> Nᴴ\nlq_null!(A, [Nᴴ]; kwargs...) -> Nᴴ\nlq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -> Nᴴ\n\nFor a (m, n) matrix A, compute the matrix Nᴴ corresponding the final n - min(m, n) rows  oft the unitary Q factor in the full LQ decomposition of A, i.e. the rows that are not present in the Q factor of the compact LQ decomposition. The matrix Nᴴ is such that the isometric matrix N = adjoint(Nᴴ) contains an orthonormal basis for the kernel (null space) of A as its columns, i.e. A * N = 0 or thus A * adjoint(Nᴴ) = 0.\n\nnote: Note\nThe bang method lq_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ argument as output.\n\nnote: Note\nThe matrix Nᴴ is empty when m >= n.\n\nSee also qr_full(!) and qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.lq_null_pullback!","text":"lq_null_pullback(ΔA, A, Nᴴ, ΔNᴴ)\n\nAdds the pullback from the left nullspace of A to ΔA, given the nullspace basis  Nᴴ and its cotangent ΔNᴴ of lq_null(A).\n\nSee also lq_pullback!.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.lq_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.lq_pullback!","text":"lq_pullback!(\n    ΔA, A, LQ, ΔLQ;\n    tol::Real = default_pullback_gaugetol(LQ[1]),\n    rank_atol::Real = tol,\n    gauge_atol::Real = tol\n)\n\nAdds the pullback from the LQ decomposition of A to ΔA given the output LQ and cotangent ΔLQ of lq_compact(A; positive = true) or lq_full(A; positive = true).\n\nIn the case where the rank r of the original matrix A ≈ L * Q (as determined by rank_atol) is less then the minimum of the number of rows and columns of the cotangents ΔL and ΔQ, only the first r columns of L and the first r rows of Q are well-defined, and also the adjoint variables ΔL and ΔQ should have nonzero values only in the first r columns and rows respectively. If nonzero values in the remaining columns or rows exceed gauge_atol, a warning will be printed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.notrunc-Tuple{}","page":"Library","title":"MatrixAlgebraKit.notrunc","text":"notrunc()\n\nTruncation strategy that does nothing, and keeps all the values.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.project_antihermitian","page":"Library","title":"MatrixAlgebraKit.project_antihermitian","text":"project_antihermitian(A; kwargs...)\nproject_antihermitian(A, alg)\nproject_antihermitian!(A, [Aₐ]; kwargs...)\nproject_antihermitian!(A, [Aₐ], alg)\n\nCompute the anti-hermitian part of a (square) matrix A, defined as (A - A') / 2. For real matrices this corresponds to the antisymmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₐ; by default it is equal toAand so the input matrixA` is replaced by its antihermitian projection.\n\nSee also project_hermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_antihermitian!","page":"Library","title":"MatrixAlgebraKit.project_antihermitian!","text":"project_antihermitian(A; kwargs...)\nproject_antihermitian(A, alg)\nproject_antihermitian!(A, [Aₐ]; kwargs...)\nproject_antihermitian!(A, [Aₐ], alg)\n\nCompute the anti-hermitian part of a (square) matrix A, defined as (A - A') / 2. For real matrices this corresponds to the antisymmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₐ; by default it is equal toAand so the input matrixA` is replaced by its antihermitian projection.\n\nSee also project_hermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_hermitian","page":"Library","title":"MatrixAlgebraKit.project_hermitian","text":"project_hermitian(A; kwargs...)\nproject_hermitian(A, alg)\nproject_hermitian!(A, [Aₕ]; kwargs...)\nproject_hermitian!(A, [Aₕ], alg)\n\nCompute the hermitian part of a (square) matrix A, defined as (A + A') / 2. For real matrices this corresponds to the symmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₕ; by default it is equal to A and so the input matrix A is replaced by its hermitian projection.\n\nSee also project_antihermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_hermitian!","page":"Library","title":"MatrixAlgebraKit.project_hermitian!","text":"project_hermitian(A; kwargs...)\nproject_hermitian(A, alg)\nproject_hermitian!(A, [Aₕ]; kwargs...)\nproject_hermitian!(A, [Aₕ], alg)\n\nCompute the hermitian part of a (square) matrix A, defined as (A + A') / 2. For real matrices this corresponds to the symmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₕ; by default it is equal to A and so the input matrix A is replaced by its hermitian projection.\n\nSee also project_antihermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_isometric","page":"Library","title":"MatrixAlgebraKit.project_isometric","text":"project_isometric(A; kwargs...)\nproject_isometric(A, alg)\nproject_isometric!(A, [W]; kwargs...)\nproject_isometric!(A, [W], alg)\n\nCompute the projection of A onto the manifold of isometric matrices, i.e. matrices satisfying A' * A ≈ I. This projection is computed via the polar decomposition, i.e. W corresponds to the first return value of left_polar!, but avoids computing the positive definite factor explicitly.\n\nnote: Note\nThe bang method project_isometric! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_isometric!","page":"Library","title":"MatrixAlgebraKit.project_isometric!","text":"project_isometric(A; kwargs...)\nproject_isometric(A, alg)\nproject_isometric!(A, [W]; kwargs...)\nproject_isometric!(A, [W], alg)\n\nCompute the projection of A onto the manifold of isometric matrices, i.e. matrices satisfying A' * A ≈ I. This projection is computed via the polar decomposition, i.e. W corresponds to the first return value of left_polar!, but avoids computing the positive definite factor explicitly.\n\nnote: Note\nThe bang method project_isometric! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact","page":"Library","title":"MatrixAlgebraKit.qr_compact","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact!","page":"Library","title":"MatrixAlgebraKit.qr_compact!","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_full","page":"Library","title":"MatrixAlgebraKit.qr_full","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_full!","page":"Library","title":"MatrixAlgebraKit.qr_full!","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null","page":"Library","title":"MatrixAlgebraKit.qr_null","text":"qr_null(A; kwargs...) -> N\nqr_null(A, alg::AbstractAlgorithm) -> N\nqr_null!(A, [N]; kwargs...) -> N\nqr_null!(A, [N], alg::AbstractAlgorithm) -> N\n\nFor a (m, n) matrix A, compute the matrix N corresponding the final m - min(m, n) columns  of the unitary Q factor in the full QR decomposition of A, i.e. the columns that are not present in the Q factor of the compact QR decomposition. The isometric matrix N contains an orthonormal basis for the cokernel of A as its columns, i.e. adjoint(A) * N = 0.\n\nnote: Note\nThe bang method qr_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N argument as output.\n\nnote: Note\nThe matrix N is empty when m <= n.\n\nSee also lq_full(!) and lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null!","page":"Library","title":"MatrixAlgebraKit.qr_null!","text":"qr_null(A; kwargs...) -> N\nqr_null(A, alg::AbstractAlgorithm) -> N\nqr_null!(A, [N]; kwargs...) -> N\nqr_null!(A, [N], alg::AbstractAlgorithm) -> N\n\nFor a (m, n) matrix A, compute the matrix N corresponding the final m - min(m, n) columns  of the unitary Q factor in the full QR decomposition of A, i.e. the columns that are not present in the Q factor of the compact QR decomposition. The isometric matrix N contains an orthonormal basis for the cokernel of A as its columns, i.e. adjoint(A) * N = 0.\n\nnote: Note\nThe bang method qr_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N argument as output.\n\nnote: Note\nThe matrix N is empty when m <= n.\n\nSee also lq_full(!) and lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.qr_null_pullback!","text":"qr_null_pullback(ΔA, A, N, ΔN)\n\nAdds the pullback from the right nullspace of A to ΔA, given the nullspace basis N and its cotangent ΔN of qr_null(A).\n\nSee also qr_pullback!.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.qr_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.qr_pullback!","text":"qr_pullback!(\n    ΔA, A, QR, ΔQR;\n    tol::Real = default_pullback_gaugetol(QR[2]),\n    rank_atol::Real = tol,\n    gauge_atol::Real = tol\n)\n\nAdds the pullback from the QR decomposition of A to ΔA given the output QR and cotangent ΔQR of qr_compact(A; positive = true) or qr_full(A; positive = true).\n\nIn the case where the rank r of the original matrix A ≈ Q * R (as determined by rank_atol) is less then the minimum of the number of rows and columns, the cotangents ΔQ and ΔR, only the first r columns of Q and the first r rows of R are well-defined, and also the adjoint variables ΔQ and ΔR should have nonzero values only in the first r columns and rows respectively. If nonzero values in the remaining columns or rows exceed gauge_atol, a warning will be printed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.right_null","page":"Library","title":"MatrixAlgebraKit.right_null","text":"right_null(A; [kind::Symbol, alg_lq, alg_svd]) -> Nᴴ\nright_null!(A, [Nᴴ]; [kind::Symbol, alg_lq, alg_svd]) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel or nullspace of the matrix A of size (m, n), such that A*adjoint(Nᴴ) ≈ 0 and Nᴴ*adjoint(Nᴴ) ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxnullity.\n\nThis is a high-level wrapper and will use one of the decompositions lq! or svd! to compute the orthogonal basis Nᴴ, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lq: Nᴴ is computed using the (nonpositive) LQ decomposition.   This requires isnothing(trunc) and right_null!(A, [Nᴴ], kind=:lq) is equivalent to   lq_null!(A, [Nᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.\n\nWhen kind is not provided, the default value is :lq when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg_lq and alg_svd keyword arguments, which will only be used by the corresponding factorization backend. If alg_lq or alg_svd are NamedTuples, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_lq defaults to (; positive=true) so that by default a positive LQ decomposition will be used.\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_orth","page":"Library","title":"MatrixAlgebraKit.right_orth","text":"right_orth(A; [kind::Symbol, trunc, alg_lq, alg_polar, alg_svd]) -> C, Vᴴ\nright_orth!(A, [CVᴴ]; [kind::Symbol, trunc, alg_lq, alg_polar, alg_svd]) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A = C * Vᴴ. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the precision in determining the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxrank.\n\nThis is a high-level wrapper and will use one of the decompositions lq_compact!, svd_compact!/svd_trunc!, and right_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lq: C and Vᴴ are computed using the QR decomposition,   This requires isnothing(trunc) and right_orth!(A, [CVᴴ]) is equivalent to   lq_compact!(A, [CVᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :polar: C and Vᴴ are computed using the polar decomposition,   This requires isnothing(trunc) and right_orth!(A, [CVᴴ]) is equivalent to   right_polar!(A, [CVᴴ], alg) with a default value alg = select_algorithm(right_polar!, A)\nkind == :svd: C and Vᴴ are computed using the singular value decomposition svd_trunc! when   a truncation strategy is specified using the trunc keyword argument, and using svd_compact! otherwise.   V = adjoint(Vᴴ) will contain the right singular vectors corresponding to the singular   values and C is computed as the product of the singular values and the right singular vectors,   i.e. with U, S, Vᴴ = svd(A), we have C = rmul!(U, S) and Vᴴ = Vᴴ.\n\nWhen kind is not provided, the default value is :lq when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm for backend factorizations through the alg_lq, alg_polar, and alg_svd keyword arguments, which will only be used if the corresponding factorization is called based on the other inputs. If alg_lq, alg_polar, or alg_svd are NamedTuples, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_lq defaults to (; positive=true) so that by default a positive LQ decomposition will be used.\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_null(!), right_null(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar","page":"Library","title":"MatrixAlgebraKit.right_polar","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar!","page":"Library","title":"MatrixAlgebraKit.right_polar!","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.right_polar_pullback!","text":"right_polar_pullback!(ΔA, A, PWᴴ, ΔPWᴴ)\n\nAdds the pullback from the left polar decomposition of A to ΔA given the output PWᴴ and cotangent ΔPWᴴ of right_polar(A).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.schur_full","page":"Library","title":"MatrixAlgebraKit.schur_full","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_full!","page":"Library","title":"MatrixAlgebraKit.schur_full!","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_vals","page":"Library","title":"MatrixAlgebraKit.schur_vals","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_vals!","page":"Library","title":"MatrixAlgebraKit.schur_vals!","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.select_algorithm","page":"Library","title":"MatrixAlgebraKit.select_algorithm","text":"MatrixAlgebraKit.select_algorithm(f, A, alg::AbstractAlgorithm)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Symbol; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Type; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, (; kwargs...))\n\nDecide on an algorithm to use for implementing the function f on inputs of type A. This can be obtained both for values A or types A.\n\nIf alg is an AbstractAlgorithm instance, it will be returned as-is.\n\nIf alg is a Symbol or a Type of algorithm, the return value is obtained by calling the corresponding algorithm constructor; keyword arguments in kwargs are passed along  to this constructor.\n\nIf alg is not specified (or nothing), an algorithm will be selected  automatically with MatrixAlgebraKit.default_algorithm and  the keyword arguments in kwargs will be passed to the algorithm constructor. Finally, the same behavior is obtained when the keyword arguments are passed as the third positional argument in the form of a NamedTuple. \n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.select_truncation","page":"Library","title":"MatrixAlgebraKit.select_truncation","text":"MatrixAlgebraKit.select_truncation(trunc)\n\nConstruct a TruncationStrategy from the given NamedTuple of keywords or input strategy.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.sign_safe-Tuple{Real}","page":"Library","title":"MatrixAlgebraKit.sign_safe","text":"sign_safe(s::Number)\n\nCompute the sign of a number s, but return +1 if s is zero so that the result is always a number with modulus 1, i.e. an element of the unitary group U(1).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.svd_compact","page":"Library","title":"MatrixAlgebraKit.svd_compact","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_compact!","page":"Library","title":"MatrixAlgebraKit.svd_compact!","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_full","page":"Library","title":"MatrixAlgebraKit.svd_full","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_full!","page":"Library","title":"MatrixAlgebraKit.svd_full!","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_pullback!","page":"Library","title":"MatrixAlgebraKit.svd_pullback!","text":"svd_pullback!(\n    ΔA, A, USVᴴ, ΔUSVᴴ, [ind];\n    tol::Real=default_pullback_gaugetol(USVᴴ[2]),\n    rank_atol::Real = tol,\n    degeneracy_atol::Real = tol,\n    gauge_atol::Real = tol\n)\n\nAdds the pullback from the SVD of A to ΔA given the output USVᴴ of svd_compact or svd_full and the cotangent ΔUSVᴴ of svd_compact, svd_full or svd_trunc.\n\nIn particular, it is assumed that A ≈ U * S * Vᴴ, or thus, that no singular values with magnitude less than rank_atol are missing from S.  For the cotangents, an arbitrary number of singular vectors or singular values can be missing, i.e. for a matrix A with size (m, n), ΔU and ΔVᴴ can have sizes (m, pU) and (pV, n) respectively, whereas diagview(ΔS) can have length pS. In those cases, additionally ind is required to specify which singular vectors and values are present in ΔU, ΔS and ΔVᴴ.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of U' * ΔU + Vᴴ * ΔVᴴ', restricted to rows i and columns j for which abs(S[i] - S[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc","page":"Library","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(A; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' ≈ U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded singular values.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all singular values.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!), svd_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc!","page":"Library","title":"MatrixAlgebraKit.svd_trunc!","text":"svd_trunc(A; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' ≈ U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded singular values.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all singular values.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!), svd_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.svd_trunc_pullback!","text":"svd_trunc_pullback!(\n    ΔA, A, USVᴴ, ΔUSVᴴ;\n    tol::Real=default_pullback_gaugetol(S),\n    rank_atol::Real = tol,\n    degeneracy_atol::Real = tol,\n    gauge_atol::Real = tol\n)\n\nAdds the pullback from the truncated SVD of A to ΔA, given the output USVᴴ and the cotangent ΔUSVᴴ of svd_trunc.\n\nIn particular, it is assumed that A * Vᴴ' ≈ U * S and U' * A = S * Vᴴ, with U and Vᴴ rectangular matrices of left and right singular vectors, and S diagonal. For the cotangents, it is assumed that if ΔU and ΔVᴴ are not zero, then they have the same size as U and Vᴴ (respectively), and if ΔS is not zero, then it is a diagonal matrix of the same size as S. For this method to work correctly, it is also assumed that the remaining singular values (not included in S) are (sufficiently) separated from those in S.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of U' * ΔU + Vᴴ * ΔVᴴ', restricted to rows i and columns j for which abs(S[i] - S[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.svd_vals","page":"Library","title":"MatrixAlgebraKit.svd_vals","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_vals!","page":"Library","title":"MatrixAlgebraKit.svd_vals!","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncate","page":"Library","title":"MatrixAlgebraKit.truncate","text":"truncate(::typeof(f), F, strategy::TruncationStrategy) -> F′, ind\n\nGiven a factorization function f and truncation strategy, truncate the factors F such that the rows or columns at the indices ind are kept.\n\nSee also findtruncated and findtruncated_svd for determining the indices.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncation_error","page":"Library","title":"MatrixAlgebraKit.truncation_error","text":"truncation_error(values, ind)\n\nCompute the truncation error as the 2-norm of the values that are not kept by ind.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncation_error!","page":"Library","title":"MatrixAlgebraKit.truncation_error!","text":"truncation_error(values, ind)\n\nCompute the truncation error as the 2-norm of the values that are not kept by ind.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncerror-Tuple{}","page":"Library","title":"MatrixAlgebraKit.truncerror","text":"truncerror(; atol::Real=0, rtol::Real=0, p::Real=2)\n\nTruncation strategy for truncating values such that the error in the factorization is smaller than max(atol, rtol * norm), where the error is determined using the p-norm.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.truncfilter-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.truncfilter","text":"truncfilter(filter)\n\nTruncation strategy to keep the values for which filter returns true.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.truncrank-Tuple{Integer}","page":"Library","title":"MatrixAlgebraKit.truncrank","text":"truncrank(howmany::Integer; by=abs, rev::Bool=true)\n\nTruncation strategy to keep the first howmany values when sorted according to by or the last howmany if rev is true.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.trunctol-Tuple{}","page":"Library","title":"MatrixAlgebraKit.trunctol","text":"trunctol(; atol::Real=0, rtol::Real=0, p::Real=2, by=abs, keep_below::Bool=false)\n\nTruncation strategy to keep the values that satisfy by(val) > max(atol, rtol * norm(values, p). If keep_below = true, discard these values instead.\n\n\n\n\n\n","category":"method"},{"location":"library/#Other","page":"Library","title":"Other","text":"","category":"section"},{"location":"library/#MatrixAlgebraKit.@algdef-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.@algdef","text":"@algdef AlgorithmName\n\nConvenience macro to define an algorithm AlgorithmName that accepts generic keywords. This defines an exported alias for Algorithm{:AlgorithmName} along with some utility methods.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@check_scalar","page":"Library","title":"MatrixAlgebraKit.@check_scalar","text":"@check_scalar(x, y, [op], [eltype])\n\nCheck if eltype(x) == op(eltype(y)) and throw an error if not. By default op = identity and `eltype = eltype'.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@check_size","page":"Library","title":"MatrixAlgebraKit.@check_size","text":"@check_size(x, sz, [size])\n\nCheck if size(x) == sz and throw an error if not. By default, size = size.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@functiondef-Tuple","page":"Library","title":"MatrixAlgebraKit.@functiondef","text":"@functiondef [n_args=1] f\n\nConvenience macro to define the boilerplate code that dispatches between several versions of f and f!. By default, f accepts a single argument A.  This enables the following signatures to be defined in terms of the final f!(A, out, alg::Algorithm).\n\n    f(A; kwargs...)\n    f(A, alg::Algorithm)\n    f!(A, [out]; kwargs...)\n    f!(A, alg::Algorithm)\n\nThe number of inputs can be set with the n_args keyword argument, so that \n\n@functiondef n_args=2 f\n\nwould create \n\n    f(A, B; kwargs...)\n    f(A, B, alg::Algorithm)\n    f!(A, B, [out]; kwargs...)\n    f!(A, B, alg::Algorithm)\n\nSee also copy_input, select_algorithm and initialize_output.\n\n\n\n\n\n","category":"macro"},{"location":"dev_interface/#Developer-Interface","page":"Developer Interface","title":"Developer Interface","text":"","category":"section"},{"location":"dev_interface/","page":"Developer Interface","title":"Developer Interface","text":"MatrixAlgebraKit.jl provides a developer interface for specifying custom algorithm backends and selecting default algorithms.","category":"page"},{"location":"dev_interface/#MatrixAlgebraKit.default_algorithm-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.default_algorithm","text":"MatrixAlgebraKit.default_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.default_algorithm(f, ::Type{TA}; kwargs...) where {TA}\n\nSelect the default algorithm for a given factorization function f and input A. In general, this is called by select_algorithm if no algorithm is specified explicitly. New types should prefer to register their default algorithms in the type domain.\n\n\n\n\n\n","category":"function"},{"location":"dev_interface/#MatrixAlgebraKit.select_algorithm-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.select_algorithm","text":"MatrixAlgebraKit.select_algorithm(f, A, alg::AbstractAlgorithm)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Symbol; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Type; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, (; kwargs...))\n\nDecide on an algorithm to use for implementing the function f on inputs of type A. This can be obtained both for values A or types A.\n\nIf alg is an AbstractAlgorithm instance, it will be returned as-is.\n\nIf alg is a Symbol or a Type of algorithm, the return value is obtained by calling the corresponding algorithm constructor; keyword arguments in kwargs are passed along  to this constructor.\n\nIf alg is not specified (or nothing), an algorithm will be selected  automatically with MatrixAlgebraKit.default_algorithm and  the keyword arguments in kwargs will be passed to the algorithm constructor. Finally, the same behavior is obtained when the keyword arguments are passed as the third positional argument in the form of a NamedTuple. \n\n\n\n\n\n","category":"function"},{"location":"dev_interface/#MatrixAlgebraKit.findtruncated-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.findtruncated","text":"MatrixAlgebraKit.findtruncated(values::AbstractVector, strategy::TruncationStrategy)\n\nGeneric interface for finding truncated values of the spectrum of a decomposition based on the strategy. The output should be a collection of indices specifying which values to keep. MatrixAlgebraKit.findtruncated is used inside of the default implementation of truncate to perform the truncation. It does not assume that the values are sorted. For a version that assumes the values are reverse sorted (which is the standard case for SVD) see MatrixAlgebraKit.findtruncated_svd.\n\n\n\n\n\n","category":"function"},{"location":"dev_interface/#MatrixAlgebraKit.findtruncated_svd-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.findtruncated_svd","text":"MatrixAlgebraKit.findtruncated_svd(values::AbstractVector, strategy::TruncationStrategy)\n\nLike MatrixAlgebraKit.findtruncated but assumes that the values are real and sorted in descending order, as typically obtained by the SVD. This assumption is not checked, and this is used in the default implementation of svd_trunc!.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/compositions/#Compositions","page":"Compositions","title":"Compositions","text":"","category":"section"},{"location":"user_interface/compositions/","page":"Compositions","title":"Compositions","text":"Coming soon...","category":"page"},{"location":"user_interface/truncations/#Truncations","page":"Truncations","title":"Truncations","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Truncation strategies allow you to control which eigenvalues or singular values to keep when computing partial or truncated decompositions. These strategies are used in the functions eigh_trunc, eig_trunc, and svd_trunc to reduce the size of the decomposition while retaining the most important information.","category":"page"},{"location":"user_interface/truncations/#Using-Truncations-in-Decompositions","page":"Truncations","title":"Using Truncations in Decompositions","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Truncation strategies can be used with truncated decomposition functions in two ways, as illustrated below. For concreteness, we use the following matrix as an example:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"using MatrixAlgebraKit\nusing MatrixAlgebraKit: diagview\n\nA = [2 1 0; 1 3 1; 0 1 4];\nD, V = eigh_full(A);\ndiagview(D) ≈ [3 - √3, 3, 3 + √3]","category":"page"},{"location":"user_interface/truncations/#1.-Using-the-trunc-keyword-with-a-NamedTuple","page":"Truncations","title":"1. Using the trunc keyword with a NamedTuple","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"The simplest approach is to pass a NamedTuple with the truncation parameters. For example, keeping only the largest 2 eigenvalues:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Dtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = (maxrank = 2,));\nsize(Dtrunc, 1) <= 2","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Note however that there are no guarantees on the order of the output values:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"diagview(Dtrunc) ≈ diagview(D)[[3, 2]]","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"You can also use tolerance-based truncation or combine multiple criteria:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Dtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = (atol = 2.9,));\nall(>(2.9), diagview(Dtrunc))","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Dtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = (maxrank = 2, atol = 2.9));\nsize(Dtrunc, 1) <= 2 && all(>(2.9), diagview(Dtrunc))","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"In general, the keyword arguments that are supported can be found in the TruncationStrategy docstring:","category":"page"},{"location":"user_interface/truncations/#MatrixAlgebraKit.TruncationStrategy-Tuple{}-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.TruncationStrategy","text":"TruncationStrategy(; kwargs...)\n\nSelect a truncation strategy based on the provided keyword arguments.\n\nKeyword arguments\n\nThe following keyword arguments are all optional, and their default value (nothing) will be ignored. It is also allowed to combine multiple of these, in which case the kept values will consist of the intersection of the different truncated strategies.\n\natol::Real : Absolute tolerance for the truncation\nrtol::Real : Relative tolerance for the truncation\nmaxrank::Real : Maximal rank for the truncation\nmaxerror::Real : Maximal truncation error.\nfilter : Custom filter to select truncated values.\n\n\n\n\n\n","category":"method"},{"location":"user_interface/truncations/#2.-Using-explicit-TruncationStrategy-objects","page":"Truncations","title":"2. Using explicit TruncationStrategy objects","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"For more control, you can construct TruncationStrategy objects directly. This is also what the previous syntax will end up calling.","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Dtrunc, Vtrunc = eigh_trunc(A; trunc = truncrank(2))\nsize(Dtrunc, 1) <= 2","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Dtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = truncrank(2) & trunctol(; atol = 2.9))\nsize(Dtrunc, 1) <= 2 && all(>(2.9), diagview(Dtrunc))","category":"page"},{"location":"user_interface/truncations/#Truncation-Strategies","page":"Truncations","title":"Truncation Strategies","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"MatrixAlgebraKit provides several built-in truncation strategies:","category":"page"},{"location":"user_interface/truncations/#MatrixAlgebraKit.notrunc-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.notrunc","text":"notrunc()\n\nTruncation strategy that does nothing, and keeps all the values.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncrank-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncrank","text":"truncrank(howmany::Integer; by=abs, rev::Bool=true)\n\nTruncation strategy to keep the first howmany values when sorted according to by or the last howmany if rev is true.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.trunctol-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.trunctol","text":"trunctol(; atol::Real=0, rtol::Real=0, p::Real=2, by=abs, keep_below::Bool=false)\n\nTruncation strategy to keep the values that satisfy by(val) > max(atol, rtol * norm(values, p). If keep_below = true, discard these values instead.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncfilter-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncfilter","text":"truncfilter(filter)\n\nTruncation strategy to keep the values for which filter returns true.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncerror-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncerror","text":"truncerror(; atol::Real=0, rtol::Real=0, p::Real=2)\n\nTruncation strategy for truncating values such that the error in the factorization is smaller than max(atol, rtol * norm), where the error is determined using the p-norm.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Truncation strategies can be combined using the & operator to create intersection-based truncation. When strategies are combined, only the values that satisfy all conditions are kept.","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"combined_trunc = truncrank(10) & trunctol(; atol = 1e-6);","category":"page"},{"location":"user_interface/truncations/#Truncation-Error","page":"Truncations","title":"Truncation Error","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"When using truncated decompositions such as svd_trunc, eig_trunc, or eigh_trunc, an additional truncation error value is returned. This error is defined as the 2-norm of the discarded  singular values or eigenvalues, providing a measure of the approximation quality. For svd_trunc and eigh_trunc, this corresponds to the 2-norm difference between the original and the truncated matrix. For the case of eig_trunc, this interpretation does not hold because the norm of the non-unitary matrix of eigenvectors and its inverse also influence the approximation quality.","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"For example:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"using LinearAlgebra: norm\nU, S, Vᴴ, ϵ = svd_trunc(A; trunc=truncrank(2))\nnorm(A - U * S * Vᴴ) ≈ ϵ # ϵ is the 2-norm of the discarded singular values","category":"page"},{"location":"user_interface/truncations/#Truncation-with-SVD-vs-Eigenvalue-Decompositions","page":"Truncations","title":"Truncation with SVD vs Eigenvalue Decompositions","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"When using truncations with different decomposition types, keep in mind:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"svd_trunc: Singular values are always real and non-negative, sorted in descending order. Truncation by value typically keeps the largest singular values. The truncation error gives the 2-norm difference between the original and the truncated matrix.\neigh_trunc: Eigenvalues are real but can be negative for symmetric matrices. By default, eigenvalues are treated by absolute value, e.g. truncrank(k) keeps the k eigenvalues with largest magnitude (positive or negative). The truncation error gives the 2-norm difference between the original and the truncated matrix.\neig_trunc: For general (non-symmetric) matrices, eigenvalues can be complex. By default, eigenvalues are treated by absolute value. The truncation error gives an indication of the magnitude of discarded values, but is not directly related to the 2-norm difference between the original and the truncated matrix.","category":"page"},{"location":"user_interface/decompositions/#Decompositions","page":"Decompositions","title":"Decompositions","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"A rather large class of matrix algebra methods consists of taking a single input A, and determining some factorization of that input. In order to streamline these functions, they all follow a similar common code pattern. For a given factorization f, this consists of the following methods:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"f(A; kwargs...) -> F...\nf!(A, [F]; kwargs...) -> F...","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Here, the input matrix is always the first argument, and optionally the output can be provided as well. The keywords are algorithm-specific, and can be used to influence the behavior of the algorithms. Importantly, for generic code patterns it is recommended to always use the output F explicitly, since some implementations may not be able to reuse the provided memory. Additionally, the f! method typically assumes that it is allowed to destroy the input A, and making use of the contents of A afterwards should be deemed as undefined behavior.","category":"page"},{"location":"user_interface/decompositions/#QR-and-LQ-Decompositions","page":"Decompositions","title":"QR and LQ Decompositions","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The QR decomposition transforms a matrix A into a product Q * R, where Q is orthonormal and R upper triangular. This is often used to solve linear least squares problems, or construct orthogonal bases, since it is typically less expensive than the Singular Value Decomposition. If the input A is invertible, Q and R are unique if we require the diagonal elements of R to be positive.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For rectangular matrices A of size (m, n), there are two modes of operation, qr_full and qr_compact. The former ensures that the resulting Q is a square unitary matrix of size (m, m), while the latter creates an isometric Q of size (m, min(m, n)).","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Similarly, the LQ decomposition transforms a matrix A into a product L * Q, where L is lower triangular and Q orthonormal. This is equivalent to the transpose of the QR decomposition of the transpose matrix, but can be computed directly. Again there are two modes of operation, lq_full and lq_compact, with the same behavior as the QR decomposition.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.qr_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.qr_full","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.qr_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.qr_compact","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.lq_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.lq_full","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.lq_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.lq_compact","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithm:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_HouseholderQR","text":"LAPACK_HouseholderQR(; blocksize, positive = false, pivoted = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  ?geqrt will be chosen if blocksize > 1. With blocksize == 1, ?geqrf will be chosen if pivoted == false and ?geqp3 will be chosen if pivoted == true. The keyword positive=true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_HouseholderLQ","text":"LAPACK_HouseholderLQ(; blocksize, positive = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. ?gelqt will be chosen if blocksize > 1 or ?gelqf will be chosen if blocksize == 1. The keyword positive=true can be used to ensure that the diagonal elements of L are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Eigenvalue-Decomposition","page":"Decompositions","title":"Eigenvalue Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Eigenvalue Decomposition transforms a square matrix A into a product V * D * V⁻¹. Equivalently, it finds V and D that satisfy A * V = V * D.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Not all matrices can be diagonalized, and some real matrices can only be diagonalized using complex arithmetic. In particular, the resulting decomposition can only guaranteed to be real for real symmetric inputs A. Therefore, we provide eig_ and eigh_ variants, where eig always results in complex-valued V and D, while eigh requires symmetric inputs but retains the scalartype of the input.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The full set of eigenvalues and eigenvectors can be computed using the eig_full and eigh_full functions. If only the eigenvalues are required, the eig_vals and eigh_vals functions can be used. These functions return the diagonal elements of D in a vector.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Finally, it is also possible to compute a partial or truncated eigenvalue decomposition, using the eig_trunc and eigh_trunc functions. To control the behavior of the truncation, we refer to Truncations for more information.","category":"page"},{"location":"user_interface/decompositions/#Symmetric-Eigenvalue-Decomposition","page":"Decompositions","title":"Symmetric Eigenvalue Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For symmetric matrices, we provide the following functions:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_full","text":"eigh_full(A; kwargs...) -> D, V, ϵ\neigh_full(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_full!(A, [DV]; kwargs...) -> D, V, ϵ\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the discarded eigenvalues.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all eigenvalues.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!), eigh_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_vals","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","text":"LAPACK_MultipleRelativelyRobustRepresentations()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Eigenvalue-Decomposition-2","page":"Decompositions","title":"Eigenvalue Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For general matrices, we provide the following functions:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_full","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_trunc","text":"eig_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neig_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neig_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all eigenvalues.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!), eig_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_vals","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert()\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple()\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Schur-Decomposition","page":"Decompositions","title":"Schur Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Schur decomposition transforms a complex square matrix A into a product Q * T * Qᴴ, where Q is unitary and T is upper triangular. It rewrites an arbitrary complex square matrix as unitarily similar to an upper triangular matrix whose diagonal elements are the eigenvalues of A. For real matrices, the same decomposition can be achieved in real arithmetic by allowing T to be quasi-upper triangular, i.e. triangular with blocks of size (1, 1) and (2, 2) on the diagonal.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"This decomposition is also useful for computing the eigenvalues of a matrix, which is exposed through the schur_vals function.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.schur_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.schur_full","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.schur_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.schur_vals","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The LAPACK-based implementation for dense arrays is provided by the following algorithms:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert()\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple()\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Singular-Value-Decomposition","page":"Decompositions","title":"Singular Value Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Singular Value Decomposition transforms a matrix A into a product U * Σ * Vᴴ, where U and Vᴴ are unitary, and Σ is diagonal, real and non-negative. For a square matrix A, both U and Vᴴ are unitary, and if the singular values are distinct, the decomposition is unique.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For rectangular matrices A of size (m, n), there are two modes of operation, svd_full and svd_compact. The former ensures that the resulting U, and Vᴴ remain square unitary matrices, of size (m, m) and (n, n), with rectangular Σ of size (m, n). The latter creates an isometric U of size (m, min(m, n)), and V = (Vᴴ)' of size (n, min(m, n)), with a square Σ of size (min(m, n), min(m, n)).","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"It is also possible to compute the singular values only, using the svd_vals function. This then returns a vector of the values on the diagonal of Σ.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Finally, we also support computing a partial or truncated SVD, using the svd_trunc function.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_full","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_compact","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_vals","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(A; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' ≈ U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded singular values.\n\nKeyword arguments\n\nThe behavior of this function is controlled by the following keyword arguments:\n\ntrunc: Specifies the truncation strategy. This can be:\nA NamedTuple with fields atol, rtol, and/or maxrank, which will be converted to a TruncationStrategy. For details on available truncation strategies, see Truncations.\nA TruncationStrategy object directly (e.g., truncrank(10), trunctol(atol=1e-6), or combinations using &).\nnothing (default), which keeps all singular values.\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!), svd_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"MatrixAlgebraKit again ships with LAPACK-based implementations for dense arrays:","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Jacobi","text":"LAPACK_Jacobi()\n\nAlgorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Polar-Decomposition","page":"Decompositions","title":"Polar Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Polar Decomposition of a matrix A is a factorization A = W * P, where W is unitary and P is positive semi-definite. If A is invertible (and therefore square), the polar decomposition always exists and is unique. For non-square matrices A of size (m, n), the decomposition A = W * P with P positive semi-definite of size (n, n) and W isometric of size (m, n) exists only if m >= n, and is unique if A and thus P is full rank. For m <= n, we can analoguously decompose A as A = P * Wᴴ with P positive semi-definite of size (m, m) and Wᴴ of size (m, n) such that W = (Wᴴ)' is isometric. Only in the case m = n do both decompositions exist.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The decompositions A = W * P or A = P * Wᴴ can be computed with the left_polar and right_polar functions, respectively.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_polar-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_polar","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_polar-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_polar","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"These functions can be implemented by first computing a singular value decomposition, and then constructing the polar decomposition from the singular values and vectors. Alternatively, the polar decomposition can be computed using an  iterative method based on Newton's method, that can be more efficient for large matrices, especially if they are close to being isometric already.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.PolarViaSVD","text":"PolarViaSVD(svd_alg)\n\nAlgorithm for computing the polar decomposition of a matrix A via the singular value decomposition (SVD) of A. The svd_alg argument specifies the SVD algorithm to use.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.PolarNewton-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.PolarNewton","text":"PolarNewton(; maxiter = 10, tol = defaulttol(A))\n\nAlgorithm for computing the polar decomposition of a matrix A via scaled Newton iteration, with a maximum of maxiter iterations and until convergence up to tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Orthogonal-Subspaces","page":"Decompositions","title":"Orthogonal Subspaces","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Often it is useful to compute orthogonal bases for a particular subspace defined by a matrix. Given a matrix A we can compute an orthonormal basis for its image or coimage, and factorize the matrix accordingly. These bases are accessible through left_orth and right_orth respectively. This is implemented through a combination of the decompositions mentioned above, and serves as a convenient interface to these operations.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_orth-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_orth","text":"left_orth(A; [kind::Symbol, trunc, alg_qr, alg_polar, alg_svd]) -> V, C\nleft_orth!(A, [VC]; [kind::Symbol, trunc, alg_qr, alg_polar, alg_svd]) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A of size (m, n), as well as a  matrix C (the corestriction) such that A factors as A = V * C. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the precision in determining the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxrank.\n\nThis is a high-level wrapper and will use one of the decompositions qr_compact!, svd_compact!/svd_trunc!, andleft_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qr: V and C are computed using the QR decomposition.   This requires isnothing(trunc) and left_orth!(A, [VC]) is equivalent to   qr_compact!(A, [VC], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :polar: V and C are computed using the polar decomposition,   This requires isnothing(trunc) and left_orth!(A, [VC]) is equivalent to   left_polar!(A, [VC], alg) with a default value alg = select_algorithm(left_polar!, A)\nkind == :svd: V and C are computed using the singular value decomposition svd_trunc! when a   truncation strategy is specified using the trunc keyword argument, and using svd_compact! otherwise.   V will contain the left singular vectors and C is computed as the product of the singular   values and the right singular vectors, i.e. with U, S, Vᴴ = svd(A), we have   V = U and C = S * Vᴴ.\n\nWhen kind is not provided, the default value is :qr when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm for backend factorizations through the alg_qr, alg_polar, and alg_svd keyword arguments, which will only be used if the corresponding factorization is called based on the other inputs. If NamedTuples are passed as alg_qr, alg_polar, or alg_svd, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_qr defaults to (; positive=true) so that by default a positive QR decomposition will be used.\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_null(!), right_null(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_orth-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_orth","text":"right_orth(A; [kind::Symbol, trunc, alg_lq, alg_polar, alg_svd]) -> C, Vᴴ\nright_orth!(A, [CVᴴ]; [kind::Symbol, trunc, alg_lq, alg_polar, alg_svd]) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A = C * Vᴴ. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the precision in determining the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxrank.\n\nThis is a high-level wrapper and will use one of the decompositions lq_compact!, svd_compact!/svd_trunc!, and right_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lq: C and Vᴴ are computed using the QR decomposition,   This requires isnothing(trunc) and right_orth!(A, [CVᴴ]) is equivalent to   lq_compact!(A, [CVᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :polar: C and Vᴴ are computed using the polar decomposition,   This requires isnothing(trunc) and right_orth!(A, [CVᴴ]) is equivalent to   right_polar!(A, [CVᴴ], alg) with a default value alg = select_algorithm(right_polar!, A)\nkind == :svd: C and Vᴴ are computed using the singular value decomposition svd_trunc! when   a truncation strategy is specified using the trunc keyword argument, and using svd_compact! otherwise.   V = adjoint(Vᴴ) will contain the right singular vectors corresponding to the singular   values and C is computed as the product of the singular values and the right singular vectors,   i.e. with U, S, Vᴴ = svd(A), we have C = rmul!(U, S) and Vᴴ = Vᴴ.\n\nWhen kind is not provided, the default value is :lq when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm for backend factorizations through the alg_lq, alg_polar, and alg_svd keyword arguments, which will only be used if the corresponding factorization is called based on the other inputs. If alg_lq, alg_polar, or alg_svd are NamedTuples, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_lq defaults to (; positive=true) so that by default a positive LQ decomposition will be used.\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_null(!), right_null(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#Null-Spaces","page":"Decompositions","title":"Null Spaces","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Similarly, it can be convenient to obtain an orthogonal basis for the kernel or cokernel of a matrix. These are the compliments of the coimage and image, respectively, and can be computed using the left_null and right_null functions. Again, this is typically implemented through a combination of the decompositions mentioned above, and serves as a convenient interface to these operations.","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_null-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_null","text":"left_null(A; [kind::Symbol, trunc, alg_qr, alg_svd]) -> N\nleft_null!(A, [N]; [kind::Symbol, alg_qr, alg_svd]) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A of size (m, n), i.e. the nullspace of adjoint(A), such that adjoint(A)*N ≈ 0 and N'*N ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxnullity.\n\nThis is a high-level wrapper and will use one of the decompositions qr! or svd! to compute the orthogonal basis N, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qr: N is computed using the QR decomposition.   This requires isnothing(trunc) and left_null!(A, [N], kind=:qr) is equivalent to   qr_null!(A, [N], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to either the zero singular values if trunc   isn't specified or the singular values specified by trunc.\n\nWhen kind is not provided, the default value is :qr when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg_qr and alg_svd keyword arguments, which will only be used by the corresponding factorization backend. If alg_qr or alg_svd are NamedTuples, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_qr defaults to (; positive=true) so that by default a positive QR decomposition will be used.\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_null-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_null","text":"right_null(A; [kind::Symbol, alg_lq, alg_svd]) -> Nᴴ\nright_null!(A, [Nᴴ]; [kind::Symbol, alg_lq, alg_svd]) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel or nullspace of the matrix A of size (m, n), such that A*adjoint(Nᴴ) ≈ 0 and Nᴴ*adjoint(Nᴴ) ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas trunc can be used to control the the rank of A via its singular values.\n\ntrunc can either be a truncation strategy object or a NamedTuple with fields atol, rtol, and maxnullity.\n\nThis is a high-level wrapper and will use one of the decompositions lq! or svd! to compute the orthogonal basis Nᴴ, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lq: Nᴴ is computed using the (nonpositive) LQ decomposition.   This requires isnothing(trunc) and right_null!(A, [Nᴴ], kind=:lq) is equivalent to   lq_null!(A, [Nᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.\n\nWhen kind is not provided, the default value is :lq when isnothing(trunc) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg_lq and alg_svd keyword arguments, which will only be used by the corresponding factorization backend. If alg_lq or alg_svd are NamedTuples, a default algorithm is chosen with select_algorithm and the NamedTuple is passed as keyword arguments to that algorithm. alg_lq defaults to (; positive=true) so that by default a positive LQ decomposition will be used.\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#Matrix-Properties","page":"Matrix Properties","title":"Matrix Properties","text":"","category":"section"},{"location":"user_interface/properties/","page":"Matrix Properties","title":"Matrix Properties","text":"MatrixAlgebraKit.jl provides a number of methods to check various properties of matrices.","category":"page"},{"location":"user_interface/properties/#MatrixAlgebraKit.isisometric-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.isisometric","text":"isisometric(A; side=:left, isapprox_kwargs...) -> Bool\n\nTest whether a linear map is an isometry, where the type of isometry is controlled by kind:\n\nside = :left : A' * A ≈ I. \nside = :right : A * A' ≈ I.\n\nThe isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nNew specializations should overload MatrixAlgebraKit.is_left_isometric and MatrixAlgebraKit.is_right_isometric.\n\nSee also isunitary.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.isunitary-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.isunitary","text":"isunitary(A; isapprox_kwargs...)\n\nTest whether a linear map is unitary, i.e. A * A' ≈ I ≈ A' * A. The isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nSee also isisometric.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.ishermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.ishermitian","text":"ishermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is Hermitian, i.e. A = A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.isantihermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.isantihermitian","text":"isantihermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is anti-Hermitian, i.e. A = -A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/","page":"Matrix Properties","title":"Matrix Properties","text":"Furthermore, there are also methods to project a matrix onto the nearest matrix (in 2-norm distance) with a given property.","category":"page"},{"location":"user_interface/properties/#MatrixAlgebraKit.project_isometric-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.project_isometric","text":"project_isometric(A; kwargs...)\nproject_isometric(A, alg)\nproject_isometric!(A, [W]; kwargs...)\nproject_isometric!(A, [W], alg)\n\nCompute the projection of A onto the manifold of isometric matrices, i.e. matrices satisfying A' * A ≈ I. This projection is computed via the polar decomposition, i.e. W corresponds to the first return value of left_polar!, but avoids computing the positive definite factor explicitly.\n\nnote: Note\nThe bang method project_isometric! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.project_hermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.project_hermitian","text":"project_hermitian(A; kwargs...)\nproject_hermitian(A, alg)\nproject_hermitian!(A, [Aₕ]; kwargs...)\nproject_hermitian!(A, [Aₕ], alg)\n\nCompute the hermitian part of a (square) matrix A, defined as (A + A') / 2. For real matrices this corresponds to the symmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₕ; by default it is equal to A and so the input matrix A is replaced by its hermitian projection.\n\nSee also project_antihermitian.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.project_antihermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.project_antihermitian","text":"project_antihermitian(A; kwargs...)\nproject_antihermitian(A, alg)\nproject_antihermitian!(A, [Aₐ]; kwargs...)\nproject_antihermitian!(A, [Aₐ], alg)\n\nCompute the anti-hermitian part of a (square) matrix A, defined as (A - A') / 2. For real matrices this corresponds to the antisymmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₐ; by default it is equal toAand so the input matrixA` is replaced by its antihermitian projection.\n\nSee also project_hermitian.\n\n\n\n\n\n","category":"function"},{"location":"#MatrixAlgebraKit.jl","page":"Home","title":"MatrixAlgebraKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia interface for matrix algebra, with a focus on performance, flexibility and extensibility.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MatrixAlgebraKit.jl is part of the general registry, and can be installed through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MatrixAlgebraKit","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main goals of this package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Definition of a common interface that is sufficiently expressive to allow easy adoption and extension.\nAbility to pass pre-allocated output arrays where the result of a computation is stored.\nAbility to easily switch between different backends and algorithms for the same operation.\nFirst class availability of pullback rules that can be used in combination with different AD ecosystems.","category":"page"},{"location":"#User-Interface","page":"Home","title":"User Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"On the user-facing side of this package, we provide various implementations and interfaces for different matrix algebra operations. These operations typically follow some common skeleton, and here we go into a little more detail to what behavior can be expected.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"user_interface/compositions.md\", \"user_interface/decompositions.md\",\n         \"user_interface/truncations.md\", \"user_interface/properties.md\",\n         \"user_interface/matrix_functions.md\"]\nDepth = 2","category":"page"}]
}
