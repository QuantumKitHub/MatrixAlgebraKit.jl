var documenterSearchIndex = {"docs":
[{"location":"user_interface/matrix_functions/#Matrix-functions","page":"Matrix functions","title":"Matrix functions","text":"Coming soon...","category":"section"},{"location":"library/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"library/#Constants-and-types","page":"Library","title":"Constants and types","text":"","category":"section"},{"location":"library/#Functions","page":"Library","title":"Functions","text":"","category":"section"},{"location":"library/#Other","page":"Library","title":"Other","text":"","category":"section"},{"location":"library/#MatrixAlgebraKit.AbstractAlgorithm","page":"Library","title":"MatrixAlgebraKit.AbstractAlgorithm","text":"abstract type AbstractAlgorithm end\n\nSupertype to dispatch on specific implementations of different the different functions. Concrete subtypes should represent both a way to dispatch to a given implementation, as well as the configuration of that implementation.\n\nSee also select_algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.Algorithm","page":"Library","title":"MatrixAlgebraKit.Algorithm","text":"Algorithm{name,KW} <: AbstractAlgorithm\n\nBare-bones implementation of an algorithm, where name should be a Symbol to dispatch on, and KW is typically a NamedTuple indicating the keyword arguments.\n\nSee also @algdef.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_DivideAndConquer","text":"CUSOLVER_DivideAndConquer(; fixgauge::Bool = true)\n\nAlgorithm type to denote the CUSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_HouseholderQR","text":"CUSOLVER_HouseholderQR(; positive = false)\n\nAlgorithm type to denote the standard CUSOLVER algorithm for computing the QR decomposition of a matrix using Householder reflectors. The keyword positive = true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_Jacobi","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_Jacobi","text":"CUSOLVER_Jacobi(; fixgauge::Bool = true)\n\nAlgorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_QRIteration","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_QRIteration","text":"CUSOLVER_QRIteration(; fixgauge::Bool = true)\n\nAlgorithm type to denote the CUSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_Randomized","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_Randomized","text":"CUSOLVER_Randomized(; k, p, niters)\n\nAlgorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix using the randomized SVD algorithm. Here, k denotes the number of singular values that should be computed, therefore requiring k <= min(size(A)). This method is accurate for small values of k compared to the size of the input matrix, where the accuracy can be improved by increasing p, the number of additional values used for oversampling, and niters, the number of iterations the solver uses, at the cost of increasing the runtime.\n\nSee also the CUSOLVER documentation for more information.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_SVDPolar","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_SVDPolar","text":"CUSOLVER_SVDPolar(; fixgauge::Bool = true)\n\nAlgorithm type to denote the CUSOLVER driver for computing the singular value decomposition of a general matrix by using Halley's iterative algorithm to compute the polar decompositon, followed by the hermitian eigenvalue decomposition of the positive definite factor. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.CUSOLVER_Simple","page":"Library","title":"MatrixAlgebraKit.CUSOLVER_Simple","text":"CUSOLVER_Simple(; fixgauge::Bool = true)\n\nAlgorithm type to denote the simple CUSOLVER driver for computing the non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.DiagonalAlgorithm","page":"Library","title":"MatrixAlgebraKit.DiagonalAlgorithm","text":"DiagonalAlgorithm(; kwargs...)\n\nAlgorithm type to denote a native Julia implementation of the decompositions making use of the diagonal structure of the input and outputs.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.GLA_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.GLA_HouseholderQR","text":"GLA_HouseholderQR(; positive = false)\n\nAlgorithm type to denote the GenericLinearAlgebra.jl implementation for computing the QR decomposition of a matrix using Householder reflectors. Currently, only blocksize = 1 and pivoted == false are supported. The keyword positive = true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.GLA_QRIteration","page":"Library","title":"MatrixAlgebraKit.GLA_QRIteration","text":"GLA_QRIteration(; fixgauge::Bool = true)\n\nAlgorithm type to denote the GenericLinearAlgebra.jl implementation for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.GS_QRIteration","page":"Library","title":"MatrixAlgebraKit.GS_QRIteration","text":"GS_QRIteration()\n\nAlgorithm type to denote the GenericSchur.jl implementation for computing the eigenvalue decomposition of a non-Hermitian matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Bisection","page":"Library","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Expert","page":"Library","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert(; fixgauge::Bool = true)\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_HouseholderLQ","page":"Library","title":"MatrixAlgebraKit.LAPACK_HouseholderLQ","text":"LAPACK_HouseholderLQ(; blocksize, positive = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. ?gelqt will be chosen if blocksize > 1 or ?gelqf will be chosen if blocksize == 1. The keyword positive = true can be used to ensure that the diagonal elements of L are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.LAPACK_HouseholderQR","text":"LAPACK_HouseholderQR(; blocksize, positive = false, pivoted = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  ?geqrt will be chosen if blocksize > 1. With blocksize == 1, ?geqrf will be chosen if pivoted == false and ?geqp3 will be chosen if pivoted == true. The keyword positive = true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Jacobi","page":"Library","title":"MatrixAlgebraKit.LAPACK_Jacobi","text":"LAPACK_Jacobi(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","page":"Library","title":"MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","text":"LAPACK_MultipleRelativelyRobustRepresentations(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_QRIteration","page":"Library","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Simple","page":"Library","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple(; fixgauge::Bool = true)\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LQViaTransposedQR","page":"Library","title":"MatrixAlgebraKit.LQViaTransposedQR","text":"LQViaTransposedQR(qr_alg)\n\nAlgorithm type to denote finding the LQ decomposition of A by computing the QR decomposition of Aᵀ. The qr_alg specifies which QR-decomposition implementation to use.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LeftNullAlgorithm","page":"Library","title":"MatrixAlgebraKit.LeftNullAlgorithm","text":"LeftNullAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for left_null. By default Kind is a symbol, which can be either :qr or :svd.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LeftOrthAlgorithm","page":"Library","title":"MatrixAlgebraKit.LeftOrthAlgorithm","text":"LeftOrthAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for left_orth. By default Kind is a symbol, which can be either :qr, :polar or :svd.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.NativeBlocked","page":"Library","title":"MatrixAlgebraKit.NativeBlocked","text":"NativeBlocked(; blocksize = 32)\n\nAlgorithm type to denote a native blocked algorithm with given blocksize for computing the hermitian or anti-hermitian part of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.NoTruncation","page":"Library","title":"MatrixAlgebraKit.NoTruncation","text":"NoTruncation()\n\nTrivial truncation strategy that keeps all values, mostly for testing purposes. See also notrunc().\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.PolarNewton","page":"Library","title":"MatrixAlgebraKit.PolarNewton","text":"PolarNewton(; maxiter = 10, tol = defaulttol(A))\n\nAlgorithm for computing the polar decomposition of a matrix A via scaled Newton iteration, with a maximum of maxiter iterations and until convergence up to tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.PolarViaSVD","page":"Library","title":"MatrixAlgebraKit.PolarViaSVD","text":"PolarViaSVD(svd_alg)\n\nAlgorithm for computing the polar decomposition of a matrix A via the singular value decomposition (SVD) of A. The svd_alg argument specifies the SVD algorithm to use.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_Bisection","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_Bisection","text":"ROCSOLVER_Bisection(; fixgauge::Bool = true)\n\nAlgorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_DivideAndConquer","text":"ROCSOLVER_DivideAndConquer(; fixgauge::Bool = true)\n\nAlgorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_HouseholderQR","text":"ROCSOLVER_HouseholderQR(; positive = false)\n\nAlgorithm type to denote the standard ROCSOLVER algorithm for computing the QR decomposition of a matrix using Householder reflectors. The keyword positive=true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_Jacobi","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_Jacobi","text":"ROCSOLVER_Jacobi(; fixgauge::Bool = true)\n\nAlgorithm type to denote the ROCSOLVER driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.ROCSOLVER_QRIteration","page":"Library","title":"MatrixAlgebraKit.ROCSOLVER_QRIteration","text":"ROCSOLVER_QRIteration(; fixgauge::Bool = true)\n\nAlgorithm type to denote the ROCSOLVER driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.RightNullAlgorithm","page":"Library","title":"MatrixAlgebraKit.RightNullAlgorithm","text":"RightNullAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for right_null. By default Kind is a symbol, which can be either :lq or :svd.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.RightOrthAlgorithm","page":"Library","title":"MatrixAlgebraKit.RightOrthAlgorithm","text":"RightOrthAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for right_orth. By default Kind is a symbol, which can be either :lq, :polar or :svd.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncatedAlgorithm","page":"Library","title":"MatrixAlgebraKit.TruncatedAlgorithm","text":"TruncatedAlgorithm(alg::AbstractAlgorithm, trunc::TruncationAlgorithm)\n\nGeneric wrapper type for algorithms that consist of first using alg, followed by a truncation through trunc.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByError","page":"Library","title":"MatrixAlgebraKit.TruncationByError","text":"TruncationByError(; atol::Real, rtol::Real, p::Real)\n\nTruncation strategy to discard values until the error caused by the discarded values exceeds some tolerances. See also truncerror.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByFilter","page":"Library","title":"MatrixAlgebraKit.TruncationByFilter","text":"TruncationByFilter(filter::Function)\n\nTruncation strategy to keep the values for which filter returns true.\n\nSee also truncfilter.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByOrder","page":"Library","title":"MatrixAlgebraKit.TruncationByOrder","text":"TruncationByOrder(howmany::Int, by::Function, rev::Bool)\n\nTruncation strategy to keep the first howmany values when sorted according to by in increasing (decreasing) order if rev is false (true).\n\nSee also truncrank.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationByValue","page":"Library","title":"MatrixAlgebraKit.TruncationByValue","text":"TruncationByValue(atol::Real, rtol::Real, p::Real, by, keep_below::Bool=false)\n\nTruncation strategy to keep the values that satisfy by(val) > max(atol, rtol * norm(values, p). If keep_below = true, discard these values instead. See also trunctol\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationIntersection","page":"Library","title":"MatrixAlgebraKit.TruncationIntersection","text":"TruncationIntersection(trunc::TruncationStrategy, truncs::TruncationStrategy...)\n\nTruncation strategy that composes multiple truncation strategies, keeping values that are common between them.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationStrategy","page":"Library","title":"MatrixAlgebraKit.TruncationStrategy","text":"abstract type TruncationStrategy end\n\nSupertype to denote different strategies for truncated decompositions that are implemented via post-truncation.\n\nSee also truncate\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationStrategy-Tuple{}","page":"Library","title":"MatrixAlgebraKit.TruncationStrategy","text":"TruncationStrategy(; kwargs...)\n\nSelect a truncation strategy based on the provided keyword arguments.\n\nKeyword arguments\n\nThe following keyword arguments are all optional, and their default value (nothing) will be ignored. It is also allowed to combine multiple of these, in which case the kept values will consist of the intersection of the different truncated strategies.\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.copy_input","page":"Library","title":"MatrixAlgebraKit.copy_input","text":"copy_input(f, A)\n\nPreprocess the input A for a given function, such that it may be handled correctly later. This may include a copy whenever the implementation would destroy the original matrix, or a change of element type to something that is supported.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.default_algorithm","page":"Library","title":"MatrixAlgebraKit.default_algorithm","text":"MatrixAlgebraKit.default_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.default_algorithm(f, ::Type{TA}; kwargs...) where {TA}\n\nSelect the default algorithm for a given factorization function f and input A. In general, this is called by select_algorithm if no algorithm is specified explicitly. New types should prefer to register their default algorithms in the type domain.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.default_fixgauge","page":"Library","title":"MatrixAlgebraKit.default_fixgauge","text":"default_fixgauge() -> current_value\ndefault_fixgauge(new_value::Bool) -> previous_value\n\nGlobal toggle for enabling or disabling the default behavior of gauge fixing the output of the eigen- and singular value decompositions.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.default_hermitian_tol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_hermitian_tol","text":"default_hermitian_tol(A)\n\nDefault tolerance for deciding to warn if the provided A is not hermitian.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.default_pullback_degeneracy_atol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_pullback_degeneracy_atol","text":"default_pullback_degeneracy_atol(A)\n\nDefault tolerance for deciding when values should be considered as degenerate.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.default_pullback_gauge_atol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_pullback_gauge_atol","text":"default_pullback_gauge_atol(ΔA...)\n\nDefault tolerance for deciding to warn if incoming adjoints of a pullback rule has components that are not gauge-invariant.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.default_pullback_rank_atol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_pullback_rank_atol","text":"default_pullback_rank_atol(A)\n\nDefault tolerance for deciding what values should be considered equal to 0.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.defaulttol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.defaulttol","text":"defaulttol(x)\n\nDefault tolerance or precision for a given object, e.g. to decide when it can be considerd to be zero or ignored in some other way, or how accurate some quantity needs to be computed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.does_truncate-Tuple{MatrixAlgebraKit.AbstractAlgorithm}","page":"Library","title":"MatrixAlgebraKit.does_truncate","text":"does_truncate(alg::AbstractAlgorithm) -> Bool\n\nIndicate whether or not an algorithm will compute a truncated decomposition (such that composing the factors only approximates the input up to some tolerance).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eig_full","page":"Library","title":"MatrixAlgebraKit.eig_full","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_full!","page":"Library","title":"MatrixAlgebraKit.eig_full!","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_pullback!","page":"Library","title":"MatrixAlgebraKit.eig_pullback!","text":"eig_pullback!(\n    ΔA::AbstractMatrix, A, DV, ΔDV, [ind];\n    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])\n)\n\nAdds the pullback from the full eigenvalue decomposition of A to ΔA, given the output DV of eig_full and the cotangent ΔDV of eig_full or eig_trunc.\n\nIn particular, it is assumed that A ≈ V * D * inv(V) with thus size(A) == size(V) == size(D) and D diagonal. For the cotangents, an arbitrary number of eigenvectors or eigenvalues can be missing, i.e. for a matrix A of size (n, n), ΔV can have size (n, pV) and diagview(ΔD) can have length pD. In those cases, additionally ind is required to specify which eigenvectors or eigenvalues are present in ΔV or ΔD. By default, it is assumed that all eigenvectors and eigenvalues are present.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of V' * ΔV to rows i and columns j for which abs(D[i] - D[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc","page":"Library","title":"MatrixAlgebraKit.eig_trunc","text":"eig_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neig_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neig_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword Arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!), eig_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc!","page":"Library","title":"MatrixAlgebraKit.eig_trunc!","text":"eig_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neig_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neig_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword Arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!), eig_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.eig_trunc_pullback!","text":"eig_trunc_pullback!(\n    ΔA::AbstractMatrix, ΔDV, A, DV;\n    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])\n)\n\nAdds the pullback from the truncated eigenvalue decomposition of A to ΔA, given the output DV and the cotangent ΔDV of eig_trunc.\n\nIn particular, it is assumed that A * V ≈ V * D with V a rectangular matrix of eigenvectors and D diagonal. For the cotangents, it is assumed that if ΔV is not zero, then it has the same number of columns as V, and if ΔD is not zero, then it is a diagonal matrix of the same size as D.\n\nFor this method to work correctly, it is also assumed that the remaining eigenvalues (not included in D) are (sufficiently) separated from those in D.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of V' * ΔV to rows i and columns j for which abs(D[i] - D[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eig_vals","page":"Library","title":"MatrixAlgebraKit.eig_vals","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_vals!","page":"Library","title":"MatrixAlgebraKit.eig_vals!","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_full","page":"Library","title":"MatrixAlgebraKit.eigh_full","text":"eigh_full(A; kwargs...) -> D, V, ϵ\neigh_full(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_full!(A, [DV]; kwargs...) -> D, V, ϵ\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_full!","page":"Library","title":"MatrixAlgebraKit.eigh_full!","text":"eigh_full(A; kwargs...) -> D, V, ϵ\neigh_full(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_full!(A, [DV]; kwargs...) -> D, V, ϵ\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_pullback!","page":"Library","title":"MatrixAlgebraKit.eigh_pullback!","text":"eigh_pullback!(\n    ΔA::AbstractMatrix, A, DV, ΔDV, [ind];\n    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])\n)\n\nAdds the pullback from the Hermitian eigenvalue decomposition of A to ΔA, given the output DV of eigh_full and the cotangent ΔDV of eigh_full or eigh_trunc.\n\nIn particular, it is assumed that A ≈ V * D * V' with thus size(A) == size(V) == size(D) and D diagonal. For the cotangents, an arbitrary number of eigenvectors or eigenvalues can be missing, i.e. for a matrix A of size (n, n), ΔV can have size (n, pV) and diagview(ΔD) can have length pD. In those cases, additionally ind is required to specify which eigenvectors or eigenvalues are present in ΔV or ΔD. By default, it is assumed that all eigenvectors and eigenvalues are present.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of V' * ΔV, restricted to rows i and columns j for which `abs(D[i]\n\nD[j]) < degeneracyatol, is not small compared togaugeatol`.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc","page":"Library","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the discarded eigenvalues.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!), eigh_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc!","page":"Library","title":"MatrixAlgebraKit.eigh_trunc!","text":"eigh_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the discarded eigenvalues.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!), eigh_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.eigh_trunc_pullback!","text":"eigh_trunc_pullback!(\n    ΔA::AbstractMatrix, A, DV, ΔDV;\n    degeneracy_atol::Real = default_pullback_rank_atol(DV[1]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔDV[2])\n)\n\nAdds the pullback from the truncated Hermitian eigenvalue decomposition of A to ΔA, given the output DV and the cotangent ΔDV of eig_trunc.\n\nIn particular, it is assumed that A * V ≈ V * D with V a rectangular matrix of eigenvectors and D diagonal. For the cotangents, it is assumed that if ΔV is not zero, then it has the same number of columns as V, and if ΔD is not zero, then it is a diagonal matrix of the same size as D.\n\nFor this method to work correctly, it is also assumed that the remaining eigenvalues (not included in D) are (sufficiently) separated from those in D.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the restriction of V' * ΔV to rows i and columns j for which abs(D[i] - D[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eigh_vals","page":"Library","title":"MatrixAlgebraKit.eigh_vals","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_vals!","page":"Library","title":"MatrixAlgebraKit.eigh_vals!","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.findtruncated","page":"Library","title":"MatrixAlgebraKit.findtruncated","text":"MatrixAlgebraKit.findtruncated(values::AbstractVector, strategy::TruncationStrategy)\n\nGeneric interface for finding truncated values of the spectrum of a decomposition based on the strategy. The output should be a collection of indices specifying which values to keep. MatrixAlgebraKit.findtruncated is used inside of the default implementation of truncate to perform the truncation. It does not assume that the values are sorted. For a version that assumes the values are reverse sorted (which is the standard case for SVD) see MatrixAlgebraKit.findtruncated_svd.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.findtruncated_svd","page":"Library","title":"MatrixAlgebraKit.findtruncated_svd","text":"MatrixAlgebraKit.findtruncated_svd(values::AbstractVector, strategy::TruncationStrategy)\n\nLike MatrixAlgebraKit.findtruncated but assumes that the values are real and sorted in descending order, as typically obtained by the SVD. This assumption is not checked, and this is used in the default implementation of svd_trunc!.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gaugefix!","page":"Library","title":"MatrixAlgebraKit.gaugefix!","text":"gaugefix!(f_eig, V)\ngaugefix!(f_svd, U, Vᴴ)\n\nFix the residual gauge degrees of freedom in the eigen or singular vectors, that are obtained from the decomposition performed by f_eig or f_svd. This is achieved by ensuring that the entry with the largest magnitude in V or U is real and positive.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_full","page":"Library","title":"MatrixAlgebraKit.gen_eig_full","text":"gen_eig_full(A, B; kwargs...) -> W, V\ngen_eig_full(A, B, alg::AbstractAlgorithm) -> W, V\ngen_eig_full!(A, B, [WV]; kwargs...) -> W, V\ngen_eig_full!(A, B, [WV], alg::AbstractAlgorithm) -> W, V\n\nCompute the full generalized eigenvalue decomposition of the square matrices A and B, such that A * V = B * V * W, where the invertible matrix V contains the generalized eigenvectors and the diagonal matrix W contains the associated generalized eigenvalues.\n\nnote: Note\nThe bang method gen_eig_full! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided WV as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_full!","page":"Library","title":"MatrixAlgebraKit.gen_eig_full!","text":"gen_eig_full(A, B; kwargs...) -> W, V\ngen_eig_full(A, B, alg::AbstractAlgorithm) -> W, V\ngen_eig_full!(A, B, [WV]; kwargs...) -> W, V\ngen_eig_full!(A, B, [WV], alg::AbstractAlgorithm) -> W, V\n\nCompute the full generalized eigenvalue decomposition of the square matrices A and B, such that A * V = B * V * W, where the invertible matrix V contains the generalized eigenvectors and the diagonal matrix W contains the associated generalized eigenvalues.\n\nnote: Note\nThe bang method gen_eig_full! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided WV as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_vals","page":"Library","title":"MatrixAlgebraKit.gen_eig_vals","text":"gen_eig_vals(A, B; kwargs...) -> W\ngen_eig_vals(A, B, alg::AbstractAlgorithm) -> W\ngen_eig_vals!(A, B, [W]; kwargs...) -> W \ngen_eig_vals!(A, B, [W], alg::AbstractAlgorithm) -> W\n\nCompute the list of generalized eigenvalues of A and B.\n\nnote: Note\nThe bang method gen_eig_vals! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.gen_eig_vals!","page":"Library","title":"MatrixAlgebraKit.gen_eig_vals!","text":"gen_eig_vals(A, B; kwargs...) -> W\ngen_eig_vals(A, B, alg::AbstractAlgorithm) -> W\ngen_eig_vals!(A, B, [W]; kwargs...) -> W \ngen_eig_vals!(A, B, [W], alg::AbstractAlgorithm) -> W\n\nCompute the list of generalized eigenvalues of A and B.\n\nnote: Note\nThe bang method gen_eig_vals! optionally accepts the output structure and possibly destroys the input matrices A and B. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\nnote: Note\nNote that gen_eig_full and its variants do not assume additional structure on the inputs, and therefore will always return complex eigenvalues and eigenvectors. Real eigenvalues can be expected when both input matrices are hermitian and one of them is positive definite, but specialized methods that exploit this structure are not yet implemented or supported.\n\nSee also gen_eig_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.initialize_output","page":"Library","title":"MatrixAlgebraKit.initialize_output","text":"initialize_output(f, A, alg)\n\nWhenever possible, allocate the destination for applying a given algorithm in-place. If this is not possible, for example when the output size is not known a priori or immutable, this function may return nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.inv_regularized","page":"Library","title":"MatrixAlgebraKit.inv_regularized","text":"inv_regularized(a::Number, tol = defaulttol(a))\ninv_regularized(A::Matrix, tol = defaulttol(A); isposdef = false, kwargs...)\n\nCompute a smooth regularised inverse (L2 Tikhonov regularisation) of a number or square  matrix a.\n\nFor numbers, this is given by inv(hypot(a, tol)).\nFor matrices, this is computed using the singular value decomposition and aplying   inv_regularized to the singular values. If isposdef = true, the singular value   decomposition is equivalent to the (Hermitian) eigenvalue decomposition of A and   the latter is used instead.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.inv_safe","page":"Library","title":"MatrixAlgebraKit.inv_safe","text":"function inv_safe(a::Number, tol = defaulttol(a))\n\nCompute the inverse of a number a, but return zero if a is smaller than tol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.is_left_isometric","page":"Library","title":"MatrixAlgebraKit.is_left_isometric","text":"is_left_isometric(A; isapprox_kwargs...) -> Bool\n\nTest whether a linear map is a (left) isometry, i.e. A' * A ≈ I. The isapprox_kwargs can be used to control the tolerances of the equality.\n\nSee also isisometric and MatrixAlgebraKit.is_right_isometric.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.is_right_isometric","page":"Library","title":"MatrixAlgebraKit.is_right_isometric","text":"is_right_isometric(A; isapprox_kwargs...) -> Bool\n\nTest whether a linear map is a (right) isometry, i.e. A * A' ≈ I. The isapprox_kwargs can be used to control the tolerances of the equality.\n\nSee also isisometric and MatrixAlgebraKit.is_left_isometric.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.isantihermitian-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.isantihermitian","text":"isantihermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is anti-Hermitian, i.e. A = -A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.ishermitian-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.ishermitian","text":"ishermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is Hermitian, i.e. A = A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.isisometric-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.isisometric","text":"isisometric(A; side=:left, isapprox_kwargs...) -> Bool\n\nTest whether a linear map is an isometry, where the type of isometry is controlled by kind:\n\nside = :left : A' * A ≈ I. \nside = :right : A * A' ≈ I.\n\nThe isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nNew specializations should overload MatrixAlgebraKit.is_left_isometric and MatrixAlgebraKit.is_right_isometric.\n\nSee also isunitary.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.isunitary-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.isunitary","text":"isunitary(A; isapprox_kwargs...)\n\nTest whether a linear map is unitary, i.e. A * A' ≈ I ≈ A' * A. The isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nSee also isisometric.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.iszerotangent","page":"Library","title":"MatrixAlgebraKit.iszerotangent","text":"iszerotangent(x)\n\nReturn true if x is of a type that the different AD engines use to communicate a (co)tangent that is identically zero. By overloading this method, and writing pullback definitions in term of it, we will be able to hook into different AD ecosystems\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_null","page":"Library","title":"MatrixAlgebraKit.left_null","text":"left_null(A; [alg], [trunc], kwargs...) -> N\nleft_null!(A, [N], [alg]; [trunc], kwargs...) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A, i.e. the nullspace of adjoint(A), such that adjoint(A) * N ≈ 0 and N' * N ≈ I.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of A', whereas trunc can optionally  be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nnote: Note\nHere notrunc has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional columns of A.\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:qr : Factorize via QR nullspace, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        N = qr_null(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument. It is roughly equivalent to:\n\n        U, S, _ = svd_full(A; kwargs...)\n        N = truncate(left_null, (U, S), trunc)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a LeftNullAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with left_null_alg(alg).\n\n\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!) and right_orth(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_null!","page":"Library","title":"MatrixAlgebraKit.left_null!","text":"left_null(A; [alg], [trunc], kwargs...) -> N\nleft_null!(A, [N], [alg]; [trunc], kwargs...) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A, i.e. the nullspace of adjoint(A), such that adjoint(A) * N ≈ 0 and N' * N ≈ I.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of A', whereas trunc can optionally  be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nnote: Note\nHere notrunc has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional columns of A.\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:qr : Factorize via QR nullspace, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        N = qr_null(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument. It is roughly equivalent to:\n\n        U, S, _ = svd_full(A; kwargs...)\n        N = truncate(left_null, (U, S), trunc)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a LeftNullAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with left_null_alg(alg).\n\n\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!) and right_orth(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}","page":"Library","title":"MatrixAlgebraKit.left_null_alg","text":"left_null_alg(alg::AbstractAlgorithm) -> LeftNullAlgorithm\n\nConvert an algorithm to a LeftNullAlgorithm wrapper for use with left_null.\n\nThis function attempts to deduce the appropriate factorization kind (:qr or :svd) from the algorithm type and wraps it in a LeftNullAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.left_null_alg(alg::CustomAlgorithm) = LeftNullAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also LeftNullAlgorithm, left_null.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.left_orth","page":"Library","title":"MatrixAlgebraKit.left_orth","text":"left_orth(A; [alg], [trunc], kwargs...) -> V, C\nleft_orth!(A, [VC], [alg]; [trunc], kwargs...) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A, as well as a  matrix C (the corestriction) such that A factors as A = V * C.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor A, whereas trunc can optionally be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will typically be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:qr : Factorize via QR decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        V, C = qr_compact(A; kwargs...)\n\n:polar : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        V, C = left_polar(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument, and is roughly equivalent to:\n\n        V, S, C = svd_trunc(A; trunc, kwargs...)\n        C = lmul!(S, C)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a LeftOrthAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with left_orth_alg(alg).\n\n\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_null(!) and right_null(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_orth!","page":"Library","title":"MatrixAlgebraKit.left_orth!","text":"left_orth(A; [alg], [trunc], kwargs...) -> V, C\nleft_orth!(A, [VC], [alg]; [trunc], kwargs...) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A, as well as a  matrix C (the corestriction) such that A factors as A = V * C.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor A, whereas trunc can optionally be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will typically be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:qr : Factorize via QR decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        V, C = qr_compact(A; kwargs...)\n\n:polar : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        V, C = left_polar(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument, and is roughly equivalent to:\n\n        V, S, C = svd_trunc(A; trunc, kwargs...)\n        C = lmul!(S, C)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a LeftOrthAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with left_orth_alg(alg).\n\n\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_null(!) and right_null(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}","page":"Library","title":"MatrixAlgebraKit.left_orth_alg","text":"left_orth_alg(alg::AbstractAlgorithm) -> LeftOrthAlgorithm\n\nConvert an algorithm to a LeftOrthAlgorithm wrapper for use with left_orth.\n\nThis function attempts to deduce the appropriate factorization kind (:qr, :polar, or :svd) from the algorithm type and wraps it in a LeftOrthAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.left_orth_alg(alg::CustomAlgorithm) = LeftOrthAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also LeftOrthAlgorithm, left_orth.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.left_polar","page":"Library","title":"MatrixAlgebraKit.left_polar","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar!","page":"Library","title":"MatrixAlgebraKit.left_polar!","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.left_polar_pullback!","text":"left_polar_pullback!(ΔA, A, WP, ΔWP)\n\nAdds the pullback from the left polar decomposition of A to ΔA given the output WP and cotangent ΔWP of left_polar(A).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.lq_compact","page":"Library","title":"MatrixAlgebraKit.lq_compact","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_compact!","page":"Library","title":"MatrixAlgebraKit.lq_compact!","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_full","page":"Library","title":"MatrixAlgebraKit.lq_full","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_full!","page":"Library","title":"MatrixAlgebraKit.lq_full!","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null","page":"Library","title":"MatrixAlgebraKit.lq_null","text":"lq_null(A; kwargs...) -> Nᴴ\nlq_null(A, alg::AbstractAlgorithm) -> Nᴴ\nlq_null!(A, [Nᴴ]; kwargs...) -> Nᴴ\nlq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -> Nᴴ\n\nFor a (m, n) matrix A, compute the matrix Nᴴ corresponding the final n - min(m, n) rows  oft the unitary Q factor in the full LQ decomposition of A, i.e. the rows that are not present in the Q factor of the compact LQ decomposition. The matrix Nᴴ is such that the isometric matrix N = adjoint(Nᴴ) contains an orthonormal basis for the kernel (null space) of A as its columns, i.e. A * N = 0 or thus A * adjoint(Nᴴ) = 0.\n\nnote: Note\nThe bang method lq_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ argument as output.\n\nnote: Note\nThe matrix Nᴴ is empty when m >= n.\n\nSee also qr_full(!) and qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null!","page":"Library","title":"MatrixAlgebraKit.lq_null!","text":"lq_null(A; kwargs...) -> Nᴴ\nlq_null(A, alg::AbstractAlgorithm) -> Nᴴ\nlq_null!(A, [Nᴴ]; kwargs...) -> Nᴴ\nlq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -> Nᴴ\n\nFor a (m, n) matrix A, compute the matrix Nᴴ corresponding the final n - min(m, n) rows  oft the unitary Q factor in the full LQ decomposition of A, i.e. the rows that are not present in the Q factor of the compact LQ decomposition. The matrix Nᴴ is such that the isometric matrix N = adjoint(Nᴴ) contains an orthonormal basis for the kernel (null space) of A as its columns, i.e. A * N = 0 or thus A * adjoint(Nᴴ) = 0.\n\nnote: Note\nThe bang method lq_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ argument as output.\n\nnote: Note\nThe matrix Nᴴ is empty when m >= n.\n\nSee also qr_full(!) and qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.lq_null_pullback!","text":"lq_null_pullback!(\n    ΔA::AbstractMatrix, A, Nᴴ, ΔNᴴ;\n    gauge_atol::Real = default_pullback_gauge_atol(ΔNᴴ)\n)\n\nAdds the pullback from the left nullspace of A to ΔA, given the nullspace basis  Nᴴ and its cotangent ΔNᴴ of lq_null(A).\n\nSee also lq_pullback!.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.lq_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.lq_pullback!","text":"lq_pullback!(\n    ΔA, A, LQ, ΔLQ;\n    rank_atol::Real = default_pullback_rank_atol(LQ[1]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔLQ[2])\n)\n\nAdds the pullback from the LQ decomposition of A to ΔA given the output LQ and cotangent ΔLQ of lq_compact(A; positive = true) or lq_full(A; positive = true).\n\nIn the case where the rank r of the original matrix A ≈ L * Q (as determined by rank_atol) is less then the minimum of the number of rows and columns of the cotangents ΔL and ΔQ, only the first r columns of L and the first r rows of Q are well-defined, and also the adjoint variables ΔL and ΔQ should have nonzero values only in the first r columns and rows respectively. If nonzero values in the remaining columns or rows exceed gauge_atol, a warning will be printed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.notrunc-Tuple{}","page":"Library","title":"MatrixAlgebraKit.notrunc","text":"notrunc()\n\nTruncation strategy that does nothing, and keeps all the values.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.null_truncation_strategy-Tuple{}","page":"Library","title":"MatrixAlgebraKit.null_truncation_strategy","text":"null_truncation_strategy(; kwargs...)\n\nSelect a nullspace truncation strategy based on the provided keyword arguments.\n\nKeyword arguments\n\nThe following keyword arguments are all optional, and their default value (nothing) will be ignored. It is also allowed to combine multiple of these, in which case the discarded values will consist of the intersection of the different truncated strategies.\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.project_antihermitian","page":"Library","title":"MatrixAlgebraKit.project_antihermitian","text":"project_antihermitian(A; kwargs...)\nproject_antihermitian(A, alg)\nproject_antihermitian!(A, [Aₐ]; kwargs...)\nproject_antihermitian!(A, [Aₐ], alg)\n\nCompute the anti-hermitian part of a (square) matrix A, defined as (A - A') / 2. For real matrices this corresponds to the antisymmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₐ; by default it is equal toAand so the input matrixA` is replaced by its antihermitian projection.\n\nSee also project_hermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_antihermitian!","page":"Library","title":"MatrixAlgebraKit.project_antihermitian!","text":"project_antihermitian(A; kwargs...)\nproject_antihermitian(A, alg)\nproject_antihermitian!(A, [Aₐ]; kwargs...)\nproject_antihermitian!(A, [Aₐ], alg)\n\nCompute the anti-hermitian part of a (square) matrix A, defined as (A - A') / 2. For real matrices this corresponds to the antisymmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₐ; by default it is equal toAand so the input matrixA` is replaced by its antihermitian projection.\n\nSee also project_hermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_hermitian","page":"Library","title":"MatrixAlgebraKit.project_hermitian","text":"project_hermitian(A; kwargs...)\nproject_hermitian(A, alg)\nproject_hermitian!(A, [Aₕ]; kwargs...)\nproject_hermitian!(A, [Aₕ], alg)\n\nCompute the hermitian part of a (square) matrix A, defined as (A + A') / 2. For real matrices this corresponds to the symmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₕ; by default it is equal to A and so the input matrix A is replaced by its hermitian projection.\n\nSee also project_antihermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_hermitian!","page":"Library","title":"MatrixAlgebraKit.project_hermitian!","text":"project_hermitian(A; kwargs...)\nproject_hermitian(A, alg)\nproject_hermitian!(A, [Aₕ]; kwargs...)\nproject_hermitian!(A, [Aₕ], alg)\n\nCompute the hermitian part of a (square) matrix A, defined as (A + A') / 2. For real matrices this corresponds to the symmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₕ; by default it is equal to A and so the input matrix A is replaced by its hermitian projection.\n\nSee also project_antihermitian.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_isometric","page":"Library","title":"MatrixAlgebraKit.project_isometric","text":"project_isometric(A; kwargs...)\nproject_isometric(A, alg)\nproject_isometric!(A, [W]; kwargs...)\nproject_isometric!(A, [W], alg)\n\nCompute the projection of A onto the manifold of isometric matrices, i.e. matrices satisfying A' * A ≈ I. This projection is computed via the polar decomposition, i.e. W corresponds to the first return value of left_polar!, but avoids computing the positive definite factor explicitly.\n\nnote: Note\nThe bang method project_isometric! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.project_isometric!","page":"Library","title":"MatrixAlgebraKit.project_isometric!","text":"project_isometric(A; kwargs...)\nproject_isometric(A, alg)\nproject_isometric!(A, [W]; kwargs...)\nproject_isometric!(A, [W], alg)\n\nCompute the projection of A onto the manifold of isometric matrices, i.e. matrices satisfying A' * A ≈ I. This projection is computed via the polar decomposition, i.e. W corresponds to the first return value of left_polar!, but avoids computing the positive definite factor explicitly.\n\nnote: Note\nThe bang method project_isometric! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact","page":"Library","title":"MatrixAlgebraKit.qr_compact","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact!","page":"Library","title":"MatrixAlgebraKit.qr_compact!","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_full","page":"Library","title":"MatrixAlgebraKit.qr_full","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_full!","page":"Library","title":"MatrixAlgebraKit.qr_full!","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null","page":"Library","title":"MatrixAlgebraKit.qr_null","text":"qr_null(A; kwargs...) -> N\nqr_null(A, alg::AbstractAlgorithm) -> N\nqr_null!(A, [N]; kwargs...) -> N\nqr_null!(A, [N], alg::AbstractAlgorithm) -> N\n\nFor a (m, n) matrix A, compute the matrix N corresponding the final m - min(m, n) columns  of the unitary Q factor in the full QR decomposition of A, i.e. the columns that are not present in the Q factor of the compact QR decomposition. The isometric matrix N contains an orthonormal basis for the cokernel of A as its columns, i.e. adjoint(A) * N = 0.\n\nnote: Note\nThe bang method qr_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N argument as output.\n\nnote: Note\nThe matrix N is empty when m <= n.\n\nSee also lq_full(!) and lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null!","page":"Library","title":"MatrixAlgebraKit.qr_null!","text":"qr_null(A; kwargs...) -> N\nqr_null(A, alg::AbstractAlgorithm) -> N\nqr_null!(A, [N]; kwargs...) -> N\nqr_null!(A, [N], alg::AbstractAlgorithm) -> N\n\nFor a (m, n) matrix A, compute the matrix N corresponding the final m - min(m, n) columns  of the unitary Q factor in the full QR decomposition of A, i.e. the columns that are not present in the Q factor of the compact QR decomposition. The isometric matrix N contains an orthonormal basis for the cokernel of A as its columns, i.e. adjoint(A) * N = 0.\n\nnote: Note\nThe bang method qr_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N argument as output.\n\nnote: Note\nThe matrix N is empty when m <= n.\n\nSee also lq_full(!) and lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.qr_null_pullback!","text":"qr_null_pullback!(\n    ΔA::AbstractMatrix, A, N, ΔN;\n    gauge_atol::Real = default_pullback_gauge_atol(ΔN)\n)\n\nAdds the pullback from the right nullspace of A to ΔA, given the nullspace basis N and its cotangent ΔN of qr_null(A).\n\nSee also qr_pullback!.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.qr_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.qr_pullback!","text":"qr_pullback!(\n    ΔA, A, QR, ΔQR;\n    tol::Real = default_pullback_gaugetol(QR[2]),\n    rank_atol::Real = default_pullback_rank_atol(QR[2]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔQR[1])\n)\n\nAdds the pullback from the QR decomposition of A to ΔA given the output QR and cotangent ΔQR of qr_compact(A; positive = true) or qr_full(A; positive = true).\n\nIn the case where the rank r of the original matrix A ≈ Q * R (as determined by rank_atol) is less then the minimum of the number of rows and columns, the cotangents ΔQ and ΔR, only the first r columns of Q and the first r rows of R are well-defined, and also the adjoint variables ΔQ and ΔR should have nonzero values only in the first r columns and rows respectively. If nonzero values in the remaining columns or rows exceed gauge_atol, a warning will be printed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.right_null","page":"Library","title":"MatrixAlgebraKit.right_null","text":"right_null(A; [alg], [trunc], kwargs...) -> Nᴴ\nright_null!(A, [Nᴴ], [alg]; [trunc], kwargs...) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel of the matrix A, i.e. the nullspace of A, such that A * Nᴴ' ≈ 0 and Nᴴ * Nᴴ' ≈ I.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of A, whereas trunc can optionally  be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nnote: Note\nHere notrunc has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional rows of A.\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:lq : Factorize via LQ nullspace, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        Nᴴ = lq_null(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument. It is roughly equivalent to:\n\n        _, S, Vᴴ = svd_full(A; kwargs...)\n        Nᴴ = truncate(right_null, (S, Vᴴ), trunc)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a RightNullAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with right_null_alg(alg).\n\n\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!) and right_orth(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_null!","page":"Library","title":"MatrixAlgebraKit.right_null!","text":"right_null(A; [alg], [trunc], kwargs...) -> Nᴴ\nright_null!(A, [Nᴴ], [alg]; [trunc], kwargs...) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel of the matrix A, i.e. the nullspace of A, such that A * Nᴴ' ≈ 0 and Nᴴ * Nᴴ' ≈ I.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of A, whereas trunc can optionally  be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nnote: Note\nHere notrunc has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional rows of A.\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:lq : Factorize via LQ nullspace, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        Nᴴ = lq_null(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument. It is roughly equivalent to:\n\n        _, S, Vᴴ = svd_full(A; kwargs...)\n        Nᴴ = truncate(right_null, (S, Vᴴ), trunc)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a RightNullAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with right_null_alg(alg).\n\n\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!) and right_orth(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}","page":"Library","title":"MatrixAlgebraKit.right_null_alg","text":"right_null_alg(alg::AbstractAlgorithm) -> RightNullAlgorithm\n\nConvert an algorithm to a RightNullAlgorithm wrapper for use with right_null.\n\nThis function attempts to deduce the appropriate factorization kind (:lq or :svd) from the algorithm type and wraps it in a RightNullAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.right_null_alg(alg::CustomAlgorithm) = RightNullAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also RightNullAlgorithm, right_null.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.right_orth","page":"Library","title":"MatrixAlgebraKit.right_orth","text":"right_orth(A; [alg], [trunc], kwargs...) -> C, Vᴴ\nright_orth!(A, [CVᴴ], [alg]; [trunc], kwargs...) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A factors as A = C * Vᴴ.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor A, whereas trunc can optionally be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will typicall be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:lq : Factorize via LQ decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        C, Vᴴ = lq_compact(A; kwargs...)\n\n:polar : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        C, Vᴴ = right_polar(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument, and is roughly equivalent to:\n\n        C, S, Vᴴ = svd_trunc(A; trunc, kwargs...)\n        C = rmul!(C, S)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a RightOrthAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with right_orth_alg.\n\n\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_null(!) and right_null(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_orth!","page":"Library","title":"MatrixAlgebraKit.right_orth!","text":"right_orth(A; [alg], [trunc], kwargs...) -> C, Vᴴ\nright_orth!(A, [CVᴴ], [alg]; [trunc], kwargs...) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A factors as A = C * Vᴴ.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor A, whereas trunc can optionally be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will typicall be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:lq : Factorize via LQ decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        C, Vᴴ = lq_compact(A; kwargs...)\n\n:polar : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        C, Vᴴ = right_polar(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument, and is roughly equivalent to:\n\n        C, S, Vᴴ = svd_trunc(A; trunc, kwargs...)\n        C = rmul!(C, S)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a RightOrthAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with right_orth_alg.\n\n\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_null(!) and right_null(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}","page":"Library","title":"MatrixAlgebraKit.right_orth_alg","text":"right_orth_alg(alg::AbstractAlgorithm) -> RightOrthAlgorithm\n\nConvert an algorithm to a RightOrthAlgorithm wrapper for use with right_orth.\n\nThis function attempts to deduce the appropriate factorization kind (:lq, :polar, or :svd) from the algorithm type and wraps it in a RightOrthAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.right_orth_alg(alg::CustomAlgorithm) = RightOrthAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also RightOrthAlgorithm, right_orth.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.right_polar","page":"Library","title":"MatrixAlgebraKit.right_polar","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar!","page":"Library","title":"MatrixAlgebraKit.right_polar!","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.right_polar_pullback!","text":"right_polar_pullback!(ΔA, A, PWᴴ, ΔPWᴴ)\n\nAdds the pullback from the left polar decomposition of A to ΔA given the output PWᴴ and cotangent ΔPWᴴ of right_polar(A).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.schur_full","page":"Library","title":"MatrixAlgebraKit.schur_full","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_full!","page":"Library","title":"MatrixAlgebraKit.schur_full!","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_vals","page":"Library","title":"MatrixAlgebraKit.schur_vals","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_vals!","page":"Library","title":"MatrixAlgebraKit.schur_vals!","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.select_algorithm","page":"Library","title":"MatrixAlgebraKit.select_algorithm","text":"MatrixAlgebraKit.select_algorithm(f, A, alg::AbstractAlgorithm)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Symbol; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Type; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, (; kwargs...))\n\nDecide on an algorithm to use for implementing the function f on inputs of type A. This can be obtained both for values A or types A.\n\nIf alg is an AbstractAlgorithm instance, it will be returned as-is.\n\nIf alg is a Symbol or a Type of algorithm, the return value is obtained by calling the corresponding algorithm constructor; keyword arguments in kwargs are passed along  to this constructor.\n\nIf alg is not specified (or nothing), an algorithm will be selected  automatically with MatrixAlgebraKit.default_algorithm and  the keyword arguments in kwargs will be passed to the algorithm constructor. Finally, the same behavior is obtained when the keyword arguments are passed as the third positional argument in the form of a NamedTuple. \n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.select_null_truncation","page":"Library","title":"MatrixAlgebraKit.select_null_truncation","text":"MatrixAlgebraKit.select_null_truncation(trunc)\n\nConstruct a TruncationStrategy from the given NamedTuple of keywords or input strategy, to implement a nullspace selection.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.select_truncation","page":"Library","title":"MatrixAlgebraKit.select_truncation","text":"MatrixAlgebraKit.select_truncation(trunc)\n\nConstruct a TruncationStrategy from the given NamedTuple of keywords or input strategy.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.sign_safe-Tuple{Real}","page":"Library","title":"MatrixAlgebraKit.sign_safe","text":"sign_safe(s::Number)\n\nCompute the sign of a number s, but return +1 if s is zero so that the result is always a number with modulus 1, i.e. an element of the unitary group U(1).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.svd_compact","page":"Library","title":"MatrixAlgebraKit.svd_compact","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_compact!","page":"Library","title":"MatrixAlgebraKit.svd_compact!","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_full","page":"Library","title":"MatrixAlgebraKit.svd_full","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_full!","page":"Library","title":"MatrixAlgebraKit.svd_full!","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_pullback!","page":"Library","title":"MatrixAlgebraKit.svd_pullback!","text":"svd_pullback!(\n    ΔA, A, USVᴴ, ΔUSVᴴ, [ind];\n    rank_atol::Real = default_pullback_rank_atol(USVᴴ[2]),\n    degeneracy_atol::Real = default_pullback_rank_atol(USVᴴ[2]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔUSVᴴ[1], ΔUSVᴴ[3])\n)\n\nAdds the pullback from the SVD of A to ΔA given the output USVᴴ of svd_compact or svd_full and the cotangent ΔUSVᴴ of svd_compact, svd_full or svd_trunc.\n\nIn particular, it is assumed that A ≈ U * S * Vᴴ, or thus, that no singular values with magnitude less than rank_atol are missing from S.  For the cotangents, an arbitrary number of singular vectors or singular values can be missing, i.e. for a matrix A with size (m, n), ΔU and ΔVᴴ can have sizes (m, pU) and (pV, n) respectively, whereas diagview(ΔS) can have length pS. In those cases, additionally ind is required to specify which singular vectors and values are present in ΔU, ΔS and ΔVᴴ.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of U' * ΔU + Vᴴ * ΔVᴴ', restricted to rows i and columns j for which abs(S[i] - S[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc","page":"Library","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(A; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' ≈ U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded singular values.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!), svd_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc!","page":"Library","title":"MatrixAlgebraKit.svd_trunc!","text":"svd_trunc(A; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' ≈ U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded singular values.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!), svd_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc_pullback!-Tuple{AbstractMatrix, Any, Any, Any}","page":"Library","title":"MatrixAlgebraKit.svd_trunc_pullback!","text":"svd_trunc_pullback!(\n    ΔA, A, USVᴴ, ΔUSVᴴ;\n    rank_atol::Real = default_pullback_rank_atol(USVᴴ[2]),\n    degeneracy_atol::Real = default_pullback_rank_atol(USVᴴ[2]),\n    gauge_atol::Real = default_pullback_gauge_atol(ΔUSVᴴ[1], ΔUSVᴴ[3])\n)\n\nAdds the pullback from the truncated SVD of A to ΔA, given the output USVᴴ and the cotangent ΔUSVᴴ of svd_trunc.\n\nIn particular, it is assumed that A * Vᴴ' ≈ U * S and U' * A = S * Vᴴ, with U and Vᴴ rectangular matrices of left and right singular vectors, and S diagonal. For the cotangents, it is assumed that if ΔU and ΔVᴴ are not zero, then they have the same size as U and Vᴴ (respectively), and if ΔS is not zero, then it is a diagonal matrix of the same size as S. For this method to work correctly, it is also assumed that the remaining singular values (not included in S) are (sufficiently) separated from those in S.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of U' * ΔU + Vᴴ * ΔVᴴ', restricted to rows i and columns j for which abs(S[i] - S[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.svd_vals","page":"Library","title":"MatrixAlgebraKit.svd_vals","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_vals!","page":"Library","title":"MatrixAlgebraKit.svd_vals!","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncate","page":"Library","title":"MatrixAlgebraKit.truncate","text":"truncate(::typeof(f), F, strategy::TruncationStrategy) -> F′, ind\n\nGiven a factorization function f and truncation strategy, truncate the factors F such that the rows or columns at the indices ind are kept.\n\nSee also findtruncated and findtruncated_svd for determining the indices.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncation_error","page":"Library","title":"MatrixAlgebraKit.truncation_error","text":"truncation_error(values, ind)\n\nCompute the truncation error as the 2-norm of the values that are not kept by ind.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncation_error!","page":"Library","title":"MatrixAlgebraKit.truncation_error!","text":"truncation_error(values, ind)\n\nCompute the truncation error as the 2-norm of the values that are not kept by ind.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncerror-Tuple{}","page":"Library","title":"MatrixAlgebraKit.truncerror","text":"truncerror(; atol::Real=0, rtol::Real=0, p::Real=2)\n\nTruncation strategy for truncating values such that the error in the factorization is smaller than max(atol, rtol * norm), where the error is determined using the p-norm.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.truncfilter-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.truncfilter","text":"truncfilter(filter)\n\nTruncation strategy to keep the values for which filter returns true.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.truncrank-Tuple{Integer}","page":"Library","title":"MatrixAlgebraKit.truncrank","text":"truncrank(howmany::Integer; by=abs, rev::Bool=true)\n\nTruncation strategy to keep the first howmany values when sorted according to by or the last howmany if rev is true.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.trunctol-Tuple{}","page":"Library","title":"MatrixAlgebraKit.trunctol","text":"trunctol(; atol::Real=0, rtol::Real=0, p::Real=2, by=abs, keep_below::Bool=false)\n\nTruncation strategy to keep the values that satisfy by(val) > max(atol, rtol * norm(values, p). If keep_below = true, discard these values instead.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.@algdef-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.@algdef","text":"@algdef AlgorithmName\n\nConvenience macro to define an algorithm AlgorithmName that accepts generic keywords. This defines an exported alias for Algorithm{:AlgorithmName} along with some utility methods.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@check_scalar","page":"Library","title":"MatrixAlgebraKit.@check_scalar","text":"@check_scalar(x, y, [op], [eltype])\n\nCheck if eltype(x) == op(eltype(y)) and throw an error if not. By default op = identity and `eltype = eltype'.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@check_size","page":"Library","title":"MatrixAlgebraKit.@check_size","text":"@check_size(x, sz, [size])\n\nCheck if size(x) == sz and throw an error if not. By default, size = size.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@functiondef-Tuple","page":"Library","title":"MatrixAlgebraKit.@functiondef","text":"@functiondef [n_args=1] f\n\nConvenience macro to define the boilerplate code that dispatches between several versions of f and f!. By default, f accepts a single argument A.  This enables the following signatures to be defined in terms of the final f!(A, out, alg::Algorithm).\n\n    f(A; kwargs...)\n    f(A, alg::Algorithm)\n    f!(A, [out]; kwargs...)\n    f!(A, alg::Algorithm)\n\nThe number of inputs can be set with the n_args keyword argument, so that \n\n@functiondef n_args=2 f\n\nwould create \n\n    f(A, B; kwargs...)\n    f(A, B, alg::Algorithm)\n    f!(A, B, [out]; kwargs...)\n    f!(A, B, alg::Algorithm)\n\nSee also copy_input, select_algorithm and initialize_output.\n\n\n\n\n\n","category":"macro"},{"location":"dev_interface/#Developer-Interface","page":"Developer Interface","title":"Developer Interface","text":"MatrixAlgebraKit.jl provides a developer interface for specifying custom algorithm backends and selecting default algorithms.","category":"section"},{"location":"dev_interface/#MatrixAlgebraKit.default_algorithm-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.default_algorithm","text":"MatrixAlgebraKit.default_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.default_algorithm(f, ::Type{TA}; kwargs...) where {TA}\n\nSelect the default algorithm for a given factorization function f and input A. In general, this is called by select_algorithm if no algorithm is specified explicitly. New types should prefer to register their default algorithms in the type domain.\n\n\n\n\n\n","category":"function"},{"location":"dev_interface/#MatrixAlgebraKit.select_algorithm-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.select_algorithm","text":"MatrixAlgebraKit.select_algorithm(f, A, alg::AbstractAlgorithm)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Symbol; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, alg::Type; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A; kwargs...)\nMatrixAlgebraKit.select_algorithm(f, A, (; kwargs...))\n\nDecide on an algorithm to use for implementing the function f on inputs of type A. This can be obtained both for values A or types A.\n\nIf alg is an AbstractAlgorithm instance, it will be returned as-is.\n\nIf alg is a Symbol or a Type of algorithm, the return value is obtained by calling the corresponding algorithm constructor; keyword arguments in kwargs are passed along  to this constructor.\n\nIf alg is not specified (or nothing), an algorithm will be selected  automatically with MatrixAlgebraKit.default_algorithm and  the keyword arguments in kwargs will be passed to the algorithm constructor. Finally, the same behavior is obtained when the keyword arguments are passed as the third positional argument in the form of a NamedTuple. \n\n\n\n\n\n","category":"function"},{"location":"dev_interface/#MatrixAlgebraKit.findtruncated-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.findtruncated","text":"MatrixAlgebraKit.findtruncated(values::AbstractVector, strategy::TruncationStrategy)\n\nGeneric interface for finding truncated values of the spectrum of a decomposition based on the strategy. The output should be a collection of indices specifying which values to keep. MatrixAlgebraKit.findtruncated is used inside of the default implementation of truncate to perform the truncation. It does not assume that the values are sorted. For a version that assumes the values are reverse sorted (which is the standard case for SVD) see MatrixAlgebraKit.findtruncated_svd.\n\n\n\n\n\n","category":"function"},{"location":"dev_interface/#MatrixAlgebraKit.findtruncated_svd-dev_interface","page":"Developer Interface","title":"MatrixAlgebraKit.findtruncated_svd","text":"MatrixAlgebraKit.findtruncated_svd(values::AbstractVector, strategy::TruncationStrategy)\n\nLike MatrixAlgebraKit.findtruncated but assumes that the values are real and sorted in descending order, as typically obtained by the SVD. This assumption is not checked, and this is used in the default implementation of svd_trunc!.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/compositions/#Compositions","page":"Compositions","title":"Compositions","text":"Coming soon...","category":"section"},{"location":"user_interface/truncations/#Truncations","page":"Truncations","title":"Truncations","text":"Truncation strategies allow you to control which eigenvalues or singular values to keep when computing partial or truncated decompositions. These strategies are used in the functions eigh_trunc, eig_trunc, and svd_trunc to reduce the size of the decomposition while retaining the most important information.","category":"section"},{"location":"user_interface/truncations/#Using-Truncations-in-Decompositions","page":"Truncations","title":"Using Truncations in Decompositions","text":"Truncation strategies can be used with truncated decomposition functions in two ways, as illustrated below. For concreteness, we use the following matrix as an example:\n\nusing MatrixAlgebraKit\nusing MatrixAlgebraKit: diagview\n\nA = [2 1 0; 1 3 1; 0 1 4];\nD, V = eigh_full(A);\ndiagview(D) ≈ [3 - √3, 3, 3 + √3]","category":"section"},{"location":"user_interface/truncations/#1.-Using-the-trunc-keyword-with-a-NamedTuple","page":"Truncations","title":"1. Using the trunc keyword with a NamedTuple","text":"The simplest approach is to pass a NamedTuple with the truncation parameters. For example, keeping only the largest 2 eigenvalues:\n\nDtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = (maxrank = 2,));\nsize(Dtrunc, 1) <= 2\n\nNote however that there are no guarantees on the order of the output values:\n\ndiagview(Dtrunc) ≈ diagview(D)[[3, 2]]\n\nYou can also use tolerance-based truncation or combine multiple criteria:\n\nDtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = (atol = 2.9,));\nall(>(2.9), diagview(Dtrunc))\n\nDtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = (maxrank = 2, atol = 2.9));\nsize(Dtrunc, 1) <= 2 && all(>(2.9), diagview(Dtrunc))\n\nIn general, the keyword arguments that are supported can be found in the TruncationStrategy docstring:","category":"section"},{"location":"user_interface/truncations/#2.-Using-explicit-TruncationStrategy-objects","page":"Truncations","title":"2. Using explicit TruncationStrategy objects","text":"For more control, you can construct TruncationStrategy objects directly. This is also what the previous syntax will end up calling.\n\nDtrunc, Vtrunc = eigh_trunc(A; trunc = truncrank(2))\nsize(Dtrunc, 1) <= 2\n\nDtrunc, Vtrunc, ϵ = eigh_trunc(A; trunc = truncrank(2) & trunctol(; atol = 2.9))\nsize(Dtrunc, 1) <= 2 && all(>(2.9), diagview(Dtrunc))","category":"section"},{"location":"user_interface/truncations/#Truncation-Strategies","page":"Truncations","title":"Truncation Strategies","text":"MatrixAlgebraKit provides several built-in truncation strategies:\n\nTruncation strategies can be combined using the & operator to create intersection-based truncation. When strategies are combined, only the values that satisfy all conditions are kept.\n\ncombined_trunc = truncrank(10) & trunctol(; atol = 1e-6);","category":"section"},{"location":"user_interface/truncations/#Truncation-Error","page":"Truncations","title":"Truncation Error","text":"When using truncated decompositions such as svd_trunc, eig_trunc, or eigh_trunc, an additional truncation error value is returned. This error is defined as the 2-norm of the discarded  singular values or eigenvalues, providing a measure of the approximation quality. For svd_trunc and eigh_trunc, this corresponds to the 2-norm difference between the original and the truncated matrix. For the case of eig_trunc, this interpretation does not hold because the norm of the non-unitary matrix of eigenvectors and its inverse also influence the approximation quality.\n\nFor example:\n\nusing LinearAlgebra: norm\nU, S, Vᴴ, ϵ = svd_trunc(A; trunc=truncrank(2))\nnorm(A - U * S * Vᴴ) ≈ ϵ # ϵ is the 2-norm of the discarded singular values","category":"section"},{"location":"user_interface/truncations/#Truncation-with-SVD-vs-Eigenvalue-Decompositions","page":"Truncations","title":"Truncation with SVD vs Eigenvalue Decompositions","text":"When using truncations with different decomposition types, keep in mind:\n\nsvd_trunc: Singular values are always real and non-negative, sorted in descending order. Truncation by value typically keeps the largest singular values. The truncation error gives the 2-norm difference between the original and the truncated matrix.\neigh_trunc: Eigenvalues are real but can be negative for symmetric matrices. By default, eigenvalues are treated by absolute value, e.g. truncrank(k) keeps the k eigenvalues with largest magnitude (positive or negative). The truncation error gives the 2-norm difference between the original and the truncated matrix.\neig_trunc: For general (non-symmetric) matrices, eigenvalues can be complex. By default, eigenvalues are treated by absolute value. The truncation error gives an indication of the magnitude of discarded values, but is not directly related to the 2-norm difference between the original and the truncated matrix.","category":"section"},{"location":"user_interface/truncations/#MatrixAlgebraKit.TruncationStrategy-Tuple{}-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.TruncationStrategy","text":"TruncationStrategy(; kwargs...)\n\nSelect a truncation strategy based on the provided keyword arguments.\n\nKeyword arguments\n\nThe following keyword arguments are all optional, and their default value (nothing) will be ignored. It is also allowed to combine multiple of these, in which case the kept values will consist of the intersection of the different truncated strategies.\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\n\n\n\n\n","category":"method"},{"location":"user_interface/truncations/#MatrixAlgebraKit.notrunc-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.notrunc","text":"notrunc()\n\nTruncation strategy that does nothing, and keeps all the values.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncrank-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncrank","text":"truncrank(howmany::Integer; by=abs, rev::Bool=true)\n\nTruncation strategy to keep the first howmany values when sorted according to by or the last howmany if rev is true.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.trunctol-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.trunctol","text":"trunctol(; atol::Real=0, rtol::Real=0, p::Real=2, by=abs, keep_below::Bool=false)\n\nTruncation strategy to keep the values that satisfy by(val) > max(atol, rtol * norm(values, p). If keep_below = true, discard these values instead.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncfilter-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncfilter","text":"truncfilter(filter)\n\nTruncation strategy to keep the values for which filter returns true.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncerror-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncerror","text":"truncerror(; atol::Real=0, rtol::Real=0, p::Real=2)\n\nTruncation strategy for truncating values such that the error in the factorization is smaller than max(atol, rtol * norm), where the error is determined using the p-norm.\n\n\n\n\n\n","category":"function"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"changelog/#Guidelines-for-updating-this-changelog","page":"Changelog","title":"Guidelines for updating this changelog","text":"When making changes to this project, please update the \"Unreleased\" section with your changes under the appropriate category:\n\nAdded for new features.\nChanged for changes in existing functionality.\nDeprecated for soon-to-be removed features.\nRemoved for now removed features.\nFixed for any bug fixes.\nSecurity in case of vulnerabilities.\n\nWhen releasing a new version, move the \"Unreleased\" changes to a new version section with the release date.\n\n[Unreleased]: https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/compare/v0.6.0...HEAD [0.6.0]: https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/releases/tag/v0.6.0","category":"section"},{"location":"changelog/#[Unreleased]","page":"Changelog","title":"[Unreleased]","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/#Deprecated","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/#Removed","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/#Security","page":"Changelog","title":"Security","text":"","category":"section"},{"location":"changelog/#[0.6.0]-2025-11-14","page":"Changelog","title":"[0.6.0] - 2025-11-14","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"New project_isometric function for projecting matrices onto isometric manifold (#67)\nNew PolarNewton algorithm for polar decomposition (#67)\nNew matrix property functions: ishermitian, isantihermitian, hermitianpart!, hermitianpart, antihermitianpart!, and antihermitianpart (#64)\nSupport for BigFloat via new GenericLinearAlgebra extension (#87)\nMooncake reverse-mode AD rules (#85)\nGPU support for image and null space computations (#82)\nGPU support for polar decomposition (#83)\nGPU support for new projection operations (#81)\nOutput truncation error for truncated decompositions (#75)\nDocumentation for truncated decomposition keyword arguments (#71)\nDefault algorithm implementations for GPU wrapper array types (#49)","category":"section"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"Made gaugefix! optional (#95)\nRenamed isisometry to isisometric for consistency with project_isometric (#73)\nRefactored left_orth, right_orth, left_null and right_null interface (#79)\nImproved GPU support for SVD operations (#80)\nLoosened strictness on hermitian checks (#78)\nUpdated pullback tolerances (#92)","category":"section"},{"location":"changelog/#Removed-2","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"user_interface/decompositions/#Decompositions","page":"Decompositions","title":"Decompositions","text":"A rather large class of matrix algebra methods consists of taking a single input A, and determining some factorization of that input. In order to streamline these functions, they all follow a similar common code pattern. For a given factorization f, this consists of the following methods:\n\nf(A; kwargs...) -> F...\nf!(A, [F]; kwargs...) -> F...\n\nHere, the input matrix is always the first argument, and optionally the output can be provided as well. The keywords are algorithm-specific, and can be used to influence the behavior of the algorithms. Importantly, for generic code patterns it is recommended to always use the output F explicitly, since some implementations may not be able to reuse the provided memory. Additionally, the f! method typically assumes that it is allowed to destroy the input A, and making use of the contents of A afterwards should be deemed as undefined behavior.","category":"section"},{"location":"user_interface/decompositions/#QR-and-LQ-Decompositions","page":"Decompositions","title":"QR and LQ Decompositions","text":"The QR decomposition transforms a matrix A into a product Q * R, where Q is orthonormal and R upper triangular. This is often used to solve linear least squares problems, or construct orthogonal bases, since it is typically less expensive than the Singular Value Decomposition. If the input A is invertible, Q and R are unique if we require the diagonal elements of R to be positive.\n\nFor rectangular matrices A of size (m, n), there are two modes of operation, qr_full and qr_compact. The former ensures that the resulting Q is a square unitary matrix of size (m, m), while the latter creates an isometric Q of size (m, min(m, n)).\n\nSimilarly, the LQ decomposition transforms a matrix A into a product L * Q, where L is lower triangular and Q orthonormal. This is equivalent to the transpose of the QR decomposition of the transpose matrix, but can be computed directly. Again there are two modes of operation, lq_full and lq_compact, with the same behavior as the QR decomposition.\n\nAlongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithm:","category":"section"},{"location":"user_interface/decompositions/#Eigenvalue-Decomposition","page":"Decompositions","title":"Eigenvalue Decomposition","text":"The Eigenvalue Decomposition transforms a square matrix A into a product V * D * V⁻¹. Equivalently, it finds V and D that satisfy A * V = V * D.\n\nNot all matrices can be diagonalized, and some real matrices can only be diagonalized using complex arithmetic. In particular, the resulting decomposition can only guaranteed to be real for real symmetric inputs A. Therefore, we provide eig_ and eigh_ variants, where eig always results in complex-valued V and D, while eigh requires symmetric inputs but retains the scalartype of the input.\n\nThe full set of eigenvalues and eigenvectors can be computed using the eig_full and eigh_full functions. If only the eigenvalues are required, the eig_vals and eigh_vals functions can be used. These functions return the diagonal elements of D in a vector.\n\nFinally, it is also possible to compute a partial or truncated eigenvalue decomposition, using the eig_trunc and eigh_trunc functions. To control the behavior of the truncation, we refer to Truncations for more information.","category":"section"},{"location":"user_interface/decompositions/#Symmetric-Eigenvalue-Decomposition","page":"Decompositions","title":"Symmetric Eigenvalue Decomposition","text":"For symmetric matrices, we provide the following functions:\n\nnote: Gauge Degrees of Freedom\nThe eigenvectors returned by these functions have residual phase degrees of freedom. By default, MatrixAlgebraKit applies a gauge fixing convention to ensure reproducible results. See Gauge choices for more details.\n\nAlongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:","category":"section"},{"location":"user_interface/decompositions/#Eigenvalue-Decomposition-2","page":"Decompositions","title":"Eigenvalue Decomposition","text":"For general matrices, we provide the following functions:\n\nnote: Gauge Degrees of Freedom\nThe eigenvectors returned by these functions have residual phase degrees of freedom. By default, MatrixAlgebraKit applies a gauge fixing convention to ensure reproducible results. See Gauge choices for more details.\n\nAlongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:","category":"section"},{"location":"user_interface/decompositions/#Schur-Decomposition","page":"Decompositions","title":"Schur Decomposition","text":"The Schur decomposition transforms a complex square matrix A into a product Q * T * Qᴴ, where Q is unitary and T is upper triangular. It rewrites an arbitrary complex square matrix as unitarily similar to an upper triangular matrix whose diagonal elements are the eigenvalues of A. For real matrices, the same decomposition can be achieved in real arithmetic by allowing T to be quasi-upper triangular, i.e. triangular with blocks of size (1, 1) and (2, 2) on the diagonal.\n\nThis decomposition is also useful for computing the eigenvalues of a matrix, which is exposed through the schur_vals function.\n\nThe LAPACK-based implementation for dense arrays is provided by the following algorithms:","category":"section"},{"location":"user_interface/decompositions/#Singular-Value-Decomposition","page":"Decompositions","title":"Singular Value Decomposition","text":"The Singular Value Decomposition transforms a matrix A into a product U * Σ * Vᴴ, where U and Vᴴ are unitary, and Σ is diagonal, real and non-negative. For a square matrix A, both U and Vᴴ are unitary, and if the singular values are distinct, the decomposition is unique.\n\nFor rectangular matrices A of size (m, n), there are two modes of operation, svd_full and svd_compact. The former ensures that the resulting U, and Vᴴ remain square unitary matrices, of size (m, m) and (n, n), with rectangular Σ of size (m, n). The latter creates an isometric U of size (m, min(m, n)), and V = (Vᴴ)' of size (n, min(m, n)), with a square Σ of size (min(m, n), min(m, n)).\n\nIt is also possible to compute the singular values only, using the svd_vals function. This then returns a vector of the values on the diagonal of Σ.\n\nFinally, we also support computing a partial or truncated SVD, using the svd_trunc function.\n\nnote: Gauge Degrees of Freedom\nThe singular vectors returned by these functions have residual phase degrees of freedom. By default, MatrixAlgebraKit applies a gauge fixing convention to ensure reproducible results. See Gauge choices for more details.\n\nMatrixAlgebraKit again ships with LAPACK-based implementations for dense arrays:","category":"section"},{"location":"user_interface/decompositions/#Polar-Decomposition","page":"Decompositions","title":"Polar Decomposition","text":"The Polar Decomposition of a matrix A is a factorization A = W * P, where W is unitary and P is positive semi-definite. If A is invertible (and therefore square), the polar decomposition always exists and is unique. For non-square matrices A of size (m, n), the decomposition A = W * P with P positive semi-definite of size (n, n) and W isometric of size (m, n) exists only if m >= n, and is unique if A and thus P is full rank. For m <= n, we can analoguously decompose A as A = P * Wᴴ with P positive semi-definite of size (m, m) and Wᴴ of size (m, n) such that W = (Wᴴ)' is isometric. Only in the case m = n do both decompositions exist.\n\nThe decompositions A = W * P or A = P * Wᴴ can be computed with the left_polar and right_polar functions, respectively.\n\nThese functions can be implemented by first computing a singular value decomposition, and then constructing the polar decomposition from the singular values and vectors. Alternatively, the polar decomposition can be computed using an  iterative method based on Newton's method, that can be more efficient for large matrices, especially if they are close to being isometric already.","category":"section"},{"location":"user_interface/decompositions/#Orthogonal-Subspaces","page":"Decompositions","title":"Orthogonal Subspaces","text":"Often it is useful to compute orthogonal bases for particular subspaces defined by a matrix. Given a matrix A, we can compute an orthonormal basis for its image or coimage, and factorize the matrix accordingly. These bases are accessible through left_orth and right_orth respectively.","category":"section"},{"location":"user_interface/decompositions/#Overview","page":"Decompositions","title":"Overview","text":"The left_orth function computes an orthonormal basis V for the image (column space) of A, along with a corestriction matrix C such that A = V * C. The resulting V has orthonormal columns (V' * V ≈ I or isisometric(V)).\n\nSimilarly, right_orth computes an orthonormal basis for the coimage (row space) of A, i.e., the image of A'. It returns matrices C and Vᴴ such that A = C * Vᴴ, where V = (Vᴴ)' has orthonormal columns (isisometric(Vᴴ; side = :right)).\n\nThese functions serve as high-level interfaces that automatically select the most appropriate decomposition based on the specified options, making them convenient for users who want orthonormalization without worrying about the underlying implementation details.","category":"section"},{"location":"user_interface/decompositions/#Algorithm-Selection","page":"Decompositions","title":"Algorithm Selection","text":"Both functions support multiple decomposition drivers, which can be selected through the alg keyword argument:\n\nFor left_orth:\n\nalg = :qr (default without truncation): Uses QR decomposition via qr_compact\nalg = :polar: Uses polar decomposition via left_polar\nalg = :svd (default with truncation): Uses SVD via svd_compact or svd_trunc\n\nFor right_orth:\n\nalg = :lq (default without truncation): Uses LQ decomposition via lq_compact\nalg = :polar: Uses polar decomposition via right_polar\nalg = :svd (default with truncation): Uses SVD via svd_compact or svd_trunc\n\nWhen alg is not specified, the function automatically selects :qr/:lq for exact orthogonalization, or :svd when a truncation strategy is provided.","category":"section"},{"location":"user_interface/decompositions/#Extending-with-Custom-Algorithms","page":"Decompositions","title":"Extending with Custom Algorithms","text":"To register a custom algorithm type for use with these functions, you need to define the appropriate conversion function, for example:\n\n# For left_orth\nMatrixAlgebraKit.left_orth_alg(alg::MyCustomAlgorithm) = LeftOrthAlgorithm{:qr}(alg)\n\n# For right_orth\nMatrixAlgebraKit.right_orth_alg(alg::MyCustomAlgorithm) = RightOrthAlgorithm{:lq}(alg)\n\nThe type parameter (:qr, :lq, :polar, or :svd) indicates which factorization backend will be used. The wrapper algorithm types handle the dispatch to the appropriate implementation:","category":"section"},{"location":"user_interface/decompositions/#Examples","page":"Decompositions","title":"Examples","text":"Basic orthogonalization:\n\nusing MatrixAlgebraKit\nusing LinearAlgebra\n\nA = [1.0 2.0; 3.0 4.0; 5.0 6.0]\nV, C = left_orth(A)\n(V' * V) ≈ I && A ≈ V * C\n\nUsing different algorithms:\n\nA = randn(4, 3)\nV1, C1 = left_orth(A; alg = :qr)\nV2, C2 = left_orth(A; alg = :polar)\nV3, C3 = left_orth(A; alg = :svd)\nA ≈ V1 * C1 ≈ V2 * C2 ≈ V3 * C3\n\nWith truncation:\n\nA = [1.0 0.0; 0.0 1e-10; 0.0 0.0]\nV, C = left_orth(A; trunc = (atol = 1e-8,))\nsize(V, 2) == 1  # Only one column retained","category":"section"},{"location":"user_interface/decompositions/#Null-Spaces","page":"Decompositions","title":"Null Spaces","text":"Similarly, it can be convenient to obtain an orthogonal basis for the kernel or cokernel of a matrix. These are the orthogonal complements of the coimage and image, respectively, and can be computed using the left_null and right_null functions.","category":"section"},{"location":"user_interface/decompositions/#Overview-2","page":"Decompositions","title":"Overview","text":"The left_null function computes an orthonormal basis N for the cokernel (left nullspace) of A, which is the nullspace of A'. This means A' * N ≈ 0 and N' * N ≈ I.\n\nSimilarly, right_null computes an orthonormal basis for the kernel (right nullspace) of A. It returns Nᴴ such that A * Nᴴ' ≈ 0 and Nᴴ * Nᴴ' ≈ I, where N = (Nᴴ)' has orthonormal columns.\n\nThese functions automatically handle rank determination and provide convenient access to nullspace computation without requiring detailed knowledge of the underlying decomposition methods.","category":"section"},{"location":"user_interface/decompositions/#Algorithm-Selection-2","page":"Decompositions","title":"Algorithm Selection","text":"Both functions support multiple decomposition drivers, which can be selected through the alg keyword argument:\n\nFor left_null:\n\nalg = :qr (default without truncation): Uses QR-based nullspace computation via qr_null\nalg = :svd (default with truncation): Uses SVD via svd_full with appropriate truncation\n\nFor right_null:\n\nalg = :lq (default without truncation): Uses LQ-based nullspace computation via lq_null\nalg = :svd (default with truncation): Uses SVD via svd_full with appropriate truncation\n\nWhen alg is not specified, the function automatically selects :qr/:lq for exact nullspace computation, or :svd when a truncation strategy is provided to handle numerical rank determination.\n\nnote: Note\nFor nullspace functions, notrunc has special meaning when used with the default QR/LQ algorithms. It indicates that the nullspace should be computed from the exact zeros determined by the additional rows/columns of the extended matrix, without any tolerance-based truncation.","category":"section"},{"location":"user_interface/decompositions/#Extending-with-Custom-Algorithms-2","page":"Decompositions","title":"Extending with Custom Algorithms","text":"To register a custom algorithm type for use with these functions, you need to define the appropriate conversion function:\n\n# For left_null\nMatrixAlgebraKit.left_null_alg(alg::MyCustomAlgorithm) = LeftNullAlgorithm{:qr}(alg)\n\n# For right_null\nMatrixAlgebraKit.right_null_alg(alg::MyCustomAlgorithm) = RightNullAlgorithm{:lq}(alg)\n\nThe type parameter (:qr, :lq, or :svd) indicates which factorization backend will be used. The wrapper algorithm types handle the dispatch to the appropriate implementation:","category":"section"},{"location":"user_interface/decompositions/#Examples-2","page":"Decompositions","title":"Examples","text":"Basic nullspace computation:\n\nA = [1.0 2.0 3.0; 4.0 5.0 6.0]  # Rank 2 matrix\nN = left_null(A)\nsize(N) == (2, 0)\n\nNᴴ = right_null(A)\nsize(Nᴴ) == (1, 3) && norm(A * Nᴴ') < 1e-14 && isisometric(Nᴴ; side = :right)\n\nComputing nullspace with rank detection:\n\nA = [1.0 2.0; 2.0 4.0; 3.0 6.0]  # Rank 1 matrix (second column = 2*first)\nN = left_null(A; alg = :svd, trunc = (atol = 1e-10,))\nsize(N) == (3, 2) && norm(A' * N) < 1e-12 && isisometric(N)\n\nUsing different algorithms:\n\nA = [1.0 0.0 0.0; 0.0 1.0 0.0]\nN1 = right_null(A; alg = :lq)\nN2 = right_null(A; alg = :svd)\nnorm(A * N1') < 1e-14 && norm(A * N2') < 1e-14 &&\n    isisometric(N1; side = :right) && isisometric(N2; side = :right)","category":"section"},{"location":"user_interface/decompositions/#sec_gaugefix","page":"Decompositions","title":"Gauge choices","text":"Both eigenvalue and singular value decompositions have residual gauge degrees of freedom even when the eigenvalues or singular values are unique. These arise from the fact that even after normalization, the eigenvectors and singular vectors are only determined up to a phase factor.","category":"section"},{"location":"user_interface/decompositions/#Phase-Ambiguity-in-Decompositions","page":"Decompositions","title":"Phase Ambiguity in Decompositions","text":"For the eigenvalue decomposition A * V = V * D, if v is an eigenvector with eigenvalue λ and |v| = 1, then so is e^(iθ) * v for any real phase θ. When λ is non-degenerate (i.e., has multiplicity 1), the eigenvector is unique up to this phase.\n\nSimilarly, for the singular value decomposition A = U * Σ * Vᴴ, the singular vectors u and v corresponding to a non-degenerate singular value σ are unique only up to a common phase. We can replace u → e^(iθ) * u and vᴴ → e^(-iθ) * vᴴ simultaneously.","category":"section"},{"location":"user_interface/decompositions/#Gauge-Fixing-Convention","page":"Decompositions","title":"Gauge Fixing Convention","text":"To remove this phase ambiguity and ensure reproducible results, MatrixAlgebraKit implements a gauge fixing convention by default. The convention ensures that the entry with the largest magnitude in each eigenvector or left singular vector is real and positive.\n\nFor eigenvectors, this means that for each column v of V, we multiply by conj(sign(v[i])) where i is the index of the entry with largest absolute value.\n\nFor singular vectors, we apply the phase factor to both u and v based on the entry with largest magnitude in u. This preserves the decomposition A = U * Σ * Vᴴ while fixing the gauge.","category":"section"},{"location":"user_interface/decompositions/#Disabling-Gauge-Fixing","page":"Decompositions","title":"Disabling Gauge Fixing","text":"Gauge fixing is enabled by default for all eigenvalue and singular value decompositions. If you prefer to obtain the raw results from the underlying computational routines without gauge fixing, you can disable it using the fixgauge keyword argument:\n\n# With gauge fixing (default)\nD, V = eigh_full(A)\n\n# Without gauge fixing\nD, V = eigh_full(A; fixgauge = false)\n\nThe same keyword is available for eig_full, eig_trunc, svd_full, svd_compact, and svd_trunc functions. Additionally, the default value can also be controlled with a global toggle using MatrixAlgebraKit.default_fixgauge.","category":"section"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.qr_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.qr_full","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.qr_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.qr_compact","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.lq_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.lq_full","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.lq_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.lq_compact","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_HouseholderQR","text":"LAPACK_HouseholderQR(; blocksize, positive = false, pivoted = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  ?geqrt will be chosen if blocksize > 1. With blocksize == 1, ?geqrf will be chosen if pivoted == false and ?geqp3 will be chosen if pivoted == true. The keyword positive = true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_HouseholderLQ","text":"LAPACK_HouseholderLQ(; blocksize, positive = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. ?gelqt will be chosen if blocksize > 1 or ?gelqf will be chosen if blocksize == 1. The keyword positive = true can be used to ensure that the diagonal elements of L are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_full","text":"eigh_full(A; kwargs...) -> D, V, ϵ\neigh_full(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_full!(A, [DV]; kwargs...) -> D, V, ϵ\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neigh_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the discarded eigenvalues.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!), eigh_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_vals","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same eltype as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by eig_full and its variants should be used instead.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","text":"LAPACK_MultipleRelativelyRobustRepresentations(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_full","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_trunc","text":"eig_trunc(A; [trunc], kwargs...) -> D, V, ϵ\neig_trunc(A, alg::AbstractAlgorithm) -> D, V, ϵ\neig_trunc!(A, [DV]; [trunc], kwargs...) -> D, V, ϵ\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V, ϵ\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded eigenvalues.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword Arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!), eig_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_vals","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert(; fixgauge::Bool = true)\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple(; fixgauge::Bool = true)\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.schur_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.schur_full","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.schur_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.schur_vals","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert(; fixgauge::Bool = true)\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple(; fixgauge::Bool = true)\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigenvectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_full","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_compact","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_vals","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(A; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -> U, S, Vᴴ, ϵ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ, ϵ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' ≈ U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nThe function also returns ϵ, the truncation error defined as the 2-norm of the  discarded singular values.\n\nTruncation\n\nThe truncation strategy can be controlled via the trunc keyword argument. This can be either a NamedTuple or a TruncationStrategy. If trunc is not provided or nothing, all values will be kept.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nOther keyword arguments are passed to the algorithm selection procedure. If no explicit alg is provided, these keywords are used to select and configure the algorithm through MatrixAlgebraKit.select_algorithm. The remaining keywords after algorithm selection are passed to the algorithm constructor. See MatrixAlgebraKit.default_algorithm for the default algorithm selection behavior.\n\nWhen alg is a TruncatedAlgorithm, the trunc keyword cannot be specified as the truncation strategy is already embedded in the algorithm.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!), svd_vals(!), and Truncations for more information on truncation strategies.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Jacobi","text":"LAPACK_Jacobi(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration(; fixgauge::Bool = true)\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm. The fixgauge keyword can be used to toggle whether or not to fix the gauge of the eigen or singular vectors, see also gaugefix!.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_polar-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_polar","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_polar-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_polar","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.PolarViaSVD","text":"PolarViaSVD(svd_alg)\n\nAlgorithm for computing the polar decomposition of a matrix A via the singular value decomposition (SVD) of A. The svd_alg argument specifies the SVD algorithm to use.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.PolarNewton-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.PolarNewton","text":"PolarNewton(; maxiter = 10, tol = defaulttol(A))\n\nAlgorithm for computing the polar decomposition of a matrix A via scaled Newton iteration, with a maximum of maxiter iterations and until convergence up to tolerance tol.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_orth-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_orth","text":"left_orth(A; [alg], [trunc], kwargs...) -> V, C\nleft_orth!(A, [VC], [alg]; [trunc], kwargs...) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A, as well as a  matrix C (the corestriction) such that A factors as A = V * C.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor A, whereas trunc can optionally be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will typically be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:qr : Factorize via QR decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        V, C = qr_compact(A; kwargs...)\n\n:polar : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        V, C = left_polar(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument, and is roughly equivalent to:\n\n        V, S, C = svd_trunc(A; trunc, kwargs...)\n        C = lmul!(S, C)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a LeftOrthAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with left_orth_alg(alg).\n\n\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_null(!) and right_null(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_orth-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_orth","text":"right_orth(A; [alg], [trunc], kwargs...) -> C, Vᴴ\nright_orth!(A, [CVᴴ], [alg]; [trunc], kwargs...) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A factors as A = C * Vᴴ.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor A, whereas trunc can optionally be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real      : Absolute tolerance for the truncation\nrtol::Real      : Relative tolerance for the truncation\nmaxrank::Real   : Maximal rank for the truncation\nmaxerror::Real  : Maximal truncation error.\nfilter          : Custom filter to select truncated values.\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will typicall be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:lq : Factorize via LQ decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        C, Vᴴ = lq_compact(A; kwargs...)\n\n:polar : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        C, Vᴴ = right_polar(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument, and is roughly equivalent to:\n\n        C, S, Vᴴ = svd_trunc(A; trunc, kwargs...)\n        C = rmul!(C, S)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a RightOrthAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with right_orth_alg.\n\n\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_null(!) and right_null(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_orth_alg-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_orth_alg","text":"left_orth_alg(alg::AbstractAlgorithm) -> LeftOrthAlgorithm\n\nConvert an algorithm to a LeftOrthAlgorithm wrapper for use with left_orth.\n\nThis function attempts to deduce the appropriate factorization kind (:qr, :polar, or :svd) from the algorithm type and wraps it in a LeftOrthAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.left_orth_alg(alg::CustomAlgorithm) = LeftOrthAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also LeftOrthAlgorithm, left_orth.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_orth_alg-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_orth_alg","text":"right_orth_alg(alg::AbstractAlgorithm) -> RightOrthAlgorithm\n\nConvert an algorithm to a RightOrthAlgorithm wrapper for use with right_orth.\n\nThis function attempts to deduce the appropriate factorization kind (:lq, :polar, or :svd) from the algorithm type and wraps it in a RightOrthAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.right_orth_alg(alg::CustomAlgorithm) = RightOrthAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also RightOrthAlgorithm, right_orth.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LeftOrthAlgorithm-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LeftOrthAlgorithm","text":"LeftOrthAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for left_orth. By default Kind is a symbol, which can be either :qr, :polar or :svd.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.RightOrthAlgorithm-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.RightOrthAlgorithm","text":"RightOrthAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for right_orth. By default Kind is a symbol, which can be either :lq, :polar or :svd.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_null-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_null","text":"left_null(A; [alg], [trunc], kwargs...) -> N\nleft_null!(A, [N], [alg]; [trunc], kwargs...) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A, i.e. the nullspace of adjoint(A), such that adjoint(A) * N ≈ 0 and N' * N ≈ I.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of A', whereas trunc can optionally  be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nnote: Note\nHere notrunc has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional columns of A.\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:qr : Factorize via QR nullspace, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        N = qr_null(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument. It is roughly equivalent to:\n\n        U, S, _ = svd_full(A; kwargs...)\n        N = truncate(left_null, (U, S), trunc)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a LeftNullAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with left_null_alg(alg).\n\n\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!) and right_orth(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_null-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_null","text":"right_null(A; [alg], [trunc], kwargs...) -> Nᴴ\nright_null!(A, [Nᴴ], [alg]; [trunc], kwargs...) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel of the matrix A, i.e. the nullspace of A, such that A * Nᴴ' ≈ 0 and Nᴴ * Nᴴ' ≈ I.\n\nThis is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of A, whereas trunc can optionally  be used to control the precision in determining the rank of A, typically via its singular values.\n\nTruncation\n\nThe optional truncation strategy can be controlled via the trunc keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a NamedTuple or a TruncationStrategy.\n\ntrunc::NamedTuple\n\nThe supported truncation keyword arguments are:\n\natol::Real       : Absolute tolerance for the truncation\nrtol::Real       : Relative tolerance for the truncation\nmaxnullity::Real : Maximal rank for the truncation\n\ntrunc::TruncationStrategy\n\nFor more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:\n\nnotrunc\ntruncrank\ntrunctol\ntruncerror\ntruncfilter\n\nnote: Note\nHere notrunc has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional rows of A.\n\nKeyword arguments\n\nThere are 3 major modes of operation, based on the alg keyword, with slightly different application purposes.\n\nalg::Nothing\n\nThis default mode uses the presence of a truncation strategy trunc to determine an optimal decomposition type, which will be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.\n\nalg::Symbol\n\nHere, the driving selector is alg, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:\n\n:lq : Factorize via LQ nullspace, with further customizations through the other keywords. This mode requires isnothing(trunc), and is equivalent to\n\n        Nᴴ = lq_null(A; kwargs...)\n\n:svd : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the trunc argument. It is roughly equivalent to:\n\n        _, S, Vᴴ = svd_full(A; kwargs...)\n        Nᴴ = truncate(right_null, (S, Vᴴ), trunc)\n\nalg::AbstractAlgorithm\n\nIn this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a RightNullAlgorithm{kind}, or automatically by attempting to deduce the decomposition kind with right_null_alg(alg).\n\n\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!) and right_orth(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LeftNullAlgorithm-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LeftNullAlgorithm","text":"LeftNullAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for left_null. By default Kind is a symbol, which can be either :qr or :svd.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.RightNullAlgorithm-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.RightNullAlgorithm","text":"RightNullAlgorithm{Kind, Alg <: AbstractAlgorithm}(alg)\n\nWrapper type to denote the Kind of factorization that is used as a backend for right_null. By default Kind is a symbol, which can be either :lq or :svd.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_null_alg-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_null_alg","text":"left_null_alg(alg::AbstractAlgorithm) -> LeftNullAlgorithm\n\nConvert an algorithm to a LeftNullAlgorithm wrapper for use with left_null.\n\nThis function attempts to deduce the appropriate factorization kind (:qr or :svd) from the algorithm type and wraps it in a LeftNullAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.left_null_alg(alg::CustomAlgorithm) = LeftNullAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also LeftNullAlgorithm, left_null.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_null_alg-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_null_alg","text":"right_null_alg(alg::AbstractAlgorithm) -> RightNullAlgorithm\n\nConvert an algorithm to a RightNullAlgorithm wrapper for use with right_null.\n\nThis function attempts to deduce the appropriate factorization kind (:lq or :svd) from the algorithm type and wraps it in a RightNullAlgorithm. Custom algorithm types can be registered by defining:\n\nMatrixAlgebraKit.right_null_alg(alg::CustomAlgorithm) = RightNullAlgorithm{kind}(alg)\n\nwhere kind specifies the factorization backend to use.\n\nSee also RightNullAlgorithm, right_null.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.gaugefix!-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.gaugefix!","text":"gaugefix!(f_eig, V)\ngaugefix!(f_svd, U, Vᴴ)\n\nFix the residual gauge degrees of freedom in the eigen or singular vectors, that are obtained from the decomposition performed by f_eig or f_svd. This is achieved by ensuring that the entry with the largest magnitude in V or U is real and positive.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.default_fixgauge-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.default_fixgauge","text":"default_fixgauge() -> current_value\ndefault_fixgauge(new_value::Bool) -> previous_value\n\nGlobal toggle for enabling or disabling the default behavior of gauge fixing the output of the eigen- and singular value decompositions.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#Matrix-Properties","page":"Matrix Properties","title":"Matrix Properties","text":"MatrixAlgebraKit.jl provides a number of methods to check various properties of matrices.\n\nFurthermore, there are also methods to project a matrix onto the nearest matrix (in 2-norm distance) with a given property.","category":"section"},{"location":"user_interface/properties/#MatrixAlgebraKit.isisometric-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.isisometric","text":"isisometric(A; side=:left, isapprox_kwargs...) -> Bool\n\nTest whether a linear map is an isometry, where the type of isometry is controlled by kind:\n\nside = :left : A' * A ≈ I. \nside = :right : A * A' ≈ I.\n\nThe isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nNew specializations should overload MatrixAlgebraKit.is_left_isometric and MatrixAlgebraKit.is_right_isometric.\n\nSee also isunitary.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.isunitary-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.isunitary","text":"isunitary(A; isapprox_kwargs...)\n\nTest whether a linear map is unitary, i.e. A * A' ≈ I ≈ A' * A. The isapprox_kwargs are passed on to isapprox to control the tolerances.\n\nSee also isisometric.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.ishermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.ishermitian","text":"ishermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is Hermitian, i.e. A = A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.isantihermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.isantihermitian","text":"isantihermitian(A; isapprox_kwargs...)\n\nTest whether a linear map is anti-Hermitian, i.e. A = -A'. The isapprox_kwargs can be used to control the tolerances of the equality.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.project_isometric-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.project_isometric","text":"project_isometric(A; kwargs...)\nproject_isometric(A, alg)\nproject_isometric!(A, [W]; kwargs...)\nproject_isometric!(A, [W], alg)\n\nCompute the projection of A onto the manifold of isometric matrices, i.e. matrices satisfying A' * A ≈ I. This projection is computed via the polar decomposition, i.e. W corresponds to the first return value of left_polar!, but avoids computing the positive definite factor explicitly.\n\nnote: Note\nThe bang method project_isometric! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided W as output.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.project_hermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.project_hermitian","text":"project_hermitian(A; kwargs...)\nproject_hermitian(A, alg)\nproject_hermitian!(A, [Aₕ]; kwargs...)\nproject_hermitian!(A, [Aₕ], alg)\n\nCompute the hermitian part of a (square) matrix A, defined as (A + A') / 2. For real matrices this corresponds to the symmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₕ; by default it is equal to A and so the input matrix A is replaced by its hermitian projection.\n\nSee also project_antihermitian.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/properties/#MatrixAlgebraKit.project_antihermitian-user_interface-properties","page":"Matrix Properties","title":"MatrixAlgebraKit.project_antihermitian","text":"project_antihermitian(A; kwargs...)\nproject_antihermitian(A, alg)\nproject_antihermitian!(A, [Aₐ]; kwargs...)\nproject_antihermitian!(A, [Aₐ], alg)\n\nCompute the anti-hermitian part of a (square) matrix A, defined as (A - A') / 2. For real matrices this corresponds to the antisymmetric part of A. In the bang method, the output storage can be provided via the optional argument Aₐ; by default it is equal toAand so the input matrixA` is replaced by its antihermitian projection.\n\nSee also project_hermitian.\n\n\n\n\n\n","category":"function"},{"location":"#MatrixAlgebraKit.jl","page":"Home","title":"MatrixAlgebraKit.jl","text":"A Julia interface for matrix algebra, with a focus on performance, flexibility and extensibility.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"MatrixAlgebraKit.jl is part of the general registry, and can be installed through the package manager:\n\npkg> add MatrixAlgebraKit","category":"section"},{"location":"#Key-features","page":"Home","title":"Key features","text":"The main goals of this package are:\n\nDefinition of a common interface that is sufficiently expressive to allow easy adoption and extension.\nAbility to pass pre-allocated output arrays where the result of a computation is stored.\nAbility to easily switch between different backends and algorithms for the same operation.\nFirst class availability of pullback rules that can be used in combination with different AD ecosystems.","category":"section"},{"location":"#User-Interface","page":"Home","title":"User Interface","text":"On the user-facing side of this package, we provide various implementations and interfaces for different matrix algebra operations. These operations typically follow some common skeleton, and here we go into a little more detail to what behavior can be expected.\n\nPages = [\"user_interface/compositions.md\", \"user_interface/decompositions.md\",\n         \"user_interface/truncations.md\", \"user_interface/properties.md\",\n         \"user_interface/matrix_functions.md\"]\nDepth = 2","category":"section"}]
}
