<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Decompositions · MatrixAlgebraKit.jl</title><meta name="title" content="Decompositions · MatrixAlgebraKit.jl"/><meta property="og:title" content="Decompositions · MatrixAlgebraKit.jl"/><meta property="twitter:title" content="Decompositions · MatrixAlgebraKit.jl"/><meta name="description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="og:description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="twitter:description" content="Documentation for MatrixAlgebraKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MatrixAlgebraKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../compositions/">Compositions</a></li><li class="is-active"><a class="tocitem" href>Decompositions</a><ul class="internal"><li><a class="tocitem" href="#QR-and-LQ-Decompositions"><span>QR and LQ Decompositions</span></a></li><li><a class="tocitem" href="#Eigenvalue-Decomposition"><span>Eigenvalue Decomposition</span></a></li><li><a class="tocitem" href="#Schur-Decomposition"><span>Schur Decomposition</span></a></li><li><a class="tocitem" href="#Singular-Value-Decomposition"><span>Singular Value Decomposition</span></a></li><li><a class="tocitem" href="#Polar-Decomposition"><span>Polar Decomposition</span></a></li><li><a class="tocitem" href="#Orthogonal-Subspaces"><span>Orthogonal Subspaces</span></a></li><li><a class="tocitem" href="#Null-Spaces"><span>Null Spaces</span></a></li></ul></li><li><a class="tocitem" href="../truncations/">Truncations</a></li><li><a class="tocitem" href="../properties/">Matrix Properties</a></li><li><a class="tocitem" href="../matrix_functions/">Matrix functions</a></li></ul></li><li><a class="tocitem" href="../../dev_interface/">Developer Interface</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Interface</a></li><li class="is-active"><a href>Decompositions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Decompositions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/main/docs/src/user_interface/decompositions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Decompositions"><a class="docs-heading-anchor" href="#Decompositions">Decompositions</a><a id="Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#Decompositions" title="Permalink"></a></h1><p>A rather large class of matrix algebra methods consists of taking a single input <code>A</code>, and determining some factorization of that input. In order to streamline these functions, they all follow a similar common code pattern. For a given factorization <code>f</code>, this consists of the following methods:</p><pre><code class="language-julia hljs">f(A; kwargs...) -&gt; F...
f!(A, [F]; kwargs...) -&gt; F...</code></pre><p>Here, the input matrix is always the first argument, and optionally the output can be provided as well. The keywords are algorithm-specific, and can be used to influence the behavior of the algorithms. Importantly, for generic code patterns it is recommended to always use the output <code>F</code> explicitly, since some implementations may not be able to reuse the provided memory. Additionally, the <code>f!</code> method typically assumes that it is allowed to destroy the input <code>A</code>, and making use of the contents of <code>A</code> afterwards should be deemed as undefined behavior.</p><h2 id="QR-and-LQ-Decompositions"><a class="docs-heading-anchor" href="#QR-and-LQ-Decompositions">QR and LQ Decompositions</a><a id="QR-and-LQ-Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#QR-and-LQ-Decompositions" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> transforms a matrix <code>A</code> into a product <code>Q * R</code>, where <code>Q</code> is orthonormal and <code>R</code> upper triangular. This is often used to solve linear least squares problems, or construct orthogonal bases, since it is typically less expensive than the <a href="#Singular-Value-Decomposition">Singular Value Decomposition</a>. If the input <code>A</code> is invertible, <code>Q</code> and <code>R</code> are unique if we require the diagonal elements of <code>R</code> to be positive.</p><p>For rectangular matrices <code>A</code> of size <code>(m, n)</code>, there are two modes of operation, <a href="../../library/#MatrixAlgebraKit.qr_full"><code>qr_full</code></a> and <a href="../../library/#MatrixAlgebraKit.qr_compact"><code>qr_compact</code></a>. The former ensures that the resulting <code>Q</code> is a square unitary matrix of size <code>(m, m)</code>, while the latter creates an isometric <code>Q</code> of size <code>(m, min(m, n))</code>.</p><p>Similarly, the <a href="https://en.wikipedia.org/wiki/LQ_decomposition">LQ decomposition</a> transforms a matrix <code>A</code> into a product <code>L * Q</code>, where <code>L</code> is lower triangular and <code>Q</code> orthonormal. This is equivalent to the <em>transpose</em> of the QR decomposition of the <em>transpose</em> matrix, but can be computed directly. Again there are two modes of operation, <a href="../../library/#MatrixAlgebraKit.lq_full"><code>lq_full</code></a> and <a href="../../library/#MatrixAlgebraKit.lq_compact"><code>lq_compact</code></a>, with the same behavior as the QR decomposition.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_full-user_interface-decompositions" href="#MatrixAlgebraKit.qr_full-user_interface-decompositions"><code>MatrixAlgebraKit.qr_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_full(A; kwargs...) -&gt; Q, R
qr_full(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_full!(A, [QR]; kwargs...) -&gt; Q, R
qr_full!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the full QR decomposition of the rectangular matrix <code>A</code>, such that <code>A = Q * R</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>R</code> is an upper triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info" id="Note-80685cba18950e8f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-80685cba18950e8f" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.qr_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/qr.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_compact-user_interface-decompositions" href="#MatrixAlgebraKit.qr_compact-user_interface-decompositions"><code>MatrixAlgebraKit.qr_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_compact(A; kwargs...) -&gt; Q, R
qr_compact(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_compact!(A, [QR]; kwargs...) -&gt; Q, R
qr_compact!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the compact QR decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = Q * R</code> where the isometric matrix <code>Q</code> of size <code>(m, min(m,n))</code> has orthogonal columns spanning the image of <code>A</code>, and the matrix <code>R</code> of size <code>(min(m,n), n)</code> is upper triangular.</p><div class="admonition is-info" id="Note-1ce8b0a3efe83601"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1ce8b0a3efe83601" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>qr_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><div class="admonition is-info" id="Note-cf5233feddbb2a3e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cf5233feddbb2a3e" title="Permalink"></a></header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full QR decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &gt;= n</code>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.qr_full"><code>qr_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/qr.jl#L22-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_full-user_interface-decompositions" href="#MatrixAlgebraKit.lq_full-user_interface-decompositions"><code>MatrixAlgebraKit.lq_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_full(A; kwargs...) -&gt; L, Q
lq_full(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_full!(A, [LQ]; kwargs...) -&gt; L, Q
lq_full!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the full LQ decomposition of the rectangular matrix <code>A</code>, such that <code>A = L * Q</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>L</code> is a lower triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info" id="Note-3996ecdc7e8c139f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3996ecdc7e8c139f" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/lq.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_compact-user_interface-decompositions" href="#MatrixAlgebraKit.lq_compact-user_interface-decompositions"><code>MatrixAlgebraKit.lq_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_compact(A; kwargs...) -&gt; L, Q
lq_compact(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_compact!(A, [LQ]; kwargs...) -&gt; L, Q
lq_compact!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the compact LQ decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = L * Q</code> where the matrix <code>Q</code> of size <code>(min(m,n), n)</code> has orthogonal rows spanning the image of <code>A&#39;</code>, and the matrix <code>L</code> of size <code>(m, min(m,n))</code> is lower triangular.</p><div class="admonition is-info" id="Note-c6610292b890d8fd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c6610292b890d8fd" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>lq_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><div class="admonition is-info" id="Note-6ad9fcccd1745048"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6ad9fcccd1745048" title="Permalink"></a></header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full LQ decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &lt;= n</code>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/lq.jl#L22-L42">source</a></section></article><p>Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithm:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_HouseholderQR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_HouseholderQR(; blocksize, positive = false, pivoted = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  <code>?geqrt</code> will be chosen if <code>blocksize &gt; 1</code>. With <code>blocksize == 1</code>, <code>?geqrf</code> will be chosen if <code>pivoted == false</code> and <code>?geqp3</code> will be chosen if <code>pivoted == true</code>. The keyword <code>positive=true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_HouseholderLQ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_HouseholderLQ(; blocksize, positive = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. <code>?gelqt</code> will be chosen if <code>blocksize &gt; 1</code> or <code>?gelqf</code> will be chosen if <code>blocksize == 1</code>. The keyword <code>positive=true</code> can be used to ensure that the diagonal elements of <code>L</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L24-L32">source</a></section></article><h2 id="Eigenvalue-Decomposition"><a class="docs-heading-anchor" href="#Eigenvalue-Decomposition">Eigenvalue Decomposition</a><a id="Eigenvalue-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">Eigenvalue Decomposition</a> transforms a square matrix <code>A</code> into a product <code>V * D * V⁻¹</code>. Equivalently, it finds <code>V</code> and <code>D</code> that satisfy <code>A * V = V * D</code>.</p><p>Not all matrices can be diagonalized, and some real matrices can only be diagonalized using complex arithmetic. In particular, the resulting decomposition can only guaranteed to be real for real symmetric inputs <code>A</code>. Therefore, we provide <code>eig_</code> and <code>eigh_</code> variants, where <code>eig</code> always results in complex-valued <code>V</code> and <code>D</code>, while <code>eigh</code> requires symmetric inputs but retains the scalartype of the input.</p><p>The full set of eigenvalues and eigenvectors can be computed using the <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> functions. If only the eigenvalues are required, the <a href="../../library/#MatrixAlgebraKit.eig_vals"><code>eig_vals</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_vals"><code>eigh_vals</code></a> functions can be used. These functions return the diagonal elements of <code>D</code> in a vector.</p><p>Finally, it is also possible to compute a partial or truncated eigenvalue decomposition, using the <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc</code></a> functions. To control the behavior of the truncation, we refer to <a href="../truncations/#Truncations">Truncations</a> for more information.</p><h3 id="Symmetric-Eigenvalue-Decomposition"><a class="docs-heading-anchor" href="#Symmetric-Eigenvalue-Decomposition">Symmetric Eigenvalue Decomposition</a><a id="Symmetric-Eigenvalue-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetric-Eigenvalue-Decomposition" title="Permalink"></a></h3><p>For symmetric matrices, we provide the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_full-user_interface-decompositions" href="#MatrixAlgebraKit.eigh_full-user_interface-decompositions"><code>MatrixAlgebraKit.eigh_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_full(A; kwargs...) -&gt; D, V, ϵ
eigh_full(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eigh_full!(A, [DV]; kwargs...) -&gt; D, V, ϵ
eigh_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute the full eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V = V * D</code>, where the unitary matrix <code>V</code> contains the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded eigenvalues.</p><div class="admonition is-info" id="Note-22eae39c03133693"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-22eae39c03133693" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-8a775800a298a227"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8a775800a298a227" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/eigh.jl#L14-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_trunc-user_interface-decompositions" href="#MatrixAlgebraKit.eigh_trunc-user_interface-decompositions"><code>MatrixAlgebraKit.eigh_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_trunc(A; [trunc], kwargs...) -&gt; D, V, ϵ
eigh_trunc(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eigh_trunc!(A, [DV]; [trunc], kwargs...) -&gt; D, V, ϵ
eigh_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the discarded eigenvalues.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="../../library/#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="../../library/#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="../../library/#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-79d424db5823198a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-79d424db5823198a" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-8a775800a298a227"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8a775800a298a227" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>, and <a href="../truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/eigh.jl#L39-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_vals-user_interface-decompositions" href="#MatrixAlgebraKit.eigh_vals-user_interface-decompositions"><code>MatrixAlgebraKit.eigh_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_vals(A; kwargs...) -&gt; D
eigh_vals(A, alg::AbstractAlgorithm) -&gt; D
eigh_vals!(A, [D]; kwargs...) -&gt; D
eigh_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of (real) eigenvalues of the symmetric or hermitian matrix <code>A</code>.</p><div class="admonition is-info" id="Note-d21f53c13380dd3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d21f53c13380dd3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eigh_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-8a775800a298a227"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8a775800a298a227" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume that the input matrix is hermitian, or thus symmetric if the input is real. The resulting algorithms exploit this structure, and return eigenvalues that are always real, and eigenvectors that are orthogonal and have the same <code>eltype</code> as the input matrix. If the input matrix does not have this structure, the generic eigenvalue decomposition provided by <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants should be used instead.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/eigh.jl#L92-L109">source</a></section></article><p>Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Bisection()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_DivideAndConquer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_DivideAndConquer()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_MultipleRelativelyRobustRepresentations()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_QRIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_QRIteration()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L61-L67">source</a></section></article><h3 id="Eigenvalue-Decomposition-2"><a class="docs-heading-anchor" href="#Eigenvalue-Decomposition-2">Eigenvalue Decomposition</a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Decomposition-2" title="Permalink"></a></h3><p>For general matrices, we provide the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_full-user_interface-decompositions" href="#MatrixAlgebraKit.eig_full-user_interface-decompositions"><code>MatrixAlgebraKit.eig_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_full(A; kwargs...) -&gt; D, V
eig_full(A, alg::AbstractAlgorithm) -&gt; D, V
eig_full!(A, [DV]; kwargs...) -&gt; D, V
eig_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the square matrix <code>A</code>, such that <code>A * V = V * D</code>, where the invertible matrix <code>V</code> contains the eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info" id="Note-df7941fe2c4293f5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-df7941fe2c4293f5" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-fa5718a1de3edd8f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fa5718a1de3edd8f" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/eig.jl#L12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_trunc-user_interface-decompositions" href="#MatrixAlgebraKit.eig_trunc-user_interface-decompositions"><code>MatrixAlgebraKit.eig_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_trunc(A; [trunc], kwargs...) -&gt; D, V, ϵ
eig_trunc(A, alg::AbstractAlgorithm) -&gt; D, V, ϵ
eig_trunc!(A, [DV]; [trunc], kwargs...) -&gt; D, V, ϵ
eig_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V, ϵ</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded eigenvalues.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword Arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="../../library/#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="../../library/#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="../../library/#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-de1f62fb0c5df685"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-de1f62fb0c5df685" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info" id="Note-fa5718a1de3edd8f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fa5718a1de3edd8f" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>, and <a href="../truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/eig.jl#L34-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_vals-user_interface-decompositions" href="#MatrixAlgebraKit.eig_vals-user_interface-decompositions"><code>MatrixAlgebraKit.eig_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_vals(A; kwargs...) -&gt; D
eig_vals(A, alg::AbstractAlgorithm) -&gt; D
eig_vals!(A, [D]; kwargs...) -&gt; D
eig_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of eigenvalues of <code>A</code>.</p><div class="admonition is-info" id="Note-4e1227c80a666bb9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4e1227c80a666bb9" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>D</code> as output.</p></div></div><div class="admonition is-info" id="Note-fa5718a1de3edd8f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fa5718a1de3edd8f" title="Permalink"></a></header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume any symmetry structure on the input matrices, and therefore will always return complex eigenvalues and eigenvectors for reasons of type stability.  For the  eigenvalue decomposition of symmetric or hermitian operators, see <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/eig.jl#L87-L104">source</a></section></article><p>Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Expert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Expert()</code></pre><p>Algorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Simple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Simple()</code></pre><p>Algorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L41-L46">source</a></section></article><h2 id="Schur-Decomposition"><a class="docs-heading-anchor" href="#Schur-Decomposition">Schur Decomposition</a><a id="Schur-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Schur-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Schur_decomposition">Schur decomposition</a> transforms a complex square matrix <code>A</code> into a product <code>Q * T * Qᴴ</code>, where <code>Q</code> is unitary and <code>T</code> is upper triangular. It rewrites an arbitrary complex square matrix as unitarily similar to an upper triangular matrix whose diagonal elements are the eigenvalues of <code>A</code>. For real matrices, the same decomposition can be achieved in real arithmetic by allowing <code>T</code> to be quasi-upper triangular, i.e. triangular with blocks of size <code>(1, 1)</code> and <code>(2, 2)</code> on the diagonal.</p><p>This decomposition is also useful for computing the eigenvalues of a matrix, which is exposed through the <a href="../../library/#MatrixAlgebraKit.schur_vals"><code>schur_vals</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_full-user_interface-decompositions" href="#MatrixAlgebraKit.schur_full-user_interface-decompositions"><code>MatrixAlgebraKit.schur_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_full(A; kwargs...) -&gt; T, Z, vals
schur_full(A, alg::AbstractAlgorithm) -&gt; T, Z, vals
schur_full!(A, [TZv]; kwargs...) -&gt; T, Z, vals
schur_full!(A, [TZv], alg::AbstractAlgorithm) -&gt; T, Z, vals</code></pre><p>Compute the full Schur decomposition of the square matrix <code>A</code>, such that <code>A * Z = Z * T</code>, where the orthogonal or unitary matrix <code>Z</code> contains the Schur vectors and the square matrix <code>T</code> is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list <code>vals</code> contains the (complex-valued) eigenvalues of <code>A</code>, as extracted from the (quasi-)diagonal of <code>T</code>.</p><div class="admonition is-info" id="Note-eb822132becfbd1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-eb822132becfbd1" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>schur_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>TZv</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/schur.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_vals-user_interface-decompositions" href="#MatrixAlgebraKit.schur_vals-user_interface-decompositions"><code>MatrixAlgebraKit.schur_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_vals(A; kwargs...) -&gt; vals
schur_vals(A, alg::AbstractAlgorithm) -&gt; vals
schur_vals!(A, [vals]; kwargs...) -&gt; vals
schur_vals!(A, [vals], alg::AbstractAlgorithm) -&gt; vals</code></pre><p>Compute the list of eigenvalues of <code>A</code> by computing the Schur decomposition of <code>A</code>.</p><div class="admonition is-info" id="Note-457490c099828ad3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-457490c099828ad3" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>schur_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>vals</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/schur.jl#L23-L37">source</a></section></article><p>The LAPACK-based implementation for dense arrays is provided by the following algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_Expert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Expert()</code></pre><p>Algorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_Simple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Simple()</code></pre><p>Algorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L41-L46">source</a></section></article><h2 id="Singular-Value-Decomposition"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition">Singular Value Decomposition</a><a id="Singular-Value-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular Value Decomposition</a> transforms a matrix <code>A</code> into a product <code>U * Σ * Vᴴ</code>, where <code>U</code> and <code>Vᴴ</code> are unitary, and <code>Σ</code> is diagonal, real and non-negative. For a square matrix <code>A</code>, both <code>U</code> and <code>Vᴴ</code> are unitary, and if the singular values are distinct, the decomposition is unique.</p><p>For rectangular matrices <code>A</code> of size <code>(m, n)</code>, there are two modes of operation, <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact</code></a>. The former ensures that the resulting <code>U</code>, and <code>Vᴴ</code> remain square unitary matrices, of size <code>(m, m)</code> and <code>(n, n)</code>, with rectangular <code>Σ</code> of size <code>(m, n)</code>. The latter creates an isometric <code>U</code> of size <code>(m, min(m, n))</code>, and <code>V = (Vᴴ)&#39;</code> of size <code>(n, min(m, n))</code>, with a square <code>Σ</code> of size <code>(min(m, n), min(m, n))</code>.</p><p>It is also possible to compute the singular values only, using the <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals</code></a> function. This then returns a vector of the values on the diagonal of <code>Σ</code>.</p><p>Finally, we also support computing a partial or truncated SVD, using the <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_full-user_interface-decompositions" href="#MatrixAlgebraKit.svd_full-user_interface-decompositions"><code>MatrixAlgebraKit.svd_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_full(A; kwargs...) -&gt; U, S, Vᴴ
svd_full(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the full singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> and <code>Vᴴ</code> are unitary matrices of size <code>(m, m)</code> and <code>(n, n)</code> respectively, and <code>S</code> is a diagonal matrix of size <code>(m, n)</code>.</p><div class="admonition is-info" id="Note-ee0ea1ab51e33750"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ee0ea1ab51e33750" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/svd.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_compact-user_interface-decompositions" href="#MatrixAlgebraKit.svd_compact-user_interface-decompositions"><code>MatrixAlgebraKit.svd_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_compact(A; kwargs...) -&gt; U, S, Vᴴ
svd_compact(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the compact singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k = min(m, n)</code>.</p><div class="admonition is-info" id="Note-1ca44472597a3142"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1ca44472597a3142" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/svd.jl#L23-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_vals-user_interface-decompositions" href="#MatrixAlgebraKit.svd_vals-user_interface-decompositions"><code>MatrixAlgebraKit.svd_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_vals(A; kwargs...) -&gt; S
svd_vals(A, alg::AbstractAlgorithm) -&gt; S
svd_vals!(A, [S]; kwargs...) -&gt; S
svd_vals!(A, [S], alg::AbstractAlgorithm) -&gt; S</code></pre><p>Compute the vector of singular values of <code>A</code>, such that for an M×N matrix <code>A</code>, <code>S</code> is a vector of size <code>K = min(M, N)</code>, the number of kept singular values.</p><p>See also <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/svd.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_trunc-user_interface-decompositions" href="#MatrixAlgebraKit.svd_trunc-user_interface-decompositions"><code>MatrixAlgebraKit.svd_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_trunc(A; [trunc], kwargs...) -&gt; U, S, Vᴴ, ϵ
svd_trunc(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ, ϵ
svd_trunc!(A, [USVᴴ]; [trunc], kwargs...) -&gt; U, S, Vᴴ, ϵ
svd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ, ϵ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; ≈ U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy.</p><p>The function also returns <code>ϵ</code>, the truncation error defined as the 2-norm of the  discarded singular values.</p><p><strong>Truncation</strong></p><p>The truncation strategy can be controlled via the <code>trunc</code> keyword argument. This can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>. If <code>trunc</code> is not provided or nothing, all values will be kept.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>Other keyword arguments are passed to the algorithm selection procedure. If no explicit <code>alg</code> is provided, these keywords are used to select and configure the algorithm through <a href="../../library/#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a>. The remaining keywords after algorithm selection are passed to the algorithm constructor. See <a href="../../library/#MatrixAlgebraKit.default_algorithm"><code>MatrixAlgebraKit.default_algorithm</code></a> for the default algorithm selection behavior.</p><p>When <code>alg</code> is a <a href="../../library/#MatrixAlgebraKit.TruncatedAlgorithm"><code>TruncatedAlgorithm</code></a>, the <code>trunc</code> keyword cannot be specified as the truncation strategy is already embedded in the algorithm.</p><div class="admonition is-info" id="Note-c0ca262c5f16cec1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c0ca262c5f16cec1" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>svd_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>, and <a href="../truncations/#Truncations">Truncations</a> for more information on truncation strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/svd.jl#L44-L92">source</a></section></article><p>MatrixAlgebraKit again ships with LAPACK-based implementations for dense arrays:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Bisection()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_DivideAndConquer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_DivideAndConquer()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Jacobi</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Jacobi()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_QRIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_QRIteration()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L61-L67">source</a></section></article><h2 id="Polar-Decomposition"><a class="docs-heading-anchor" href="#Polar-Decomposition">Polar Decomposition</a><a id="Polar-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Polar_decomposition">Polar Decomposition</a> of a matrix <code>A</code> is a factorization <code>A = W * P</code>, where <code>W</code> is unitary and <code>P</code> is positive semi-definite. If <code>A</code> is invertible (and therefore square), the polar decomposition always exists and is unique. For non-square matrices <code>A</code> of size <code>(m, n)</code>, the decomposition <code>A = W * P</code> with <code>P</code> positive semi-definite of size <code>(n, n)</code> and <code>W</code> isometric of size <code>(m, n)</code> exists only if <code>m &gt;= n</code>, and is unique if <code>A</code> and thus <code>P</code> is full rank. For <code>m &lt;= n</code>, we can analoguously decompose <code>A</code> as <code>A = P * Wᴴ</code> with <code>P</code> positive semi-definite of size <code>(m, m)</code> and <code>Wᴴ</code> of size <code>(m, n)</code> such that <code>W = (Wᴴ)&#39;</code> is isometric. Only in the case <code>m = n</code> do both decompositions exist.</p><p>The decompositions <code>A = W * P</code> or <code>A = P * Wᴴ</code> can be computed with the <a href="../../library/#MatrixAlgebraKit.left_polar"><code>left_polar</code></a> and <a href="../../library/#MatrixAlgebraKit.right_polar"><code>right_polar</code></a> functions, respectively.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_polar-user_interface-decompositions" href="#MatrixAlgebraKit.left_polar-user_interface-decompositions"><code>MatrixAlgebraKit.left_polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_polar(A; kwargs...) -&gt; W, P
left_polar(A, alg::AbstractAlgorithm) -&gt; W, P
left_polar!(A, [WP]; kwargs...) -&gt; W, P
left_polar!(A, [WP], alg::AbstractAlgorithm) -&gt; W, P</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>m &gt;= n</code>, such that <code>A = W * P</code>. Here, <code>W</code> is an isometric matrix (orthonormal columns) of size <code>(m, n)</code>, whereas <code>P</code> is a positive (semi)definite matrix of size <code>(n, n)</code>.</p><div class="admonition is-info" id="Note-42ed2d31e17943d5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-42ed2d31e17943d5" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.right_polar"><code>right_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/polar.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_polar-user_interface-decompositions" href="#MatrixAlgebraKit.right_polar-user_interface-decompositions"><code>MatrixAlgebraKit.right_polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_polar(A; kwargs...) -&gt; P, Wᴴ
right_polar(A, alg::AbstractAlgorithm) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ]; kwargs...) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -&gt; P, Wᴴ</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>n &gt;= m</code>, such that <code>A = P * Wᴴ</code>. Here, <code>P</code> is a positive (semi)definite matrix of size <code>(m, m)</code>, whereas <code>Wᴴ</code> is a matrix with orthonormal rows (its adjoint is isometric) of size <code>(n, m)</code>.</p><div class="admonition is-info" id="Note-4242b4aee47d7c20"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4242b4aee47d7c20" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.left_polar"><code>left_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/polar.jl#L22-L39">source</a></section></article><p>These functions can be implemented by first computing a singular value decomposition, and then constructing the polar decomposition from the singular values and vectors. Alternatively, the polar decomposition can be computed using an  iterative method based on Newton&#39;s method, that can be more efficient for large matrices, especially if they are close to being isometric already.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions" href="#MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions"><code>MatrixAlgebraKit.PolarViaSVD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolarViaSVD(svd_alg)</code></pre><p>Algorithm for computing the polar decomposition of a matrix <code>A</code> via the singular value decomposition (SVD) of <code>A</code>. The <code>svd_alg</code> argument specifies the SVD algorithm to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.PolarNewton-user_interface-decompositions" href="#MatrixAlgebraKit.PolarNewton-user_interface-decompositions"><code>MatrixAlgebraKit.PolarNewton</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolarNewton(; maxiter = 10, tol = defaulttol(A))</code></pre><p>Algorithm for computing the polar decomposition of a matrix <code>A</code> via scaled Newton iteration, with a maximum of <code>maxiter</code> iterations and until convergence up to tolerance <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L133-L139">source</a></section></article><h2 id="Orthogonal-Subspaces"><a class="docs-heading-anchor" href="#Orthogonal-Subspaces">Orthogonal Subspaces</a><a id="Orthogonal-Subspaces-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-Subspaces" title="Permalink"></a></h2><p>Often it is useful to compute orthogonal bases for particular subspaces defined by a matrix. Given a matrix <code>A</code>, we can compute an orthonormal basis for its image or coimage, and factorize the matrix accordingly. These bases are accessible through <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth</code></a> and <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth</code></a> respectively.</p><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p>The <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth</code></a> function computes an orthonormal basis <code>V</code> for the image (column space) of <code>A</code>, along with a corestriction matrix <code>C</code> such that <code>A = V * C</code>. The resulting <code>V</code> has orthonormal columns (<code>V&#39; * V ≈ I</code> or <code>isisometric(V)</code>).</p><p>Similarly, <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth</code></a> computes an orthonormal basis for the coimage (row space) of <code>A</code>, i.e., the image of <code>A&#39;</code>. It returns matrices <code>C</code> and <code>Vᴴ</code> such that <code>A = C * Vᴴ</code>, where <code>V = (Vᴴ)&#39;</code> has orthonormal columns (<code>isisometric(Vᴴ; side = :right)</code>).</p><p>These functions serve as high-level interfaces that automatically select the most appropriate decomposition based on the specified options, making them convenient for users who want orthonormalization without worrying about the underlying implementation details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_orth-user_interface-decompositions" href="#MatrixAlgebraKit.left_orth-user_interface-decompositions"><code>MatrixAlgebraKit.left_orth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_orth(A; [alg], [trunc], kwargs...) -&gt; V, C
left_orth!(A, [VC], [alg]; [trunc], kwargs...) -&gt; V, C</code></pre><p>Compute an orthonormal basis <code>V</code> for the image of the matrix <code>A</code>, as well as a  matrix <code>C</code> (the corestriction) such that <code>A</code> factors as <code>A = V * C</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>trunc</code> can optionally be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will typically be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:qr</code> : Factorize via QR decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        V, C = qr_compact(A; kwargs...)</code></pre><ul><li><code>:polar</code> : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        V, C = left_polar(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument, and is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        V, S, C = svd_trunc(A; trunc, kwargs...)
        C = lmul!(S, C)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="../../library/#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="../../library/#MatrixAlgebraKit.left_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>left_orth_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-45533f2d9c23aca2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-45533f2d9c23aca2" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CV</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L3-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_orth-user_interface-decompositions" href="#MatrixAlgebraKit.right_orth-user_interface-decompositions"><code>MatrixAlgebraKit.right_orth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_orth(A; [alg], [trunc], kwargs...) -&gt; C, Vᴴ
right_orth!(A, [CVᴴ], [alg]; [trunc], kwargs...) -&gt; C, Vᴴ</code></pre><p>Compute an orthonormal basis <code>V = adjoint(Vᴴ)</code> for the coimage of the matrix <code>A</code>, i.e. for the image of <code>adjoint(A)</code>, as well as a matrix <code>C</code> such that <code>A</code> factors as <code>A = C * Vᴴ</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>trunc</code> can optionally be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decompositions. This keyword can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>      : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>      : Relative tolerance for the truncation</li><li><code>maxrank::Real</code>   : Maximal rank for the truncation</li><li><code>maxerror::Real</code>  : Maximal truncation error.</li><li><code>filter</code>          : Custom filter to select truncated values.</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will typicall be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:lq</code> : Factorize via LQ decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        C, Vᴴ = lq_compact(A; kwargs...)</code></pre><ul><li><code>:polar</code> : Factorize via polar decomposition, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        C, Vᴴ = right_polar(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument, and is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        C, S, Vᴴ = svd_trunc(A; trunc, kwargs...)
        C = rmul!(C, S)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="../../library/#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="../../library/#MatrixAlgebraKit.right_orth_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>right_orth_alg</code></a>.</p><hr/><div class="admonition is-info" id="Note-d2d62bfec9f5a338"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d2d62bfec9f5a338" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L84-L162">source</a></section></article><h3 id="Algorithm-Selection"><a class="docs-heading-anchor" href="#Algorithm-Selection">Algorithm Selection</a><a id="Algorithm-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Selection" title="Permalink"></a></h3><p>Both functions support multiple decomposition drivers, which can be selected through the <code>alg</code> keyword argument:</p><p><strong>For <code>left_orth</code>:</strong></p><ul><li><code>alg = :qr</code> (default without truncation): Uses QR decomposition via <a href="../../library/#MatrixAlgebraKit.qr_compact"><code>qr_compact</code></a></li><li><code>alg = :polar</code>: Uses polar decomposition via <a href="../../library/#MatrixAlgebraKit.left_polar"><code>left_polar</code></a></li><li><code>alg = :svd</code> (default with truncation): Uses SVD via <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact</code></a> or <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc</code></a></li></ul><p><strong>For <code>right_orth</code>:</strong></p><ul><li><code>alg = :lq</code> (default without truncation): Uses LQ decomposition via <a href="../../library/#MatrixAlgebraKit.lq_compact"><code>lq_compact</code></a></li><li><code>alg = :polar</code>: Uses polar decomposition via <a href="../../library/#MatrixAlgebraKit.right_polar"><code>right_polar</code></a></li><li><code>alg = :svd</code> (default with truncation): Uses SVD via <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact</code></a> or <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc</code></a></li></ul><p>When <code>alg</code> is not specified, the function automatically selects <code>:qr</code>/<code>:lq</code> for exact orthogonalization, or <code>:svd</code> when a truncation strategy is provided.</p><h3 id="Extending-with-Custom-Algorithms"><a class="docs-heading-anchor" href="#Extending-with-Custom-Algorithms">Extending with Custom Algorithms</a><a id="Extending-with-Custom-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-with-Custom-Algorithms" title="Permalink"></a></h3><p>To register a custom algorithm type for use with these functions, you need to define the appropriate conversion function, for example:</p><pre><code class="language-julia hljs"># For left_orth
MatrixAlgebraKit.left_orth_alg(alg::MyCustomAlgorithm) = LeftOrthAlgorithm{:qr}(alg)

# For right_orth
MatrixAlgebraKit.right_orth_alg(alg::MyCustomAlgorithm) = RightOrthAlgorithm{:lq}(alg)</code></pre><p>The type parameter (<code>:qr</code>, <code>:lq</code>, <code>:polar</code>, or <code>:svd</code>) indicates which factorization backend will be used. The wrapper algorithm types handle the dispatch to the appropriate implementation:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_orth_alg-user_interface-decompositions" href="#MatrixAlgebraKit.left_orth_alg-user_interface-decompositions"><code>MatrixAlgebraKit.left_orth_alg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_orth_alg(alg::AbstractAlgorithm) -&gt; LeftOrthAlgorithm</code></pre><p>Convert an algorithm to a <a href="../../library/#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm</code></a> wrapper for use with <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:qr</code>, <code>:polar</code>, or <code>:svd</code>) from the algorithm type and wraps it in a <code>LeftOrthAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.left_orth_alg(alg::CustomAlgorithm) = LeftOrthAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="../../library/#MatrixAlgebraKit.LeftOrthAlgorithm"><code>LeftOrthAlgorithm</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L413-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_orth_alg-user_interface-decompositions" href="#MatrixAlgebraKit.right_orth_alg-user_interface-decompositions"><code>MatrixAlgebraKit.right_orth_alg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_orth_alg(alg::AbstractAlgorithm) -&gt; RightOrthAlgorithm</code></pre><p>Convert an algorithm to a <a href="../../library/#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm</code></a> wrapper for use with <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:lq</code>, <code>:polar</code>, or <code>:svd</code>) from the algorithm type and wraps it in a <code>RightOrthAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.right_orth_alg(alg::CustomAlgorithm) = RightOrthAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="../../library/#MatrixAlgebraKit.RightOrthAlgorithm"><code>RightOrthAlgorithm</code></a>, <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L448-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LeftOrthAlgorithm-user_interface-decompositions" href="#MatrixAlgebraKit.LeftOrthAlgorithm-user_interface-decompositions"><code>MatrixAlgebraKit.LeftOrthAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LeftOrthAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:qr</code>, <code>:polar</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L321-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.RightOrthAlgorithm-user_interface-decompositions" href="#MatrixAlgebraKit.RightOrthAlgorithm-user_interface-decompositions"><code>MatrixAlgebraKit.RightOrthAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightOrthAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:lq</code>, <code>:polar</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L350-L355">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>Basic orthogonalization:</p><pre><code class="language-julia hljs">using MatrixAlgebraKit
using LinearAlgebra

A = [1.0 2.0; 3.0 4.0; 5.0 6.0]
V, C = left_orth(A)
(V&#39; * V) ≈ I &amp;&amp; A ≈ V * C</code></pre><p>Using different algorithms:</p><pre><code class="language-julia hljs">A = randn(4, 3)
V1, C1 = left_orth(A; alg = :qr)
V2, C2 = left_orth(A; alg = :polar)
V3, C3 = left_orth(A; alg = :svd)
A ≈ V1 * C1 ≈ V2 * C2 ≈ V3 * C3</code></pre><p>With truncation:</p><pre><code class="language-julia hljs">A = [1.0 0.0; 0.0 1e-10; 0.0 0.0]
V, C = left_orth(A; trunc = (atol = 1e-8,))
size(V, 2) == 1  # Only one column retained</code></pre><h2 id="Null-Spaces"><a class="docs-heading-anchor" href="#Null-Spaces">Null Spaces</a><a id="Null-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Null-Spaces" title="Permalink"></a></h2><p>Similarly, it can be convenient to obtain an orthogonal basis for the kernel or cokernel of a matrix. These are the orthogonal complements of the coimage and image, respectively, and can be computed using the <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null</code></a> and <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null</code></a> functions.</p><h3 id="Overview-2"><a class="docs-heading-anchor" href="#Overview-2">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-2" title="Permalink"></a></h3><p>The <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null</code></a> function computes an orthonormal basis <code>N</code> for the cokernel (left nullspace) of <code>A</code>, which is the nullspace of <code>A&#39;</code>. This means <code>A&#39; * N ≈ 0</code> and <code>N&#39; * N ≈ I</code>.</p><p>Similarly, <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null</code></a> computes an orthonormal basis for the kernel (right nullspace) of <code>A</code>. It returns <code>Nᴴ</code> such that <code>A * Nᴴ&#39; ≈ 0</code> and <code>Nᴴ * Nᴴ&#39; ≈ I</code>, where <code>N = (Nᴴ)&#39;</code> has orthonormal columns.</p><p>These functions automatically handle rank determination and provide convenient access to nullspace computation without requiring detailed knowledge of the underlying decomposition methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_null-user_interface-decompositions" href="#MatrixAlgebraKit.left_null-user_interface-decompositions"><code>MatrixAlgebraKit.left_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_null(A; [alg], [trunc], kwargs...) -&gt; N
left_null!(A, [N], [alg]; [trunc], kwargs...) -&gt; N</code></pre><p>Compute an orthonormal basis <code>N</code> for the cokernel of the matrix <code>A</code>, i.e. the nullspace of <code>adjoint(A)</code>, such that <code>adjoint(A) * N ≈ 0</code> and <code>N&#39; * N ≈ I</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of <code>A&#39;</code>, whereas <code>trunc</code> can optionally  be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><div class="admonition is-info" id="Note-897a2abb96c2bb64"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-897a2abb96c2bb64" title="Permalink"></a></header><div class="admonition-body"><p>Here <a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional columns of <code>A</code>.</p></div></div><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will be QR-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:qr</code> : Factorize via QR nullspace, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        N = qr_null(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument. It is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        U, S, _ = svd_full(A; kwargs...)
        N = truncate(left_null, (U, S), trunc)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="../../library/#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="../../library/#MatrixAlgebraKit.left_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>left_null_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-673dfc2142e867c6"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-673dfc2142e867c6" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>left_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L167-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_null-user_interface-decompositions" href="#MatrixAlgebraKit.right_null-user_interface-decompositions"><code>MatrixAlgebraKit.right_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_null(A; [alg], [trunc], kwargs...) -&gt; Nᴴ
right_null!(A, [Nᴴ], [alg]; [trunc], kwargs...) -&gt; Nᴴ</code></pre><p>Compute an orthonormal basis <code>N = adjoint(Nᴴ)</code> for the kernel of the matrix <code>A</code>, i.e. the nullspace of <code>A</code>, such that <code>A * Nᴴ&#39; ≈ 0</code> and <code>Nᴴ * Nᴴ&#39; ≈ I</code>.</p><p>This is a high-level wrapper where the keyword arguments can be used to specify and control the underlying orthogonal decomposition that should be used to find the null space of <code>A</code>, whereas <code>trunc</code> can optionally  be used to control the precision in determining the rank of <code>A</code>, typically via its singular values.</p><p><strong>Truncation</strong></p><p>The optional truncation strategy can be controlled via the <code>trunc</code> keyword argument, and any non-trivial strategy typically requires an SVD-based decomposition. This keyword can be either a <code>NamedTuple</code> or a <a href="../../library/#MatrixAlgebraKit.TruncationStrategy"><code>TruncationStrategy</code></a>.</p><p><strong><code>trunc::NamedTuple</code></strong></p><p>The supported truncation keyword arguments are:</p><ul><li><code>atol::Real</code>       : Absolute tolerance for the truncation</li><li><code>rtol::Real</code>       : Relative tolerance for the truncation</li><li><code>maxnullity::Real</code> : Maximal rank for the truncation</li></ul><p><strong><code>trunc::TruncationStrategy</code></strong></p><p>For more control, a truncation strategy can be supplied directly. By default, MatrixAlgebraKit supplies the following:</p><ul><li><a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncrank-Tuple{Integer}"><code>truncrank</code></a></li><li><a href="../../library/#MatrixAlgebraKit.trunctol-Tuple{}"><code>trunctol</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncerror-Tuple{}"><code>truncerror</code></a></li><li><a href="../../library/#MatrixAlgebraKit.truncfilter-Tuple{Any}"><code>truncfilter</code></a></li></ul><div class="admonition is-info" id="Note-ba86a9d23a57e8dd"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ba86a9d23a57e8dd" title="Permalink"></a></header><div class="admonition-body"><p>Here <a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning, and signifies keeping the values that correspond to the exact zeros determined from the additional rows of <code>A</code>.</p></div></div><p><strong>Keyword arguments</strong></p><p>There are 3 major modes of operation, based on the <code>alg</code> keyword, with slightly different application purposes.</p><p><strong><code>alg::Nothing</code></strong></p><p>This default mode uses the presence of a truncation strategy <code>trunc</code> to determine an optimal decomposition type, which will be LQ-based for no truncation, or SVD-based for truncation. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type.</p><p><strong><code>alg::Symbol</code></strong></p><p>Here, the driving selector is <code>alg</code>, which is used to select the kind of decomposition. The remaining keyword arguments are passed on directly to the algorithm selection procedure of the chosen decomposition type. By default, the supported kinds are:</p><ul><li><code>:lq</code> : Factorize via LQ nullspace, with further customizations through the other keywords. This mode requires <code>isnothing(trunc)</code>, and is equivalent to</li></ul><pre><code class="language-julia hljs">        Nᴴ = lq_null(A; kwargs...)</code></pre><ul><li><code>:svd</code> : Factorize via SVD, with further customizations through the other keywords. This mode further allows truncation, which can be selected through the <code>trunc</code> argument. It is roughly equivalent to:</li></ul><pre><code class="language-julia hljs">        _, S, Vᴴ = svd_full(A; kwargs...)
        Nᴴ = truncate(right_null, (S, Vᴴ), trunc)</code></pre><p><strong><code>alg::AbstractAlgorithm</code></strong></p><p>In this expert mode the algorithm is supplied directly, and the kind of decomposition is deduced from that. This is achieved either directly by providing a <a href="../../library/#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm{kind}</code></a>, or automatically by attempting to deduce the decomposition kind with <a href="../../library/#MatrixAlgebraKit.right_null_alg-Tuple{MatrixAlgebraKit.AbstractAlgorithm}"><code>right_null_alg(alg)</code></a>.</p><hr/><div class="admonition is-info" id="Note-f42eb95c7bf3c0a9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f42eb95c7bf3c0a9" title="Permalink"></a></header><div class="admonition-body"><p>The bang method <code>right_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L246-L322">source</a></section></article><h3 id="Algorithm-Selection-2"><a class="docs-heading-anchor" href="#Algorithm-Selection-2">Algorithm Selection</a><a class="docs-heading-anchor-permalink" href="#Algorithm-Selection-2" title="Permalink"></a></h3><p>Both functions support multiple decomposition drivers, which can be selected through the <code>alg</code> keyword argument:</p><p><strong>For <code>left_null</code>:</strong></p><ul><li><code>alg = :qr</code> (default without truncation): Uses QR-based nullspace computation via <a href="../../library/#MatrixAlgebraKit.qr_null"><code>qr_null</code></a></li><li><code>alg = :svd</code> (default with truncation): Uses SVD via <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full</code></a> with appropriate truncation</li></ul><p><strong>For <code>right_null</code>:</strong></p><ul><li><code>alg = :lq</code> (default without truncation): Uses LQ-based nullspace computation via <a href="../../library/#MatrixAlgebraKit.lq_null"><code>lq_null</code></a></li><li><code>alg = :svd</code> (default with truncation): Uses SVD via <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full</code></a> with appropriate truncation</li></ul><p>When <code>alg</code> is not specified, the function automatically selects <code>:qr</code>/<code>:lq</code> for exact nullspace computation, or <code>:svd</code> when a truncation strategy is provided to handle numerical rank determination.</p><div class="admonition is-info" id="Note-4a326b8ea68223ad"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4a326b8ea68223ad" title="Permalink"></a></header><div class="admonition-body"><p>For nullspace functions, <a href="../../library/#MatrixAlgebraKit.notrunc-Tuple{}"><code>notrunc</code></a> has special meaning when used with the default QR/LQ algorithms. It indicates that the nullspace should be computed from the exact zeros determined by the additional rows/columns of the extended matrix, without any tolerance-based truncation.</p></div></div><h3 id="Extending-with-Custom-Algorithms-2"><a class="docs-heading-anchor" href="#Extending-with-Custom-Algorithms-2">Extending with Custom Algorithms</a><a class="docs-heading-anchor-permalink" href="#Extending-with-Custom-Algorithms-2" title="Permalink"></a></h3><p>To register a custom algorithm type for use with these functions, you need to define the appropriate conversion function:</p><pre><code class="language-julia hljs"># For left_null
MatrixAlgebraKit.left_null_alg(alg::MyCustomAlgorithm) = LeftNullAlgorithm{:qr}(alg)

# For right_null
MatrixAlgebraKit.right_null_alg(alg::MyCustomAlgorithm) = RightNullAlgorithm{:lq}(alg)</code></pre><p>The type parameter (<code>:qr</code>, <code>:lq</code>, or <code>:svd</code>) indicates which factorization backend will be used. The wrapper algorithm types handle the dispatch to the appropriate implementation:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LeftNullAlgorithm-user_interface-decompositions" href="#MatrixAlgebraKit.LeftNullAlgorithm-user_interface-decompositions"><code>MatrixAlgebraKit.LeftNullAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LeftNullAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:qr</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L379-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.RightNullAlgorithm-user_interface-decompositions" href="#MatrixAlgebraKit.RightNullAlgorithm-user_interface-decompositions"><code>MatrixAlgebraKit.RightNullAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightNullAlgorithm{Kind, Alg &lt;: AbstractAlgorithm}(alg)</code></pre><p>Wrapper type to denote the <code>Kind</code> of factorization that is used as a backend for <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null</code></a>. By default <code>Kind</code> is a symbol, which can be either <code>:lq</code> or <code>:svd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/decompositions.jl#L407-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_null_alg-user_interface-decompositions" href="#MatrixAlgebraKit.left_null_alg-user_interface-decompositions"><code>MatrixAlgebraKit.left_null_alg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_null_alg(alg::AbstractAlgorithm) -&gt; LeftNullAlgorithm</code></pre><p>Convert an algorithm to a <a href="../../library/#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm</code></a> wrapper for use with <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:qr</code> or <code>:svd</code>) from the algorithm type and wraps it in a <code>LeftNullAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.left_null_alg(alg::CustomAlgorithm) = LeftNullAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="../../library/#MatrixAlgebraKit.LeftNullAlgorithm"><code>LeftNullAlgorithm</code></a>, <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L483-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_null_alg-user_interface-decompositions" href="#MatrixAlgebraKit.right_null_alg-user_interface-decompositions"><code>MatrixAlgebraKit.right_null_alg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_null_alg(alg::AbstractAlgorithm) -&gt; RightNullAlgorithm</code></pre><p>Convert an algorithm to a <a href="../../library/#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm</code></a> wrapper for use with <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null</code></a>.</p><p>This function attempts to deduce the appropriate factorization kind (<code>:lq</code> or <code>:svd</code>) from the algorithm type and wraps it in a <code>RightNullAlgorithm</code>. Custom algorithm types can be registered by defining:</p><pre><code class="language-julia hljs">MatrixAlgebraKit.right_null_alg(alg::CustomAlgorithm) = RightNullAlgorithm{kind}(alg)</code></pre><p>where <code>kind</code> specifies the factorization backend to use.</p><p>See also <a href="../../library/#MatrixAlgebraKit.RightNullAlgorithm"><code>RightNullAlgorithm</code></a>, <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/c52614bffe120e3e63fbbd222230cdc695f476ea/src/interface/orthnull.jl#L517-L533">source</a></section></article><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><p>Basic nullspace computation:</p><pre><code class="language-julia hljs">A = [1.0 2.0 3.0; 4.0 5.0 6.0]  # Rank 2 matrix
N = left_null(A)
size(N) == (2, 0)</code></pre><pre><code class="language-julia hljs">Nᴴ = right_null(A)
size(Nᴴ) == (1, 3) &amp;&amp; norm(A * Nᴴ&#39;) &lt; 1e-14 &amp;&amp; isisometric(Nᴴ; side = :right)</code></pre><p>Computing nullspace with rank detection:</p><pre><code class="language-julia hljs">A = [1.0 2.0; 2.0 4.0; 3.0 6.0]  # Rank 1 matrix (second column = 2*first)
N = left_null(A; alg = :svd, trunc = (atol = 1e-10,))
size(N) == (3, 2) &amp;&amp; norm(A&#39; * N) &lt; 1e-12 &amp;&amp; isisometric(N)</code></pre><p>Using different algorithms:</p><pre><code class="language-julia hljs">A = [1.0 0.0 0.0; 0.0 1.0 0.0]
N1 = right_null(A; alg = :lq)
N2 = right_null(A; alg = :svd)
norm(A * N1&#39;) &lt; 1e-14 &amp;&amp; norm(A * N2&#39;) &lt; 1e-14 &amp;&amp;
    isisometric(N1; side = :right) &amp;&amp; isisometric(N2; side = :right)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compositions/">« Compositions</a><a class="docs-footer-nextpage" href="../truncations/">Truncations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 1 November 2025 12:50">Saturday 1 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
